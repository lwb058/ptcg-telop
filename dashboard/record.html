<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Records</title>
    <link rel="stylesheet" href="css/dashboard.css">
    <style>
        .timeline-wrapper {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .timeline-wrapper .panel-section {
            flex: 1;
            min-width: 0;
            margin-top: 0 !important;
            border-top: none !important;
            padding-top: 0 !important;
        }

        .timeline-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            max-height: 82vh;
        }

        .timeline-item {
            background: #adadad;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 8px;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
        }

        .timeline-item:hover {
            background: #3a3a3a;
        }

        .timeline-item.active {
            border-color: #d30000;
            border-width: 3px;
        }

        .timeline-item.turn-l {
            background-color: rgb(143, 181, 198);
        }

        .timeline-item.turn-r {
            background-color: rgb(226, 169, 153);
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            color: rgb(50, 50, 50);
        }

        .timeline-header>span {
            flex: 1;
            text-align: left;
            margin-left: 10px;
        }

        .timeline-details {
            margin-top: 5px;
            font-size: 0.9em;
            color: #2d2d2d;
            display: none;
        }

        .timeline-item.expanded .timeline-details {
            display: block;
        }

        .controls-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #222;
            border-bottom: 1px solid #444;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        /* Task 1: Timestamp input style */
        .timestamp-input-group {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-family: monospace;
        }

        .timestamp-input {
            width: 35px;
            padding: 2px 4px;
            border: 1px solid #555;
            background: #333;
            color: #ddd;
            border-radius: 3px;
            font-size: 0.9em;
            text-align: center;
            font-family: monospace;
        }

        .timestamp-input:focus {
            outline: none;
            border-color: #d30000;
            background: #3a3a3a;
        }

        .timestamp-input.invalid {
            border-color: #ff6b6b;
            background: #4a2828;
        }

        .timestamp-separator {
            color: #999;
            font-weight: bold;
        }

        /* Task 2: Vertical operations list style */
        .operations-list {
            max-height: 250px;
            overflow-y: auto;
            margin-top: 8px;
        }

        .operation-number {
            display: inline-block;
            min-width: 20px;
            color: #999;
            font-weight: bold;
        }

        /* Scrollbar style */
        .operations-list::-webkit-scrollbar {
            width: 6px;
        }

        .operations-list::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 3px;
        }

        .operations-list::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }

        .operations-list::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        /* Task 3: Modified OpsPack indicator */
        .timeline-item.modified {
            border-left: 3px solid #ffa500;
        }

        .modified-badge {
            display: inline-block;
            background: #ffa500;
            color: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7em;
            margin-left: 6px;
            font-weight: bold;
        }

        .operation-source-badge {
            display: inline-block;
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 0.65em;
            margin-left: 4px;
            font-weight: bold;
        }

        .operation-source-badge.inserted {
            background: #6495ed;
            color: white;
        }

        .operation-source-badge.deleted {
            background: #ff6b6b;
            color: white;
        }

        .operation-content {
            flex: 1;
        }

        .operation-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        /* Timer Edit Popup Styles */
        .timer-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
        }

        .timer-popup-content {
            position: absolute;
            background: #222;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            text-align: center;
            min-width: 250px;
        }

        .timer-popup-display {
            font-family: monospace;
            font-size: 2em;
            margin-bottom: 15px;
            color: #fff;
            background: #000;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .timer-popup-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .timer-popup-btn {
            padding: 8px;
            font-size: 0.9em;
            cursor: pointer;
            background: #333;
            color: #ddd;
            border: 1px solid #555;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .timer-popup-btn:hover {
            background: #444;
            border-color: #777;
        }

        .timer-popup-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            border-top: 1px solid #333;
            padding-top: 10px;
        }

        .panel-disabled {
            opacity: 0.4;
            filter: grayscale(100%);
            pointer-events: none;
            user-select: none;
        }

        /* Inline Confirmation UI for Delete Operation */
        .operation-confirm-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 107, 107, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 4px 8px;
            border-radius: 3px;
            animation: confirmSlideIn 0.2s ease-out;
            z-index: 10;
        }

        @keyframes confirmSlideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .operation-confirm-message {
            color: white;
            font-weight: bold;
            font-size: 0.85em;
            flex: 1;
        }

        .operation-confirm-buttons {
            display: flex;
            gap: 6px;
        }

        .operation-confirm-yes,
        .operation-confirm-no {
            padding: 4px 12px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            font-weight: bold;
            transition: all 0.2s;
        }

        .operation-confirm-yes {
            background: #fff;
            color: #d30000;
        }

        .operation-confirm-yes:hover {
            background: #f0f0f0;
            transform: scale(1.05);
        }

        .operation-confirm-no {
            background: #333;
            color: #fff;
        }

        .operation-confirm-no:hover {
            background: #444;
            transform: scale(1.05);
        }

        .operation-item {
            position: relative;
        }

        .operation-confirm-countdown {
            display: inline-block;
            min-width: 12px;
            text-align: center;
            color: white;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="controls-bar">
        <div class="btn-group" style="display: flex; gap: 5px;">
            <button id="replay-btn" class="btn btn-primary" style="min-width:80px">Replay</button>
            <button id="timer-toggle-btn" class="btn btn-primary">Start</button>
            <button id="pause-btn" class="btn btn-warning" style="display: none;">Pause</button>
            <button id="resume-btn" class="btn btn-primary">Resume</button>
        </div>
        <div id="timer-display" style="font-family: monospace; font-size: 1.2em; color: #ddd; align-self: center;">
            Timer:00:00
        </div>
        <button id="timer-edit-btn" class="btn btn-secondary" style="padding: 2px 8px; margin-left: 5px;">Edit</button>
        <div style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="insert-mode-toggle" checked style="width: auto; height: auto;">
            <label for="insert-mode-toggle" id="insert-mode-label" style="margin: 0; cursor: pointer;">Insert
                Mode</label>
        </div>
        <div
            style="display: flex; align-items: center; gap: 8px; margin-left: 10px; border-left: 1px solid #444; padding-left: 10px;">
            <span style="color: #aaa; font-size: 0.9em;">Tracks:</span>
            <input type="checkbox" id="track-gameplay-toggle" checked style="width: auto; height: auto;">
            <label for="track-gameplay-toggle" style="margin: 0; cursor: pointer; color: #ddd;">Gameplay</label>
            <input type="checkbox" id="track-display-toggle" checked style="width: auto; height: auto;">
            <label for="track-display-toggle" style="margin: 0; cursor: pointer; color: #ddd;">Display</label>
        </div>
        <div class="btn-group" style="display:flex; margin-left: auto; gap:5px;">
            <button id="export-btn" class="btn btn-secondary">Export JSON</button>
            <button id="import-btn" class="btn btn-secondary">Import JSON</button>
        </div>
        <input type="file" id="import-file" style="display: none;" accept=".json">
    </div>

    <!-- Timer Edit Popup -->
    <div id="timer-popup" class="timer-popup-overlay">
        <div class="timer-popup-content">
            <div id="popup-timer-display" class="timer-popup-display">00:00</div>
            <div class="timer-popup-controls">
                <button class="timer-popup-btn" data-adjust="30">+30s</button>
                <button class="timer-popup-btn" data-adjust="5">+5s</button>
                <button class="timer-popup-btn" data-adjust="1">+1s</button>
                <button class="timer-popup-btn" data-adjust="-30">-30s</button>
                <button class="timer-popup-btn" data-adjust="-5">-5s</button>
                <button class="timer-popup-btn" data-adjust="-1">-1s</button>
            </div>
            <div class="timer-popup-actions">
                <button id="timer-popup-cancel" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div class="timeline-wrapper">
        <div class="panel-section" id="panel-gameplay">
            <h3 style="margin-top: 10px;">Timeline - GamePlay</h3>
            <div id="timeline-list" class="timeline-container">
                <!-- Timeline items will be injected here -->
            </div>
        </div>

        <div class="panel-section" id="panel-display">
            <h3 style="margin-top: 10px;">Timeline - Display</h3>
            <div id="timeline-display-list" class="timeline-container">
                <!-- Display Timeline items will be injected here -->
            </div>
        </div>
    </div>

    <script src="js/dashboard.js"></script>
    <script>
        NodeCG.waitForReplicants(
            nodecg.Replicant('timelineGameplay'),
            nodecg.Replicant('timelineDisplay'),
            nodecg.Replicant('playbackConfig'),
            nodecg.Replicant('cardDatabase'),
            nodecg.Replicant('firstMove'),
            nodecg.Replicant('ptcg-settings'),
            nodecg.Replicant('playbackStatus'),
            nodecg.Replicant('i18nStrings'),
            nodecg.Replicant('language'),
            nodecg.Replicant('deckLoadingStatus')
        ).then(() => {
            const timelineGameplay = nodecg.Replicant('timelineGameplay');
            const timelineDisplay = nodecg.Replicant('timelineDisplay');
            const playbackConfig = nodecg.Replicant('playbackConfig');
            const cardDatabase = nodecg.Replicant('cardDatabase');
            const firstMove = nodecg.Replicant('firstMove');
            const settingsRep = nodecg.Replicant('ptcg-settings');
            const playbackStatus = nodecg.Replicant('playbackStatus');
            const matchTimer = nodecg.Replicant('matchTimer');
            const gameTimeSettings = nodecg.Replicant('gameTimeSettings');
            const i18nStrings = nodecg.Replicant('i18nStrings');
            const language = nodecg.Replicant('language');
            const deckLoadingStatus = nodecg.Replicant('deckLoadingStatus');
            const timelineList = document.getElementById('timeline-list');
            const timelineDisplayList = document.getElementById('timeline-display-list');
            const replayBtn = document.getElementById('replay-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const resumeBtn = document.getElementById('resume-btn');
            const exportBtn = document.getElementById('export-btn');
            const importBtn = document.getElementById('import-btn');
            const importFile = document.getElementById('import-file');
            const timerDisplay = document.getElementById('timer-display');
            const insertModeToggle = document.getElementById('insert-mode-toggle');
            const insertModeLabel = document.getElementById('insert-mode-label');
            const trackGameplayToggle = document.getElementById('track-gameplay-toggle');
            const trackDisplayToggle = document.getElementById('track-display-toggle');
            const timerEditBtn = document.getElementById('timer-edit-btn');
            const timerToggleBtn = document.getElementById('timer-toggle-btn');

            // Popup Elements
            const timerPopup = document.getElementById('timer-popup');
            const popupContent = timerPopup.querySelector('.timer-popup-content');
            const popupDisplay = document.getElementById('popup-timer-display');
            const popupCancelBtn = document.getElementById('timer-popup-cancel');
            const popupAdjustBtns = timerPopup.querySelectorAll('.timer-popup-btn');

            let tempSeconds = 0;

            // Local i18n helper function
            function getI18nText(key) {
                if (!i18nStrings.value || !i18nStrings.value[key] || !language.value) {
                    return key; // Fallback to key name if not found
                }
                return i18nStrings.value[key][language.value] || i18nStrings.value[key]['jp'] || key;
            }

            // Update all static UI text with i18n
            function updateStaticUI() {
                // Update control panel buttons
                replayBtn.textContent = getI18nText('record_replay');
                pauseBtn.textContent = getI18nText('record_pause');
                resumeBtn.textContent = getI18nText('record_resume');
                exportBtn.textContent = getI18nText('record_export_json');
                importBtn.textContent = getI18nText('record_import_json');

                // Update track labels
                document.querySelector('span[style*="color: #aaa"]').textContent = getI18nText('record_tracks');
                document.querySelector('label[for="track-gameplay-toggle"]').textContent = getI18nText('record_gameplay');
                document.querySelector('label[for="track-display-toggle"]').textContent = getI18nText('record_display');
            }

            // Playback Config Logic
            function updatePlaybackConfigUI() {
                if (playbackConfig.value) {
                    trackGameplayToggle.checked = playbackConfig.value.gameplay;
                    trackDisplayToggle.checked = playbackConfig.value.display;

                    // Visual feedback for panels
                    const gameplayPanel = document.getElementById('panel-gameplay');
                    const displayPanel = document.getElementById('panel-display');

                    if (gameplayPanel) {
                        if (playbackConfig.value.gameplay) {
                            gameplayPanel.classList.remove('panel-disabled');
                        } else {
                            gameplayPanel.classList.add('panel-disabled');
                        }
                    }

                    if (displayPanel) {
                        if (playbackConfig.value.display) {
                            displayPanel.classList.remove('panel-disabled');
                        } else {
                            displayPanel.classList.add('panel-disabled');
                        }
                    }
                }
            }

            trackGameplayToggle.addEventListener('change', () => {
                playbackConfig.value = { ...playbackConfig.value, gameplay: trackGameplayToggle.checked };
            });

            trackDisplayToggle.addEventListener('change', () => {
                playbackConfig.value = { ...playbackConfig.value, display: trackDisplayToggle.checked };
            });

            playbackConfig.on('change', updatePlaybackConfigUI);

            // Insert Mode toggle logic
            function updateInsertModeUI() {
                const isInsertMode = insertModeToggle.checked;
                insertModeLabel.textContent = isInsertMode ? getI18nText('record_insert_mode') : getI18nText('record_overwrite_mode');
                insertModeLabel.style.color = isInsertMode ? '#ddd' : '#ff6b6b'; // Red for destructive mode
            }

            insertModeToggle.addEventListener('change', () => {
                settingsRep.value = {
                    ...settingsRep.value,
                    insertMode: insertModeToggle.checked
                };
                updateInsertModeUI();
            });

            // Initialize from settings
            if (settingsRep.value && typeof settingsRep.value.insertMode === 'boolean') {
                insertModeToggle.checked = settingsRep.value.insertMode;
            } else {
                insertModeToggle.checked = true; // Default to Insert Mode
            }

            // Initialize static UI text
            updateStaticUI();
            updateInsertModeUI();

            // Update UI when language changes
            language.on('change', () => {
                updateStaticUI();
                updateInsertModeUI();
                renderTimeline();
                renderDisplayTimeline();
            });

            function updateTimerDisplay() {
                if (!matchTimer.value) return;

                // Use server-calculated elapsed time to avoid client-server time sync issues
                let elapsed = matchTimer.value.elapsed || 0;

                // Handle Countdown vs Countup
                let displayTime = elapsed;
                if (gameTimeSettings.value && gameTimeSettings.value.useCountdown) {
                    const limit = (gameTimeSettings.value.limit || 1500) * 1000;
                    displayTime = Math.max(0, limit - elapsed);
                }

                const totalSeconds = Math.floor(displayTime / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                if (matchTimer.value.mode === 'standby') {
                    timerDisplay.innerText = "Standby";
                    timerDisplay.style.color = "#ffcc00";
                    timerEditBtn.disabled = true;
                } else {
                    const modeStr = matchTimer.value.mode === 'playback' ? 'Playback' : 'Live';
                    timerDisplay.innerText = `${modeStr} - ${timeStr}`;
                    timerDisplay.style.color = "#ddd";
                    timerEditBtn.disabled = false;
                }
            }

            matchTimer.on('change', (newValue) => {
                updateTimerDisplay();
                updateControlButtons();
                // Let's use 100ms for consistency.
                if (newValue.isRunning) {
                    if (!window.recordTimerInterval) {
                        window.recordTimerInterval = setInterval(updateTimerDisplay, 100);
                    }
                } else {
                    if (window.recordTimerInterval) {
                        clearInterval(window.recordTimerInterval);
                        window.recordTimerInterval = null;
                    }
                }
            });

            gameTimeSettings.on('change', updateTimerDisplay);

            // Timer Edit Popup Logic
            function updatePopupDisplay() {
                const minutes = Math.floor(tempSeconds / 60);
                const seconds = tempSeconds % 60;
                popupDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            function openTimerPopup() {
                // Initialize with current timer value
                if (matchTimer.value) {
                    // Use server-calculated elapsed time
                    let elapsed = matchTimer.value.elapsed || 0;

                    tempSeconds = Math.floor(elapsed / 1000);
                    updatePopupDisplay();

                    // Show overlay first to calculate dimensions
                    timerPopup.style.display = 'block';
                    timerPopup.style.visibility = 'hidden';

                    // Position popup next to the button
                    const btnRect = timerEditBtn.getBoundingClientRect();
                    const popupRect = popupContent.getBoundingClientRect();

                    // Default: Position below the button for record.html (since it's in top bar)
                    let top = btnRect.bottom + 10;
                    let left = btnRect.left;

                    // Check if it goes off-screen horizontally
                    if (left + popupRect.width > window.innerWidth) {
                        left = window.innerWidth - popupRect.width - 10;
                    }

                    // Check if it goes off-screen vertically
                    if (top + popupRect.height > window.innerHeight) {
                        // Try above
                        top = btnRect.top - popupRect.height - 10;
                    }
                    if (left < 0) left = 10;

                    popupContent.style.top = `${top}px`;
                    popupContent.style.left = `${left}px`;

                    timerPopup.style.visibility = 'visible';
                }
            }

            function closeTimerPopup(save) {
                if (save) {
                    nodecg.sendMessage('timerControl', { action: 'edit', seconds: tempSeconds });
                }
                timerPopup.style.display = 'none';
            }

            timerEditBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent immediate closing
                openTimerPopup();
            });

            popupAdjustBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const adjust = parseInt(btn.dataset.adjust, 10);
                    tempSeconds += adjust;
                    if (tempSeconds < 0) tempSeconds = 0;
                    updatePopupDisplay();
                });
            });

            popupCancelBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                closeTimerPopup(false);
            });

            // Click outside to save and close
            timerPopup.addEventListener('click', (e) => {
                if (e.target === timerPopup) {
                    closeTimerPopup(true);
                }
            });

            // Prevent clicks inside content from closing
            popupContent.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            function getCardName(cardId) {
                const db = cardDatabase.value;
                if (db && db[cardId]) {
                    return db[cardId].name;
                }
                return cardId;
            }

            function formatOpSummary(op) {
                // Use shared formatting logic
                if (window.formatOperation) {
                    return window.formatOperation(op, cardDatabase.value);
                }
                // Fallback if not loaded
                const { type, payload } = op;
                const target = payload.target || ''; // Safe access
                return `${type} (${target})`;
            }

            function renderTimeline() {
                // Save expanded state before re-rendering
                const expandedIndices = new Set();
                const existingItems = timelineList.querySelectorAll('.timeline-item.expanded');
                existingItems.forEach(item => {
                    const index = parseInt(item.dataset.index, 10);
                    if (!isNaN(index)) {
                        expandedIndices.add(index);
                    }
                });

                timelineList.innerHTML = '';
                if (!timelineGameplay.value || timelineGameplay.value.length === 0) {
                    timelineList.innerHTML = '<div style="color: #666; padding: 10px;">No history recorded.</div>';
                    return;
                }

                window.deleteOperation = function (packIndex, opIndices) {
                    if (!timelineGameplay.value || !timelineGameplay.value[packIndex]) return;

                    const newTimeline = [...timelineGameplay.value];
                    const pack = newTimeline[packIndex];
                    const newOps = [...pack.ops];

                    const indicesToDelete = Array.isArray(opIndices) ? opIndices : [opIndices];

                    indicesToDelete.forEach(idx => {
                        if (newOps[idx]) {
                            newOps[idx] = { ...newOps[idx], deleted: true };
                        }
                    });

                    newTimeline[packIndex] = { ...pack, ops: newOps };
                    timelineGameplay.value = newTimeline;
                };

                timelineGameplay.value.forEach((pack, index) => {
                    const item = document.createElement('div');
                    item.classList.add('timeline-item');
                    item.dataset.index = index;

                    // Restore expanded state if it was previously expanded
                    if (expandedIndices.has(index)) {
                        item.classList.add('expanded');
                    }

                    // Determine turn player and add class
                    const firstMover = firstMove.value || 'L';
                    const round = pack.round || 1;
                    const isOdd = round % 2 !== 0;
                    const isPlayerL = (firstMover === 'L' && isOdd) || (firstMover === 'R' && !isOdd);
                    item.classList.add(isPlayerL ? 'turn-l' : 'turn-r');

                    // Highlight active item
                    if (playbackStatus.value && playbackStatus.value.currentIndexGameplay === index) {
                        item.classList.add('active');
                        item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }

                    const opCount = pack.ops.length;

                    // In renderTimeline function, dynamically calculate modified status after creating item
                    const hasInserted = pack.ops.some(op => op.source === 'inserted');
                    const hasDeleted = pack.ops.some(op => op.deleted);
                    const isModified = hasInserted || hasDeleted;

                    if (isModified) {
                        item.classList.add('modified');
                    }

                    // Calculate visual counts (grouping SLIDE_OUT + APPLY_SWITCH)
                    let visualTotal = 0;
                    let visualActive = 0;

                    for (let i = 0; i < pack.ops.length; i++) {
                        const op = pack.ops[i];
                        const nextOp = pack.ops[i + 1];

                        // Skip SLIDE_OUT if it's the first part of a switch pair
                        if (op.type === 'SLIDE_OUT' && nextOp && nextOp.type === 'APPLY_SWITCH') {
                            continue;
                        }

                        visualTotal++;
                        if (!op.deleted) {
                            visualActive++;
                        }
                    }

                    // Calculate the count of each type of operation (raw counts strictly referencing data)
                    const nativeCount = pack.ops.filter(op => !op.source && !op.deleted).length;
                    const insertedCount = pack.ops.filter(op => op.source === 'inserted' && !op.deleted).length;
                    const deletedCount = pack.ops.filter(op => op.deleted).length;

                    // Modify HTML template, add modified badge after Round info (only shown when modified)
                    const modifiedBadge = isModified
                        ? `<span class="modified-badge" title="${getI18nText('record_opspack_modified_tooltip')}\n${getI18nText('record_native')}: ${nativeCount}, ${getI18nText('record_inserted')}: ${insertedCount}, ${getI18nText('record_deleted')}: ${deletedCount}">${getI18nText('record_modified')}</span>`
                        : '';

                    // Parse current timestamp
                    const [minutes, seconds] = pack.timestamp.split(':').map(Number);

                    // Helper functions for source and badges
                    const getSourceClass = (op) => op.source || 'native';
                    const getSourceBadge = (op) => op.source === 'inserted' ? `<span class="operation-source-badge inserted">${getI18nText('record_inserted')}</span>` : '';

                    let displayCounter = 0; // Initialize counter for visible items

                    // Create the operations list HTML
                    const operationsHTML = pack.ops.map((op, idx) => {
                        const source = getSourceClass(op);
                        const sourceBadge = getSourceBadge(op);
                        const isDeleted = op.deleted;
                        const deletedBadge = isDeleted ? `<span class="operation-source-badge deleted">${getI18nText('record_deleted')}</span>` : '';

                        // --- Grouping Logic: SLIDE_OUT ---
                        // Skip SLIDE_OUT if it's part of a switch pair (followed by APPLY_SWITCH)
                        if (op.type === 'SLIDE_OUT') {
                            const nextOp = pack.ops[idx + 1];
                            if (nextOp && nextOp.type === 'APPLY_SWITCH') {
                                return ''; // Skip rendering
                            }
                        }

                        // Increment visible counter
                        displayCounter++;

                        // --- Grouping Logic: APPLY_SWITCH ---
                        let indices = [idx];
                        if (op.type === 'APPLY_SWITCH') {
                            const prevOp = pack.ops[idx - 1];
                            if (prevOp && prevOp.type === 'SLIDE_OUT') {
                                // It's a pair! Target both.
                                indices = [idx - 1, idx];
                            }
                        }

                        const actionButton = isDeleted
                            ? `<button class="btn btn-restore-op" data-op-indices='${JSON.stringify(indices)}' title="Restore">↩</button>`
                            : `<button class="btn btn-delete-op" data-op-indices='${JSON.stringify(indices)}' title="Delete">✕</button>`;

                        return `
                        <div class="operation-item ${source} ${isDeleted ? 'deleted-op' : ''}" data-op-index="${idx}">
                            <div class="operation-content">
                                <span class="operation-number">${displayCounter}.</span> ${formatOpSummary(op)}${sourceBadge}${deletedBadge}
                            </div>
                            <div class="operation-actions">
                                ${actionButton}
                            </div>
                        </div>
                    `;
                    }).join('');

                    // Modify timestamp display in timeline-header
                    item.innerHTML = `
						<div class="timeline-header">
							<button class="btn btn-sm btn-primary seek-btn" data-index="${index}" style="margin-left: 10px;">${getI18nText('record_seek')}</button>
							<span>
								<span class="timestamp-input-group">
									<input type="number" 
										   class="timestamp-input timestamp-minutes" 
										   min="0" 
										   max="99" 
										   value="${minutes}" 
										   data-index="${index}">
									<span class="timestamp-separator">:</span>
									<input type="number" 
										   class="timestamp-input timestamp-seconds" 
										   value="${seconds}" 
										   data-index="${index}">
								</span>
								| ${getI18nText('record_round')} ${pack.round || 1} - ${visualActive}/${visualTotal} ${getI18nText('record_ops')}${modifiedBadge}</span>
							</span>
							<div>
								<button class="btn btn-sm btn-danger delete-btn" data-index="${index}" style="margin-left: 10px;">${getI18nText('delete')}</button>
							</div>
						</div>
						<div class="timeline-details">
							<div class="operations-list">
								${operationsHTML}
							</div>
						</div>
					`;

                    item.addEventListener('click', (e) => {
                        // Expand/collapse logic, but ignore clicks on any button
                        if (e.target.closest('button, input')) return;
                        item.classList.toggle('expanded');
                    });

                    // Event delegation for operations list
                    const opsListEl = item.querySelector('.operations-list');
                    opsListEl.addEventListener('click', (e) => {
                        const target = e.target;
                        if (target.classList.contains('btn-delete-op')) {
                            e.stopPropagation();
                            const indices = JSON.parse(target.dataset.opIndices);
                            const opsToDelete = indices.map(i => pack.ops[i]);
                            const isAllNative = opsToDelete.every(o => !o.source || o.source === 'native');

                            if (isAllNative) {
                                nodecg.sendMessage('deleteOperation', { opsPackIndex: index, operationIndex: indices })
                                    .catch(err => alert('Failed to delete operation: ' + err.message));
                            } else {
                                // Show inline confirmation for inserted operations
                                const operationItem = target.closest('.operation-item');
                                if (!operationItem) return;

                                // Prevent multiple confirmations
                                if (operationItem.querySelector('.operation-confirm-overlay')) return;

                                const summary = opsToDelete.map(o => formatOpSummary(o)).join(', ');

                                // Create confirmation overlay
                                const confirmOverlay = document.createElement('div');
                                confirmOverlay.className = 'operation-confirm-overlay';

                                let countdown = 3;
                                confirmOverlay.innerHTML = `
                                    <div class="operation-confirm-message">
                                        Permanent Delete <strong>${summary}</strong>? (<span class="operation-confirm-countdown">${countdown}</span>s)
                                    </div>
                                    <div class="operation-confirm-buttons">
                                        <button class="operation-confirm-yes">Yes</button>
                                        <button class="operation-confirm-no">No</button>
                                    </div>
                                `;

                                // Add overlay to operation item
                                operationItem.appendChild(confirmOverlay);

                                // Auto-dismiss timer
                                let dismissTimer = null;
                                let countdownInterval = null;

                                const cleanup = () => {
                                    if (dismissTimer) clearTimeout(dismissTimer);
                                    if (countdownInterval) clearInterval(countdownInterval);
                                    if (confirmOverlay.parentNode) {
                                        confirmOverlay.remove();
                                    }
                                };

                                // Update countdown every second
                                const countdownDisplay = confirmOverlay.querySelector('.operation-confirm-countdown');
                                countdownInterval = setInterval(() => {
                                    countdown--;
                                    if (countdownDisplay && countdown > 0) {
                                        countdownDisplay.textContent = countdown;
                                    }
                                }, 1000);

                                // Auto-dismiss after 3 seconds
                                dismissTimer = setTimeout(() => {
                                    cleanup();
                                }, 3000);

                                // Yes button - proceed with deletion
                                const yesBtn = confirmOverlay.querySelector('.operation-confirm-yes');
                                yesBtn.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    cleanup();
                                    nodecg.sendMessage('deleteOperation', { opsPackIndex: index, operationIndex: indices })
                                        .catch(err => alert('Failed to delete operation: ' + err.message));
                                });

                                // No button - cancel
                                const noBtn = confirmOverlay.querySelector('.operation-confirm-no');
                                noBtn.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    cleanup();
                                });

                                // Stop propagation on overlay clicks
                                confirmOverlay.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                });
                            }
                        } else if (target.classList.contains('btn-restore-op')) {
                            e.stopPropagation();
                            const indices = JSON.parse(target.dataset.opIndices);
                            nodecg.sendMessage('restoreOperation', { opsPackIndex: index, operationIndex: indices })
                                .catch(err => alert('Failed to restore operation: ' + err.message));
                        }
                    });

                    // New: Time input field event handling
                    const minutesInput = item.querySelector('.timestamp-minutes');
                    const secondsInput = item.querySelector('.timestamp-seconds');

                    function validateAndUpdateTimestamp(inputElement) {
                        const minutes = parseInt(minutesInput.value) || 0;
                        let seconds = parseInt(secondsInput.value) || 0;

                        // Validate seconds range
                        if (seconds < 0) seconds = 0;
                        if (seconds > 59) seconds = 59;

                        // Validate minutes range
                        const validMinutes = Math.max(0, Math.min(99, minutes));

                        // Update display values (handle invalid input)
                        minutesInput.value = validMinutes;
                        secondsInput.value = seconds;

                        // Check input validity
                        const isValid = seconds >= 0 && seconds <= 59 && validMinutes >= 0;

                        if (!isValid) {
                            inputElement.classList.add('invalid');
                            return;
                        }

                        inputElement.classList.remove('invalid');

                        // Build new timestamp
                        const newTimestamp = `${validMinutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                        // Only send update when timestamp actually changes
                        if (newTimestamp !== pack.timestamp) {
                            nodecg.sendMessage('editOpsPack', { index, newTimestamp })
                                .catch(err => {
                                    alert('Failed to update timestamp: ' + err);
                                    // Restore original value
                                    const [origMin, origSec] = pack.timestamp.split(':').map(Number);
                                    minutesInput.value = origMin;
                                    secondsInput.value = origSec;
                                });
                        }
                    }

                    // Use blur event (triggered on focus loss) to avoid frequent updates
                    minutesInput.addEventListener('blur', (e) => validateAndUpdateTimestamp(e.target));
                    secondsInput.addEventListener('blur', (e) => validateAndUpdateTimestamp(e.target));

                    // Support Enter key for quick confirmation
                    minutesInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.target.blur();
                        }
                    });
                    secondsInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.target.blur();
                        }
                    });

                    // Seconds input field: handle carry-over and borrow for both keyboard and spinner clicks
                    let lastSecondsValue = seconds;

                    secondsInput.addEventListener('input', (e) => {
                        let value = parseInt(e.target.value) || 0;
                        let currentMinutes = parseInt(minutesInput.value) || 0;

                        if (value >= 60) {
                            const extraMinutes = Math.floor(value / 60);
                            const newSeconds = value % 60;

                            currentMinutes += extraMinutes;
                            if (currentMinutes > 99) currentMinutes = 99; // Cap at max

                            minutesInput.value = currentMinutes;
                            secondsInput.value = newSeconds;
                            lastSecondsValue = newSeconds;
                        }
                        else if (value < 0) {
                            if (currentMinutes > 0) {
                                minutesInput.value = currentMinutes - 1;
                                secondsInput.value = 59;
                                lastSecondsValue = 59;
                            } else { // Can't go negative
                                secondsInput.value = 0;
                                lastSecondsValue = 0;
                            }
                        } else {
                            lastSecondsValue = value;
                        }
                    });

                    // Handle arrow key presses for seamless minute/second transitions
                    secondsInput.addEventListener('keydown', (e) => {
                        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                            e.preventDefault(); // Prevent default browser behavior

                            let currentSeconds = parseInt(secondsInput.value) || 0;
                            let currentMinutes = parseInt(minutesInput.value) || 0;

                            if (e.key === 'ArrowUp') {
                                currentSeconds++;
                                // Carry over to minutes when reaching 60
                                if (currentSeconds >= 60) {
                                    currentSeconds = 0;
                                    currentMinutes++;
                                    if (currentMinutes > 99) currentMinutes = 99; // Cap at max
                                }
                            } else if (e.key === 'ArrowDown') {
                                currentSeconds--;
                                // Borrow from minutes when going below 0
                                if (currentSeconds < 0) {
                                    if (currentMinutes > 0) {
                                        currentSeconds = 59;
                                        currentMinutes--;
                                    } else {
                                        currentSeconds = 0; // Can't go negative if no minutes to borrow
                                    }
                                }
                            }

                            // Update both inputs
                            minutesInput.value = currentMinutes;
                            secondsInput.value = currentSeconds;

                            // Trigger validation and update
                            validateAndUpdateTimestamp(secondsInput);
                        }
                    });

                    // Handle arrow key presses for minutes (optional enhancement)
                    minutesInput.addEventListener('keydown', (e) => {
                        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                            e.preventDefault();

                            let currentMinutes = parseInt(minutesInput.value) || 0;

                            if (e.key === 'ArrowUp') {
                                currentMinutes++;
                                if (currentMinutes > 99) currentMinutes = 99;
                            } else if (e.key === 'ArrowDown') {
                                currentMinutes--;
                                if (currentMinutes < 0) currentMinutes = 0;
                            }

                            minutesInput.value = currentMinutes;
                            validateAndUpdateTimestamp(minutesInput);
                        }
                    });

                    const deleteBtn = item.querySelector('.delete-btn');
                    deleteBtn.addEventListener('click', () => {
                        // Analyze OpsPack composition
                        const nativeOps = pack.ops.filter(op => !op.source || op.source === 'native');
                        const insertedOps = pack.ops.filter(op => op.source === 'inserted');
                        const nativeCount = nativeOps.length;
                        const insertedCount = insertedOps.length;

                        // Build detailed confirmation message
                        let confirmMessage = getI18nText('record_delete_opspack_confirm') || 'Delete all operations in this OpsPack?';
                        confirmMessage += '\n\n';

                        if (nativeCount > 0) {
                            confirmMessage += `• ${nativeCount} ${getI18nText('record_native')} ${nativeCount === 1 ? 'operation' : 'operations'} will be marked as deleted (can be restored)\n`;
                        }

                        if (insertedCount > 0) {
                            confirmMessage += `• ${insertedCount} ${getI18nText('record_inserted')} ${insertedCount === 1 ? 'operation' : 'operations'} will be permanently removed\n`;
                        }

                        confirmMessage += '\n';

                        // Determine if OpsPack will be deleted
                        if (insertedCount > 0 && nativeCount === 0) {
                            confirmMessage += getI18nText('record_opspack_will_be_deleted') || 'The OpsPack itself will also be deleted.';
                        } else {
                            confirmMessage += getI18nText('record_opspack_will_be_kept') || 'The OpsPack will be kept for potential restoration.';
                        }

                        if (confirm(confirmMessage)) {
                            nodecg.sendMessage('deleteOpsPack', index)
                                .catch(err => alert('Failed to delete: ' + err));
                        }
                    });

                    const seekBtn = item.querySelector('.seek-btn');
                    seekBtn.addEventListener('click', () => {
                        if (confirm(`Restore to timestamp ${pack.timestamp}? This will reset the board and fast-forward.`)) {
                            nodecg.sendMessage('seekTimeline', index);
                        }
                    });

                    timelineList.appendChild(item);
                });
            }

            function renderDisplayTimeline() {
                // Save expanded state before re-rendering
                const expandedIndices = new Set();
                const existingItems = timelineDisplayList.querySelectorAll('.timeline-item.expanded');
                existingItems.forEach(item => {
                    const index = parseInt(item.dataset.index, 10);
                    if (!isNaN(index)) {
                        expandedIndices.add(index);
                    }
                });

                timelineDisplayList.innerHTML = '';
                if (!timelineDisplay.value || timelineDisplay.value.length === 0) {
                    timelineDisplayList.innerHTML = '<div style="color: #666; padding: 10px;">No display history recorded.</div>';
                    return;
                }

                timelineDisplay.value.forEach((op, index) => {
                    const item = document.createElement('div');
                    item.classList.add('timeline-item');
                    item.dataset.index = index;

                    // Restore expanded state if it was previously expanded
                    if (expandedIndices.has(index)) {
                        item.classList.add('expanded');
                    }

                    // Determine side and add class
                    let side = null;
                    if (op.payload && op.payload.side) {
                        side = op.payload.side;
                    } else if (op.type.endsWith('_L')) {
                        side = 'L';
                    } else if (op.type.endsWith('_R')) {
                        side = 'R';
                    }

                    if (side === 'L') item.classList.add('turn-l');
                    if (side === 'R') item.classList.add('turn-r');

                    // Highlight active item
                    if (playbackStatus.value && playbackStatus.value.currentIndexDisplay === index) {
                        item.classList.add('active');
                    }

                    let summary = '';
                    if (op.type === 'SHOW_CARD_L' || op.type === 'SHOW_CARD_R') {
                        summary = `Show Card (${op.payload.side}): ${getCardName(op.payload.cardId)}`;
                    } else if (op.type === 'SHOW_PRIZE_L' || op.type === 'SHOW_PRIZE_R') {
                        summary = `Show Prize (${op.payload.side})`;
                    } else if (op.type === 'HIDE_DISPLAY') {
                        summary = `Hide Display`;
                    } else if (op.type === 'TOGGLE_EXTRA_BENCH') {
                        summary = `Extra Bench (${op.payload.side}): ${op.payload.visible ? 'Show' : 'Hide'}`;
                    } else if (op.type === 'TOGGLE_PRIZE_TAKEN') {
                        const cardName = (op.payload.cardId && cardDatabase.value && cardDatabase.value[op.payload.cardId])
                            ? cardDatabase.value[op.payload.cardId].name
                            : null;
                        const status = op.payload.isTaken ? 'Taken' : 'Untaken';
                        summary = cardName
                            ? `Prize (${op.payload.side}) #${op.payload.index + 1}: ${cardName} ${status}`
                            : `Prize (${op.payload.side}) #${op.payload.index + 1}: ${status}`;
                    } else if (op.type === 'SET_PRIZE_CARD') {
                        const cardName = (cardDatabase.value && cardDatabase.value[op.payload.cardId])
                            ? cardDatabase.value[op.payload.cardId].name
                            : op.payload.cardId;
                        summary = `Set Prize (${op.payload.side}) #${op.payload.index + 1}: ${cardName}`;
                    } else if (op.type === 'CLEAR_PRIZE_CARDS') {
                        summary = `Clear Prizes (${op.payload.side})`;
                    } else {
                        summary = op.type;
                    }

                    // Apply similar modifications in renderDisplayTimeline function
                    const [minutes, seconds] = op.timestamp.split(':').map(Number);

                    item.innerHTML = `
            						<div class="timeline-header">
            							<button class="btn btn-sm btn-primary seek-btn" data-index="${index}" style="margin-left: 10px;">${getI18nText('record_seek')}</button>
            							<span>
            								<span class="timestamp-input-group">
            									<input type="number" 
            										   class="timestamp-input timestamp-minutes" 
            										   min="0" 
            										   max="99" 
            										   value="${minutes}" 
            										   data-index="${index}">
            									<span class="timestamp-separator">:</span>
            									<input type="number" 
            										   class="timestamp-input timestamp-seconds" 
            										   min="0" 
            										   max="59" 
            										   value="${seconds}" 
            										   data-index="${index}">
            								</span>
            								| ${summary}
            							</span>
            							<div>
            								<button class="btn btn-sm btn-danger delete-btn" data-index="${index}" style="margin-left: 10px;">${getI18nText('delete')}</button>
            							</div>
            						</div>
            					`;

                    // Add same input validation logic, but use editDisplayOp message
                    const minutesInput = item.querySelector('.timestamp-minutes');
                    const secondsInput = item.querySelector('.timestamp-seconds');

                    function validateAndUpdateTimestamp(inputElement) {
                        const minutes = parseInt(minutesInput.value) || 0;
                        let seconds = parseInt(secondsInput.value) || 0;

                        if (seconds < 0) seconds = 0;
                        if (seconds > 59) seconds = 59;
                        const validMinutes = Math.max(0, Math.min(99, minutes));

                        minutesInput.value = validMinutes;
                        secondsInput.value = seconds;

                        const isValid = seconds >= 0 && seconds <= 59 && validMinutes >= 0;

                        if (!isValid) {
                            inputElement.classList.add('invalid');
                            return;
                        }

                        inputElement.classList.remove('invalid');

                        const newTimestamp = `${validMinutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                        if (newTimestamp !== op.timestamp) {
                            nodecg.sendMessage('editDisplayOp', { index, newTimestamp })
                                .catch(err => {
                                    alert('Failed to update timestamp: ' + err);
                                    const [origMin, origSec] = op.timestamp.split(':').map(Number);
                                    minutesInput.value = origMin;
                                    secondsInput.value = origSec;
                                });
                        }
                    }

                    minutesInput.addEventListener('blur', (e) => validateAndUpdateTimestamp(e.target));
                    secondsInput.addEventListener('blur', (e) => validateAndUpdateTimestamp(e.target));
                    minutesInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') e.target.blur(); });
                    secondsInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') e.target.blur(); });

                    secondsInput.addEventListener('input', (e) => {
                        let value = parseInt(e.target.value);
                        if (value > 59) {
                            const extraMinutes = Math.floor(value / 60);
                            const newSeconds = value % 60;
                            const currentMinutes = parseInt(minutesInput.value) || 0;
                            minutesInput.value = currentMinutes + extraMinutes;
                            secondsInput.value = newSeconds;
                        }
                    });

                    const deleteBtn = item.querySelector('.delete-btn');
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();

                        // Prevent multiple confirmations
                        if (item.querySelector('.operation-confirm-overlay')) return;

                        // Create confirmation overlay
                        const confirmOverlay = document.createElement('div');
                        confirmOverlay.className = 'operation-confirm-overlay';

                        let countdown = 3;
                        confirmOverlay.innerHTML = `
                            <div class="operation-confirm-message">
                                Delete <strong>${summary}</strong>? (<span class="operation-confirm-countdown">${countdown}</span>s)
                            </div>
                            <div class="operation-confirm-buttons">
                                <button class="operation-confirm-yes">Yes</button>
                                <button class="operation-confirm-no">No</button>
                            </div>
                        `;

                        // Add overlay to timeline item
                        item.appendChild(confirmOverlay);

                        // Auto-dismiss timer
                        let dismissTimer = null;
                        let countdownInterval = null;

                        const cleanup = () => {
                            if (dismissTimer) clearTimeout(dismissTimer);
                            if (countdownInterval) clearInterval(countdownInterval);
                            if (confirmOverlay.parentNode) {
                                confirmOverlay.remove();
                            }
                        };

                        // Update countdown every second
                        const countdownDisplay = confirmOverlay.querySelector('.operation-confirm-countdown');
                        countdownInterval = setInterval(() => {
                            countdown--;
                            if (countdownDisplay && countdown > 0) {
                                countdownDisplay.textContent = countdown;
                            }
                        }, 1000);

                        // Auto-dismiss after 3 seconds
                        dismissTimer = setTimeout(() => {
                            cleanup();
                        }, 3000);

                        // Yes button - proceed with deletion
                        const yesBtn = confirmOverlay.querySelector('.operation-confirm-yes');
                        yesBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            cleanup();
                            nodecg.sendMessage('deleteDisplayOp', index)
                                .catch(err => alert('Failed to delete: ' + err));
                        });

                        // No button - cancel
                        const noBtn = confirmOverlay.querySelector('.operation-confirm-no');
                        noBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            cleanup();
                        });

                        // Stop propagation on overlay clicks
                        confirmOverlay.addEventListener('click', (e) => {
                            e.stopPropagation();
                        });
                    });

                    const restoreBtn = item.querySelector('.seek-btn');
                    restoreBtn.addEventListener('click', () => {
                        const targetTime = op.timestamp;
                        if (confirm(`Restore to timestamp ${targetTime}? This will reset the board and fast-forward.`)) {
                            nodecg.sendMessage('seekToTimestamp', targetTime);
                        }
                    });

                    timelineDisplayList.appendChild(item);
                });
            }
            timelineGameplay.on('change', renderTimeline);
            timelineDisplay.on('change', renderDisplayTimeline);
            nodecg.listenFor('timelineRefreshed', () => {
                renderTimeline();
                renderDisplayTimeline();
            });

            nodecg.listenFor('opsPackMerged', (data) => {
                console.log(`OpsPack modified at ${data.timestamp}: ${data.newOpsCount} new ops appended, total ${data.totalOps} ops`);
                // UI will automatically refresh through timelineGameplay's change event
            });

            function updateControlButtons() {
                if (!matchTimer.value) return;

                const isPlaybackMode = matchTimer.value.mode === 'playback';
                const isRunning = matchTimer.value.isRunning;

                // Timer Toggle Button (Start/Stop) - Only in Live mode
                if (isPlaybackMode) {
                    timerToggleBtn.style.display = 'none';
                } else {
                    timerToggleBtn.style.display = 'inline-block';
                    // Update Start/Stop text/class based on isRunning
                    if (isRunning) {
                        timerToggleBtn.textContent = 'Stop';
                        timerToggleBtn.classList.remove('btn-primary');
                        timerToggleBtn.classList.add('btn-warning');
                    } else {
                        timerToggleBtn.textContent = 'Start';
                        timerToggleBtn.classList.remove('btn-warning');
                        timerToggleBtn.classList.add('btn-primary');
                    }
                }

                // Pause/Resume Buttons - Only in Playback mode
                if (isPlaybackMode && playbackStatus.value) {
                    const isPlaying = playbackStatus.value.isPlaying;
                    if (isPlaying) {
                        pauseBtn.style.display = 'inline-block';
                        resumeBtn.style.display = 'none';
                    } else {
                        pauseBtn.style.display = 'none';
                        resumeBtn.style.display = 'inline-block';
                    }
                } else {
                    pauseBtn.style.display = 'none';
                    resumeBtn.style.display = 'none';
                }
            }

            playbackStatus.on('change', (newVal) => {
                if (newVal) {
                    renderTimeline();
                    renderDisplayTimeline();
                    updateControlButtons();
                }
            });

            // Replay button countdown state
            let replayCountdownTimer = null;
            let replayCountdownInterval = null;
            let replayCountdown = 0;

            replayBtn.addEventListener('click', () => {
                // If countdown is active, cancel it
                if (replayCountdownTimer) {
                    clearTimeout(replayCountdownTimer);
                    clearInterval(replayCountdownInterval);
                    replayCountdownTimer = null;
                    replayCountdownInterval = null;
                    replayCountdown = 0;

                    // Restore original i18n text
                    replayBtn.textContent = getI18nText('record_replay');
                    replayBtn.classList.remove('btn-danger');
                    replayBtn.classList.add('btn-primary');
                    return;
                }

                // Start countdown
                replayCountdown = 3;
                replayBtn.classList.remove('btn-primary');
                replayBtn.classList.add('btn-danger');

                // Update button text with countdown
                const updateCountdownText = () => {
                    const baseText = getI18nText('record_replay');
                    replayBtn.textContent = `${baseText} (${replayCountdown})`;
                };

                updateCountdownText();

                // Update countdown every second
                replayCountdownInterval = setInterval(() => {
                    replayCountdown--;
                    if (replayCountdown > 0) {
                        updateCountdownText();
                    }
                }, 1000);

                // Execute replay after 3 seconds
                replayCountdownTimer = setTimeout(() => {
                    clearInterval(replayCountdownInterval);
                    replayCountdownTimer = null;
                    replayCountdownInterval = null;
                    replayCountdown = 0;

                    // Restore button appearance
                    replayBtn.textContent = getI18nText('record_replay');
                    replayBtn.classList.remove('btn-warning');
                    replayBtn.classList.add('btn-primary');

                    // Execute replay
                    nodecg.sendMessage('playTimeline');
                }, 3000);
            });

            timerToggleBtn.addEventListener('click', () => {
                const action = matchTimer.value.isRunning ? 'stop' : 'start';
                nodecg.sendMessage('timerControl', { action });
            });

            pauseBtn.addEventListener('click', () => {
                nodecg.sendMessage('pauseTimeline');
            });

            resumeBtn.addEventListener('click', () => {
                nodecg.sendMessage('resumeTimeline');
            });

            exportBtn.addEventListener('click', () => {
                nodecg.sendMessage('exportTimeline').then(jsonString => {
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(jsonString);
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    downloadAnchorNode.setAttribute("download", `match_data_${Date.now()}.json`);
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                }).catch(err => {
                    alert('Failed to export timeline: ' + err.message);
                });
            });

            importBtn.addEventListener('click', () => {
                importFile.click();
            });

            let isImporting = false;

            importFile.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const json = event.target.result;
                        // Validate JSON
                        JSON.parse(json);
                        if (confirm('Importing will overwrite the current timeline and decks. Continue?')) {
                            isImporting = true;
                            importBtn.disabled = true;
                            exportBtn.disabled = true;
                            importBtn.textContent = "Initializing...";

                            nodecg.sendMessage('importTimeline', json)
                                .then(() => alert('Import successful!'))
                                .catch(err => alert('Import failed: ' + err))
                                .finally(() => {
                                    isImporting = false;
                                    importBtn.disabled = false;
                                    exportBtn.disabled = false;
                                    importBtn.textContent = getI18nText('record_import_json');
                                });
                        }
                    } catch (err) {
                        alert('Invalid JSON file.');
                    }
                };
                reader.readAsText(file);
                // Reset value so same file can be selected again
                importFile.value = '';
            });

            deckLoadingStatus.on('change', (newVal) => {
                if (isImporting && newVal && newVal.loading) {
                    importBtn.textContent = newVal.text || `Importing... ${newVal.percentage}%`;
                }
            });
        });
    </script>
</body>

</html>