<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Records</title>
    <link rel="stylesheet" href="css/dashboard.css">
    <style>
        .timeline-wrapper {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .timeline-wrapper .panel-section {
            flex: 1;
            min-width: 0;
            margin-top: 0 !important;
            border-top: none !important;
            padding-top: 0 !important;
        }

        .timeline-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .timeline-item {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .timeline-item:hover {
            background: #3a3a3a;
        }

        .timeline-item.active {
            border-color: #d30000;
            border-width: 3px;
        }

        .timeline-item.turn-l {
            background-color: rgb(143, 181, 198);
        }

        .timeline-item.turn-r {
            background-color: rgb(226, 169, 153);
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            color: #ddd;
        }

        .timeline-details {
            margin-top: 5px;
            font-size: 0.9em;
            color: #2d2d2d;
            display: none;
        }

        .timeline-item.expanded .timeline-details {
            display: block;
        }

        .controls-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #222;
            border-bottom: 1px solid #444;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        /* Task 1: Timestamp input style */
        .timestamp-input-group {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-family: monospace;
        }

        .timestamp-input {
            width: 35px;
            padding: 2px 4px;
            border: 1px solid #555;
            background: #333;
            color: #ddd;
            border-radius: 3px;
            font-size: 0.9em;
            text-align: center;
            font-family: monospace;
        }

        .timestamp-input:focus {
            outline: none;
            border-color: #d30000;
            background: #3a3a3a;
        }

        .timestamp-input.invalid {
            border-color: #ff6b6b;
            background: #4a2828;
        }

        .timestamp-separator {
            color: #999;
            font-weight: bold;
        }

        /* 任务2: 垂直操作列表样式 */
        .operations-list {
            max-height: 250px;
            overflow-y: auto;
            margin-top: 8px;
        }

        .operation-item {
            padding: 4px 8px;
            margin: 2px 0;
            background: rgba(255, 255, 255, 0.05);
            border-left: 2px solid #555;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .operation-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-left-color: #d30000;
        }

        .operation-number {
            display: inline-block;
            min-width: 20px;
            color: #999;
            font-weight: bold;
        }

        /* Scrollbar style */
        .operations-list::-webkit-scrollbar {
            width: 6px;
        }

        .operations-list::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 3px;
        }

        .operations-list::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }

        .operations-list::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        /* Task 3: Modified OpsPack indicator */
        .timeline-item.modified {
            background: rgba(255, 165, 0, 0.08);
            /* Light orange background */
            border-left: 3px solid #ffa500;
        }

        .modified-badge {
            display: inline-block;
            background: #ffa500;
            color: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7em;
            margin-left: 6px;
            font-weight: bold;
        }

        /* Operation source indicators */
        .operation-item.native {
            /* Default style - native recording */
        }

        .operation-item.inserted {
            background: rgba(100, 149, 237, 0.15);
            /* Light blue background */
            border-left-color: #6495ed;
            /* Blue left border */
        }

        .operation-item.deleted {
            opacity: 0.4;
            text-decoration: line-through;
            background: rgba(255, 0, 0, 0.05);
        }

        .operation-source-badge {
            display: inline-block;
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 0.65em;
            margin-left: 4px;
            font-weight: bold;
        }

        .operation-source-badge.inserted {
            background: #6495ed;
            color: white;
        }

        .operation-source-badge.deleted {
            background: #ff6b6b;
            color: white;
        }

        /* Task 4: Operation item with delete button */
        .operation-item {
            padding: 4px 8px;
            margin: 2px 0;
            background: rgba(255, 255, 255, 0.05);
            border-left: 2px solid #555;
            font-size: 0.85em;
            line-height: 1.4;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .operation-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-left-color: #d30000;
        }

        .operation-content {
            flex: 1;
        }

        .operation-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .operation-item:hover .operation-actions {
            opacity: 1;
        }

        .btn-delete-op {
            padding: 2px 6px;
            font-size: 0.7em;
            background: #d30000;
            border: none;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-delete-op:hover {
            background: #ff0000;
        }

        .btn-restore-op {
            padding: 2px 6px;
            font-size: 0.7em;
            background: #28a745;
            border: none;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-restore-op:hover {
            background: #218838;
        }

        .operation-item.deleted-op {
            background: rgba(80, 80, 80, 0.2);
        }
    </style>
</head>

<body>
    <div class="controls-bar">
        <div class="btn-group">
            <button id="play-btn" class="btn btn-primary">Replay</button>
            <button id="pause-btn" class="btn btn-warning" style="display: none;">Pause</button>
            <button id="resume-btn" class="btn btn-primary">Resume</button>
        </div>
        <div id="timer-display" style="font-family: monospace; font-size: 1.2em; color: #ddd; align-self: center;">
            Timer:00:00
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="insert-mode-toggle" checked style="width: auto; height: auto;">
            <label for="insert-mode-toggle" id="insert-mode-label" style="margin: 0; cursor: pointer;">Insert
                Mode</label>
        </div>
        <div
            style="display: flex; align-items: center; gap: 8px; margin-left: 10px; border-left: 1px solid #444; padding-left: 10px;">
            <span style="color: #aaa; font-size: 0.9em;">Tracks:</span>
            <input type="checkbox" id="track-gameplay-toggle" checked style="width: auto; height: auto;">
            <label for="track-gameplay-toggle" style="margin: 0; cursor: pointer; color: #ddd;">Gameplay</label>
            <input type="checkbox" id="track-display-toggle" checked style="width: auto; height: auto;">
            <label for="track-display-toggle" style="margin: 0; cursor: pointer; color: #ddd;">Display</label>
        </div>
        <div class="btn-group" style="margin-left: auto;">
            <button id="export-btn" class="btn btn-secondary">Export JSON</button>
            <button id="import-btn" class="btn btn-secondary">Import JSON</button>
        </div>
        <input type="file" id="import-file" style="display: none;" accept=".json">
    </div>

    <div class="timeline-wrapper">
        <div class="panel-section">
            <h3 style="margin-top: 10px;">Timeline - GamePlay</h3>
            <div id="timeline-list" class="timeline-container">
                <!-- Timeline items will be injected here -->
            </div>
        </div>

        <div class="panel-section">
            <h3 style="margin-top: 10px;">Timeline - Display</h3>
            <div id="timeline-display-list" class="timeline-container">
                <!-- Display Timeline items will be injected here -->
            </div>
        </div>
    </div>

    <script src="js/dashboard.js"></script>
    <script>
        NodeCG.waitForReplicants(
            nodecg.Replicant('timelineGameplay'),
            nodecg.Replicant('timelineDisplay'),
            nodecg.Replicant('playbackConfig'),
            nodecg.Replicant('cardDatabase'),
            nodecg.Replicant('firstMove'),
            nodecg.Replicant('ptcg-settings'),
            nodecg.Replicant('playbackStatus')
        ).then(() => {
            const timelineGameplay = nodecg.Replicant('timelineGameplay');
            const timelineDisplay = nodecg.Replicant('timelineDisplay');
            const playbackConfig = nodecg.Replicant('playbackConfig');
            const cardDatabase = nodecg.Replicant('cardDatabase');
            const firstMove = nodecg.Replicant('firstMove');
            const settingsRep = nodecg.Replicant('ptcg-settings');
            const playbackStatus = nodecg.Replicant('playbackStatus');
            const matchTimer = nodecg.Replicant('matchTimer');
            const gameTimeSettings = nodecg.Replicant('gameTimeSettings');
            const timelineList = document.getElementById('timeline-list');
            const timelineDisplayList = document.getElementById('timeline-display-list');
            const playBtn = document.getElementById('play-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const resumeBtn = document.getElementById('resume-btn');
            const exportBtn = document.getElementById('export-btn');
            const importBtn = document.getElementById('import-btn');
            const importFile = document.getElementById('import-file');
            const timerDisplay = document.getElementById('timer-display');
            const insertModeToggle = document.getElementById('insert-mode-toggle');
            const insertModeLabel = document.getElementById('insert-mode-label');
            const trackGameplayToggle = document.getElementById('track-gameplay-toggle');
            const trackDisplayToggle = document.getElementById('track-display-toggle');

            // Playback Config Logic
            function updatePlaybackConfigUI() {
                if (playbackConfig.value) {
                    trackGameplayToggle.checked = playbackConfig.value.gameplay;
                    trackDisplayToggle.checked = playbackConfig.value.display;
                }
            }

            trackGameplayToggle.addEventListener('change', () => {
                playbackConfig.value = { ...playbackConfig.value, gameplay: trackGameplayToggle.checked };
            });

            trackDisplayToggle.addEventListener('change', () => {
                playbackConfig.value = { ...playbackConfig.value, display: trackDisplayToggle.checked };
            });

            playbackConfig.on('change', updatePlaybackConfigUI);

            // Insert Mode toggle logic
            function updateInsertModeUI() {
                const isInsertMode = insertModeToggle.checked;
                insertModeLabel.textContent = isInsertMode ? 'Insert Mode' : 'Overwrite Mode';
                insertModeLabel.style.color = isInsertMode ? '#ddd' : '#ff6b6b'; // Red for destructive mode
            }

            insertModeToggle.addEventListener('change', () => {
                settingsRep.value = {
                    ...settingsRep.value,
                    insertMode: insertModeToggle.checked
                };
                updateInsertModeUI();
            });

            // Initialize from settings
            if (settingsRep.value && typeof settingsRep.value.insertMode === 'boolean') {
                insertModeToggle.checked = settingsRep.value.insertMode;
            } else {
                insertModeToggle.checked = true; // Default to Insert Mode
            }
            updateInsertModeUI();

            function updateTimerDisplay() {
                if (!matchTimer.value) return;

                let elapsed = matchTimer.value.offset;
                if (matchTimer.value.isRunning && matchTimer.value.startTime && matchTimer.value.mode === 'live') {
                    elapsed += (Date.now() - matchTimer.value.startTime);
                }

                // Handle Countdown vs Countup
                let displayTime = elapsed;
                if (gameTimeSettings.value && gameTimeSettings.value.useCountdown) {
                    const limit = (gameTimeSettings.value.limit || 1500) * 1000;
                    displayTime = Math.max(0, limit - elapsed);
                }

                const totalSeconds = Math.floor(displayTime / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                if (matchTimer.value.mode === 'standby') {
                    timerDisplay.innerText = "Standby";
                    timerDisplay.style.color = "#ffcc00";
                } else {
                    const modeStr = matchTimer.value.mode === 'playback' ? 'Playback' : 'Live';
                    timerDisplay.innerText = `${modeStr} - ${timeStr}`;
                    timerDisplay.style.color = "#ddd";
                }
            }

            matchTimer.on('change', (newValue) => {
                updateTimerDisplay();
                // We don't need a high-frequency interval here unless we want smooth live updates
                // But for Record panel, maybe 1s update is fine? Or 100ms if we want to see playback smoothly.
                // Let's use 100ms for consistency.
                if (newValue.isRunning) {
                    if (!window.recordTimerInterval) {
                        window.recordTimerInterval = setInterval(updateTimerDisplay, 100);
                    }
                } else {
                    if (window.recordTimerInterval) {
                        clearInterval(window.recordTimerInterval);
                        window.recordTimerInterval = null;
                    }
                }
            });

            gameTimeSettings.on('change', updateTimerDisplay);

            function getCardName(cardId) {
                const db = cardDatabase.value;
                if (db && db[cardId]) {
                    return db[cardId].name;
                }
                return cardId;
            }

            function formatOpSummary(op) {
                // Simplified summary for the timeline list
                const { type, payload } = op;
                const target = payload.target || '';
                switch (type) {
                    case 'ATTACK': return `Attack: ${payload.attackName}`;
                    case 'SET_POKEMON': return `Set: ${getCardName(payload.cardId)}`;
                    case 'KO_POKEMON': return `KO: ${target}`;
                    default: return `${type} (${target})`;
                }
            }

            function renderTimeline() {
                timelineList.innerHTML = '';
                if (!timelineGameplay.value || timelineGameplay.value.length === 0) {
                    timelineList.innerHTML = '<div style="color: #666; padding: 10px;">No history recorded.</div>';
                    return;
                }

                const firstMover = firstMove.value || 'L';

                timelineGameplay.value.forEach((pack, index) => {
                    const item = document.createElement('div');
                    item.classList.add('timeline-item');
                    item.dataset.index = index;

                    // Determine turn player and add class
                    const round = pack.round || 1;
                    const isOdd = round % 2 !== 0;
                    const isPlayerL = (firstMover === 'L' && isOdd) || (firstMover === 'R' && !isOdd);
                    item.classList.add(isPlayerL ? 'turn-l' : 'turn-r');

                    // Highlight active item
                    if (playbackStatus.value && playbackStatus.value.currentIndexGameplay === index) {
                        item.classList.add('active');
                        item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }

                    const opCount = pack.ops.length;

                    // 在renderTimeline函数中，创建item后动态计算modified状态
                    const hasInserted = pack.ops.some(op => op.source === 'inserted');
                    const hasDeleted = pack.ops.some(op => op.deleted);
                    const isModified = hasInserted || hasDeleted;

                    if (isModified) {
                        item.classList.add('modified');
                    }

                    // 计算各类操作的数量
                    const nativeCount = pack.ops.filter(op => !op.source && !op.deleted).length;
                    const insertedCount = pack.ops.filter(op => op.source === 'inserted' && !op.deleted).length;
                    const deletedCount = pack.ops.filter(op => op.deleted).length;

                    // 修改HTML模板，在Round信息后添加修改badge（仅在modified时显示）
                    const modifiedBadge = isModified
                        ? `<span class="modified-badge" title="此OpsPack已被修改\n原生: ${nativeCount}, 追加: ${insertedCount}, 已删: ${deletedCount}">已修改</span>`
                        : '';

                    // 解析当前timestamp
                    const [minutes, seconds] = pack.timestamp.split(':').map(Number);

                    // Create the operations list HTML
                    const operationsHTML = pack.ops.map((op, idx) => {
                        const source = op.source || 'native';
                        const isDeleted = op.deleted;
                        const sourceBadge = op.source === 'inserted' ? `<span class="operation-source-badge inserted">追加</span>` : '';
                        const deletedBadge = isDeleted ? `<span class="operation-source-badge deleted">已删</span>` : '';
                        const actionButton = isDeleted
                            ? `<button class="btn-restore-op" data-op-index="${idx}" title="Restore this operation">↩</button>`
                            : `<button class="btn-delete-op" data-op-index="${idx}" title="Delete this operation">×</button>`;
                        return `
                            <div class="operation-item ${source} ${isDeleted ? 'deleted-op' : ''}" data-op-index="${idx}">
                                <div class="operation-content">
                                    <span class="operation-number">${idx + 1}.</span> ${formatOpSummary(op)}${sourceBadge}${deletedBadge}
                                </div>
                                <div class="operation-actions">
                                    ${actionButton}
                                </div>
                            </div>
                        `;
                    }).join('');

                    // 修改timeline-header内的timestamp显示
                    item.innerHTML = `
						<div class="timeline-header">
							<button class="btn btn-sm btn-primary seek-btn" data-index="${index}" style="margin-left: 10px;">Restore</button>
							<span>
								<span class="timestamp-input-group">
									<input type="number" 
										   class="timestamp-input timestamp-minutes" 
										   min="0" 
										   max="99" 
										   value="${minutes}" 
										   data-index="${index}">
									<span class="timestamp-separator">:</span>
									<input type="number" 
										   class="timestamp-input timestamp-seconds" 
										   min="0" 
										   max="59" 
										   value="${seconds}" 
										   data-index="${index}">
								</span>
								| Round ${pack.round || 1}${modifiedBadge} - ${pack.ops.filter(op => !op.deleted).length}/${opCount} Ops</span>
							</span>
							<div>
								<button class="btn btn-sm btn-danger delete-btn" data-index="${index}" style="margin-left: 10px;">Delete</button>
							</div>
						</div>
						<div class="timeline-details">
							<div class="operations-list">
								${operationsHTML}
							</div>
						</div>
					`;

                    item.addEventListener('click', (e) => {
                        // Expand/collapse logic, but ignore clicks on any button
                        if (e.target.closest('button, input')) return;
                        item.classList.toggle('expanded');
                    });

                    // Event delegation for operations list
                    const opsListEl = item.querySelector('.operations-list');
                    opsListEl.addEventListener('click', (e) => {
                        const target = e.target;
                        const opIndex = parseInt(target.dataset.opIndex, 10);
                        if (target.classList.contains('btn-delete-op')) {
                            e.stopPropagation();
                            const opToDelete = pack.ops[opIndex];
                            const isNative = !opToDelete.source || opToDelete.source === 'native';
                            let confirmMessage = `Are you sure you want to delete operation #${opIndex + 1} (${formatOpSummary(opToDelete)})?`;
                            if (!isNative) {
                                confirmMessage += "\n\nThis is an INSERTED operation and will be permanently removed.";
                            } else {
                                confirmMessage += "\n\nThis is a NATIVE operation and will be marked as deleted (can be restored).";
                            }
                            if (confirm(confirmMessage)) {
                                nodecg.sendMessage('deleteOperation', { opsPackIndex: index, operationIndex: opIndex })
                                    .catch(err => alert('Failed to delete operation: ' + err.message));
                            }
                        } else if (target.classList.contains('btn-restore-op')) {
                            e.stopPropagation();
                            nodecg.sendMessage('restoreOperation', { opsPackIndex: index, operationIndex: opIndex })
                                .catch(err => alert('Failed to restore operation: ' + err.message));
                        }
                    });

                    // 新增：时间输入框事件处理
                    const minutesInput = item.querySelector('.timestamp-minutes');
                    const secondsInput = item.querySelector('.timestamp-seconds');

                    function validateAndUpdateTimestamp(inputElement) {
                        const minutes = parseInt(minutesInput.value) || 0;
                        let seconds = parseInt(secondsInput.value) || 0;

                        // 验证秒数范围
                        if (seconds < 0) seconds = 0;
                        if (seconds > 59) seconds = 59;

                        // 验证分钟范围
                        const validMinutes = Math.max(0, Math.min(99, minutes));

                        // 更新显示值（处理非法输入）
                        minutesInput.value = validMinutes;
                        secondsInput.value = seconds;

                        // 检查输入有效性
                        const isValid = seconds >= 0 && seconds <= 59 && validMinutes >= 0;

                        if (!isValid) {
                            inputElement.classList.add('invalid');
                            return;
                        }

                        inputElement.classList.remove('invalid');

                        // 构建新timestamp
                        const newTimestamp = `${validMinutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                        // 只有当timestamp真正改变时才发送更新
                        if (newTimestamp !== pack.timestamp) {
                            nodecg.sendMessage('editOpsPack', { index, newTimestamp })
                                .catch(err => {
                                    alert('Failed to update timestamp: ' + err);
                                    // 恢复原值
                                    const [origMin, origSec] = pack.timestamp.split(':').map(Number);
                                    minutesInput.value = origMin;
                                    secondsInput.value = origSec;
                                });
                        }
                    }

                    // 使用blur事件（失去焦点时触发）以避免频繁更新
                    minutesInput.addEventListener('blur', (e) => validateAndUpdateTimestamp(e.target));
                    secondsInput.addEventListener('blur', (e) => validateAndUpdateTimestamp(e.target));

                    // 支持Enter键快速确认
                    minutesInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.target.blur();
                        }
                    });
                    secondsInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.target.blur();
                        }
                    });

                    // 秒数输入框：自动处理超过59的情况
                    secondsInput.addEventListener('input', (e) => {
                        let value = parseInt(e.target.value);
                        if (value > 59) {
                            const extraMinutes = Math.floor(value / 60);
                            const newSeconds = value % 60;
                            const currentMinutes = parseInt(minutesInput.value) || 0;

                            minutesInput.value = currentMinutes + extraMinutes;
                            secondsInput.value = newSeconds;
                        }
                    });

                    const deleteBtn = item.querySelector('.delete-btn');
                    deleteBtn.addEventListener('click', () => {
                        if (confirm('Are you sure you want to delete this OpsPack? This cannot be undone.')) {
                            nodecg.sendMessage('deleteOpsPack', index)
                                .catch(err => alert('Failed to delete: ' + err));
                        }
                    });

                    const seekBtn = item.querySelector('.seek-btn');
                    seekBtn.addEventListener('click', () => {
                        if (confirm(`Restore to timestamp ${pack.timestamp}? This will reset the board and fast-forward.`)) {
                            nodecg.sendMessage('seekTimeline', index);
                        }
                    });

                    timelineList.appendChild(item);
                });
            }

            function renderDisplayTimeline() {
                timelineDisplayList.innerHTML = '';
                if (!timelineDisplay.value || timelineDisplay.value.length === 0) {
                    timelineDisplayList.innerHTML = '<div style="color: #666; padding: 10px;">No display history recorded.</div>';
                    return;
                }

                timelineDisplay.value.forEach((op, index) => {
                    const item = document.createElement('div');
                    item.classList.add('timeline-item');
                    item.dataset.index = index;

                    // Determine side and add class
                    let side = null;
                    if (op.payload && op.payload.side) {
                        side = op.payload.side;
                    } else if (op.type.endsWith('_L')) {
                        side = 'L';
                    } else if (op.type.endsWith('_R')) {
                        side = 'R';
                    }

                    if (side === 'L') item.classList.add('turn-l');
                    if (side === 'R') item.classList.add('turn-r');

                    // Highlight active item
                    if (playbackStatus.value && playbackStatus.value.currentIndexDisplay === index) {
                        item.classList.add('active');
                    }

                    let summary = '';
                    if (op.type === 'SHOW_CARD_L' || op.type === 'SHOW_CARD_R') {
                        summary = `Show Card (${op.payload.side}): ${getCardName(op.payload.cardId)}`;
                    } else if (op.type === 'SHOW_PRIZE_L' || op.type === 'SHOW_PRIZE_R') {
                        summary = `Show Prize (${op.payload.side})`;
                    } else if (op.type === 'HIDE_DISPLAY') {
                        summary = `Hide Display`;
                    } else if (op.type === 'TOGGLE_EXTRA_BENCH') {
                        summary = `Extra Bench (${op.payload.side}): ${op.payload.visible ? 'Show' : 'Hide'}`;
                    } else if (op.type === 'TOGGLE_PRIZE_TAKEN') {
                        summary = `Prize (${op.payload.side}) #${op.payload.index + 1}: ${op.payload.isTaken ? 'Taken' : 'Untaken'}`;
                    } else if (op.type === 'SET_PRIZE_CARD') {
                        summary = `Set Prize (${op.payload.side}) #${op.payload.index + 1}: ${op.payload.cardId}`;
                    } else if (op.type === 'CLEAR_PRIZE_CARDS') {
                        summary = `Clear Prizes (${op.payload.side})`;
                    } else {
                        summary = op.type;
                    }

                    // 在renderDisplayTimeline函数中应用类似的修改
                    const [minutes, seconds] = op.timestamp.split(':').map(Number);
            
                    item.innerHTML = `
            						<div class="timeline-header">
            							<button class="btn btn-sm btn-primary seek-btn" data-index="${index}" style="margin-left: 10px;">Restore</button>
            							<span>
            								<span class="timestamp-input-group">
            									<input type="number" 
            										   class="timestamp-input timestamp-minutes" 
            										   min="0" 
            										   max="99" 
            										   value="${minutes}" 
            										   data-index="${index}">
            									<span class="timestamp-separator">:</span>
            									<input type="number" 
            										   class="timestamp-input timestamp-seconds" 
            										   min="0" 
            										   max="59" 
            										   value="${seconds}" 
            										   data-index="${index}">
            								</span>
            								| ${summary}
            							</span>
            							<div>
            								<button class="btn btn-sm btn-danger delete-btn" data-index="${index}" style="margin-left: 10px;">Delete</button>
            							</div>
            						</div>
            					`;

                    // 添加相同的输入验证逻辑，但使用editDisplayOp消息
                    const minutesInput = item.querySelector('.timestamp-minutes');
                    const secondsInput = item.querySelector('.timestamp-seconds');

                    function validateAndUpdateTimestamp(inputElement) {
                        const minutes = parseInt(minutesInput.value) || 0;
                        let seconds = parseInt(secondsInput.value) || 0;
            						
                        if (seconds < 0) seconds = 0;
                        if (seconds > 59) seconds = 59;
                        const validMinutes = Math.max(0, Math.min(99, minutes));
            						
                        minutesInput.value = validMinutes;
                        secondsInput.value = seconds;
            						
                        const isValid = seconds >= 0 && seconds <= 59 && validMinutes >= 0;
            						
                        if (!isValid) {
                            inputElement.classList.add('invalid');
                            return;
                        }
            						
                        inputElement.classList.remove('invalid');
            						
                        const newTimestamp = `${validMinutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            						
                        if (newTimestamp !== op.timestamp) {
                            nodecg.sendMessage('editDisplayOp', { index, newTimestamp })
                                .catch(err => {
                                    alert('Failed to update timestamp: ' + err);
                                    const [origMin, origSec] = op.timestamp.split(':').map(Number);
                                    minutesInput.value = origMin;
                                    secondsInput.value = origSec;
                                });
                        }
                    }
            
                    minutesInput.addEventListener('blur', (e) => validateAndUpdateTimestamp(e.target));
                    secondsInput.addEventListener('blur', (e) => validateAndUpdateTimestamp(e.target));
                    minutesInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') e.target.blur(); });
                    secondsInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') e.target.blur(); });
            
                    secondsInput.addEventListener('input', (e) => {
                        let value = parseInt(e.target.value);
                        if (value > 59) {
                            const extraMinutes = Math.floor(value / 60);
                            const newSeconds = value % 60;
                            const currentMinutes = parseInt(minutesInput.value) || 0;
                            minutesInput.value = currentMinutes + extraMinutes;
                            secondsInput.value = newSeconds;
                        }
                    });
            
                    const deleteBtn = item.querySelector('.delete-btn');
                    deleteBtn.addEventListener('click', () => {
                        if (confirm('Are you sure you want to delete this Display Op?')) {
                            nodecg.sendMessage('deleteDisplayOp', index)
                                .catch(err => alert('Failed to delete: ' + err));
                        }
                    });

                    const restoreBtn = item.querySelector('.seek-btn');
                    restoreBtn.addEventListener('click', () => {
                        const targetTime = op.timestamp;
                        if (confirm(`Restore to timestamp ${targetTime}? This will reset the board and fast-forward.`)) {
                            nodecg.sendMessage('seekToTimestamp', targetTime);
                        }
                    });

                    timelineDisplayList.appendChild(item);
                });
            }
            timelineGameplay.on('change', renderTimeline);
            timelineDisplay.on('change', renderDisplayTimeline);
            nodecg.listenFor('timelineRefreshed', () => {
                renderTimeline();
                renderDisplayTimeline();
            });

            nodecg.listenFor('opsPackMerged', (data) => {
                console.log(`OpsPack modified at ${data.timestamp}: ${data.newOpsCount} new ops appended, total ${data.totalOps} ops`);
                // UI会通过timelineGameplay的change事件自动刷新
            });

            playbackStatus.on('change', (newVal) => {
                if (newVal) {
                    // timerDisplay.innerText = `Playback: ${newVal.currentTime}`; // Removed, using matchTimer
                    renderTimeline(); // Re-render to update highlights
                    renderDisplayTimeline(); // Re-render display timeline highlights

                    // Update Button States
                    // Replay button is always visible
                    // Toggle between Pause (when playing) and Resume (when not playing)
                    if (newVal.isPlaying) {
                        pauseBtn.style.display = 'inline-block';
                        resumeBtn.style.display = 'none';
                    } else {
                        pauseBtn.style.display = 'none';
                        resumeBtn.style.display = 'inline-block';
                    }
                }
            });

            playBtn.addEventListener('click', () => {
                if (confirm('Re-simulate entire timeline?')) {
                    nodecg.sendMessage('playTimeline');
                }
            });

            pauseBtn.addEventListener('click', () => {
                nodecg.sendMessage('pauseTimeline');
            });

            resumeBtn.addEventListener('click', () => {
                nodecg.sendMessage('resumeTimeline');
            });

            exportBtn.addEventListener('click', () => {
                nodecg.sendMessage('exportTimeline').then(jsonString => {
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(jsonString);
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    downloadAnchorNode.setAttribute("download", `match_data_${Date.now()}.json`);
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                }).catch(err => {
                    alert('Failed to export timeline: ' + err.message);
                });
            });

            importBtn.addEventListener('click', () => {
                importFile.click();
            });

            importFile.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const json = event.target.result;
                        // Validate JSON
                        JSON.parse(json);
                        if (confirm('Importing will overwrite the current timeline and decks. Continue?')) {
                            nodecg.sendMessage('importTimeline', json)
                                .then(() => alert('Import successful!'))
                                .catch(err => alert('Import failed: ' + err));
                        }
                    } catch (err) {
                        alert('Invalid JSON file.');
                    }
                };
                reader.readAsText(file);
                // Reset value so same file can be selected again
                importFile.value = '';
            });
        });
    </script>
</body>

</html>