<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Records</title>
    <link rel="stylesheet" href="css/dashboard.css">
    <style>
        .timeline-wrapper {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .timeline-wrapper .panel-section {
            flex: 1;
            min-width: 0;
            margin-top: 0 !important;
            border-top: none !important;
            padding-top: 0 !important;
        }

        .timeline-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .timeline-item {
            background: #adadad;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .timeline-item:hover {
            background: #3a3a3a;
        }

        .timeline-item.active {
            border-color: #d30000;
            border-width: 3px;
        }

        .timeline-item.turn-l {
            background-color: rgb(143, 181, 198);
        }

        .timeline-item.turn-r {
            background-color: rgb(226, 169, 153);
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            color: rgb(50, 50, 50);
        }

        .timeline-header>span {
            flex: 1;
            text-align: left;
            margin-left: 10px;
        }

        .timeline-details {
            margin-top: 5px;
            font-size: 0.9em;
            color: #2d2d2d;
            display: none;
        }

        .timeline-item.expanded .timeline-details {
            display: block;
        }

        .controls-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #222;
            border-bottom: 1px solid #444;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        /* Task 1: Timestamp input style */
        .timestamp-input-group {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-family: monospace;
        }

        .timestamp-input {
            width: 35px;
            padding: 2px 4px;
            border: 1px solid #555;
            background: #333;
            color: #ddd;
            border-radius: 3px;
            font-size: 0.9em;
            text-align: center;
            font-family: monospace;
        }

        .timestamp-input:focus {
            outline: none;
            border-color: #d30000;
            background: #3a3a3a;
        }

        .timestamp-input.invalid {
            border-color: #ff6b6b;
            background: #4a2828;
        }

        .timestamp-separator {
            color: #999;
            font-weight: bold;
        }

        /* Task 2: Vertical operations list style */
        .operations-list {
            max-height: 250px;
            overflow-y: auto;
            margin-top: 8px;
        }

        .operation-item {
            padding: 4px 8px;
            margin: 2px 0;
            background: rgba(255, 255, 255, 0.05);
            border-left: 2px solid #555;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .operation-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-left-color: #d30000;
        }

        .operation-number {
            display: inline-block;
            min-width: 20px;
            color: #999;
            font-weight: bold;
        }

        /* Scrollbar style */
        .operations-list::-webkit-scrollbar {
            width: 6px;
        }

        .operations-list::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 3px;
        }

        .operations-list::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }

        .operations-list::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        /* Task 3: Modified OpsPack indicator */
        .timeline-item.modified {
            background: rgba(255, 165, 0, 0.08);
            /* Light orange background */
            border-left: 3px solid #ffa500;
        }

        .modified-badge {
            display: inline-block;
            background: #ffa500;
            color: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7em;
            margin-left: 6px;
            font-weight: bold;
        }

        /* Operation source indicators */
        .operation-item.native {
            /* Default style - native recording */
        }

        .operation-item.inserted {
            background: rgba(100, 149, 237, 0.15);
            /* Light blue background */
            border-left-color: #6495ed;
            /* Blue left border */
        }

        .operation-item.deleted {
            opacity: 0.4;
            text-decoration: line-through;
            background: rgba(255, 0, 0, 0.05);
        }

        .operation-source-badge {
            display: inline-block;
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 0.65em;
            margin-left: 4px;
            font-weight: bold;
        }

        .operation-source-badge.inserted {
            background: #6495ed;
            color: white;
        }

        .operation-source-badge.deleted {
            background: #ff6b6b;
            color: white;
        }

        /* Task 4: Operation item with delete button */
        .operation-item {
            padding: 4px 8px;
            margin: 2px 0;
            background: rgba(255, 255, 255, 0.05);
            border-left: 2px solid #555;
            font-size: 0.85em;
            line-height: 1.4;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .operation-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-left-color: #d30000;
        }

        .operation-content {
            flex: 1;
        }

        .operation-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .operation-item:hover .operation-actions {
            opacity: 1;
        }

        .btn-delete-op {
            padding: 2px 6px;
            font-size: 0.7em;
            background: #d30000;
            border: none;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-delete-op:hover {
            background: #ff0000;
        }

        .btn-restore-op {
            padding: 2px 6px;
            font-size: 0.7em;
            background: #28a745;
            border: none;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-restore-op:hover {
            background: #218838;
        }

        .operation-item.deleted-op {
            background: rgba(80, 80, 80, 0.2);
        }

        /* Timer Edit Popup Styles */
        .timer-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            /* justify-content: center; Removed for manual positioning */
            /* align-items: center;     Removed for manual positioning */
        }

        .timer-popup-content {
            position: absolute;
            /* Added for manual positioning */
            background: #222;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            text-align: center;
            min-width: 250px;
        }

        .timer-popup-display {
            font-family: monospace;
            font-size: 2em;
            margin-bottom: 15px;
            color: #fff;
            background: #000;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .timer-popup-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .timer-popup-btn {
            padding: 8px;
            font-size: 0.9em;
            cursor: pointer;
            background: #333;
            color: #ddd;
            border: 1px solid #555;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .timer-popup-btn:hover {
            background: #444;
            border-color: #777;
        }

        .timer-popup-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            border-top: 1px solid #333;
            padding-top: 10px;
        }
    </style>
</head>

<body>
    <div class="controls-bar">
        <div class="btn-group">
            <button id="play-btn" class="btn btn-primary">Replay</button>
            <button id="pause-btn" class="btn btn-warning" style="display: none;">Pause</button>
            <button id="resume-btn" class="btn btn-primary">Resume</button>
        </div>
        <div id="timer-display" style="font-family: monospace; font-size: 1.2em; color: #ddd; align-self: center;">
            Timer:00:00
        </div>
        <button id="timer-edit-btn" class="btn btn-secondary" style="padding: 2px 8px; margin-left: 5px;">Edit</button>
        <div style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="insert-mode-toggle" checked style="width: auto; height: auto;">
            <label for="insert-mode-toggle" id="insert-mode-label" style="margin: 0; cursor: pointer;">Insert
                Mode</label>
        </div>
        <div
            style="display: flex; align-items: center; gap: 8px; margin-left: 10px; border-left: 1px solid #444; padding-left: 10px;">
            <span style="color: #aaa; font-size: 0.9em;">Tracks:</span>
            <input type="checkbox" id="track-gameplay-toggle" checked style="width: auto; height: auto;">
            <label for="track-gameplay-toggle" style="margin: 0; cursor: pointer; color: #ddd;">Gameplay</label>
            <input type="checkbox" id="track-display-toggle" checked style="width: auto; height: auto;">
            <label for="track-display-toggle" style="margin: 0; cursor: pointer; color: #ddd;">Display</label>
        </div>
        <div class="btn-group" style="margin-left: auto;">
            <button id="export-btn" class="btn btn-secondary">Export JSON</button>
            <button id="import-btn" class="btn btn-secondary">Import JSON</button>
        </div>
        <input type="file" id="import-file" style="display: none;" accept=".json">
    </div>

    <!-- Timer Edit Popup -->
    <div id="timer-popup" class="timer-popup-overlay">
        <div class="timer-popup-content">
            <div id="popup-timer-display" class="timer-popup-display">00:00</div>
            <div class="timer-popup-controls">
                <button class="timer-popup-btn" data-adjust="30">+30s</button>
                <button class="timer-popup-btn" data-adjust="5">+5s</button>
                <button class="timer-popup-btn" data-adjust="1">+1s</button>
                <button class="timer-popup-btn" data-adjust="-30">-30s</button>
                <button class="timer-popup-btn" data-adjust="-5">-5s</button>
                <button class="timer-popup-btn" data-adjust="-1">-1s</button>
            </div>
            <div class="timer-popup-actions">
                <button id="timer-popup-cancel" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div class="timeline-wrapper">
        <div class="panel-section">
            <h3 style="margin-top: 10px;">Timeline - GamePlay</h3>
            <div id="timeline-list" class="timeline-container">
                <!-- Timeline items will be injected here -->
            </div>
        </div>

        <div class="panel-section">
            <h3 style="margin-top: 10px;">Timeline - Display</h3>
            <div id="timeline-display-list" class="timeline-container">
                <!-- Display Timeline items will be injected here -->
            </div>
        </div>
    </div>

    <script src="js/dashboard.js"></script>
    <script>
        NodeCG.waitForReplicants(
            nodecg.Replicant('timelineGameplay'),
            nodecg.Replicant('timelineDisplay'),
            nodecg.Replicant('playbackConfig'),
            nodecg.Replicant('cardDatabase'),
            nodecg.Replicant('firstMove'),
            nodecg.Replicant('ptcg-settings'),
            nodecg.Replicant('playbackStatus'),
            nodecg.Replicant('i18nStrings'),
            nodecg.Replicant('language')
        ).then(() => {
            const timelineGameplay = nodecg.Replicant('timelineGameplay');
            const timelineDisplay = nodecg.Replicant('timelineDisplay');
            const playbackConfig = nodecg.Replicant('playbackConfig');
            const cardDatabase = nodecg.Replicant('cardDatabase');
            const firstMove = nodecg.Replicant('firstMove');
            const settingsRep = nodecg.Replicant('ptcg-settings');
            const playbackStatus = nodecg.Replicant('playbackStatus');
            const matchTimer = nodecg.Replicant('matchTimer');
            const gameTimeSettings = nodecg.Replicant('gameTimeSettings');
            const i18nStrings = nodecg.Replicant('i18nStrings');
            const language = nodecg.Replicant('language');
            const timelineList = document.getElementById('timeline-list');
            const timelineDisplayList = document.getElementById('timeline-display-list');
            const playBtn = document.getElementById('play-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const resumeBtn = document.getElementById('resume-btn');
            const exportBtn = document.getElementById('export-btn');
            const importBtn = document.getElementById('import-btn');
            const importFile = document.getElementById('import-file');
            const timerDisplay = document.getElementById('timer-display');
            const insertModeToggle = document.getElementById('insert-mode-toggle');
            const insertModeLabel = document.getElementById('insert-mode-label');
            const trackGameplayToggle = document.getElementById('track-gameplay-toggle');
            const trackDisplayToggle = document.getElementById('track-display-toggle');
            const timerEditBtn = document.getElementById('timer-edit-btn');

            // Popup Elements
            const timerPopup = document.getElementById('timer-popup');
            const popupContent = timerPopup.querySelector('.timer-popup-content');
            const popupDisplay = document.getElementById('popup-timer-display');
            const popupCancelBtn = document.getElementById('timer-popup-cancel');
            const popupAdjustBtns = timerPopup.querySelectorAll('.timer-popup-btn');

            let tempSeconds = 0;

            // Local i18n helper function
            function getI18nText(key) {
                if (!i18nStrings.value || !i18nStrings.value[key] || !language.value) {
                    return key; // Fallback to key name if not found
                }
                return i18nStrings.value[key][language.value] || i18nStrings.value[key]['jp'] || key;
            }

            // Update all static UI text with i18n
            function updateStaticUI() {
                // Update control panel buttons
                playBtn.textContent = getI18nText('record_replay');
                pauseBtn.textContent = getI18nText('record_pause');
                resumeBtn.textContent = getI18nText('record_resume');
                exportBtn.textContent = getI18nText('record_export_json');
                importBtn.textContent = getI18nText('record_import_json');

                // Update track labels
                document.querySelector('span[style*="color: #aaa"]').textContent = getI18nText('record_tracks');
                document.querySelector('label[for="track-gameplay-toggle"]').textContent = getI18nText('record_gameplay');
                document.querySelector('label[for="track-display-toggle"]').textContent = getI18nText('record_display');
            }

            // Playback Config Logic
            function updatePlaybackConfigUI() {
                if (playbackConfig.value) {
                    trackGameplayToggle.checked = playbackConfig.value.gameplay;
                    trackDisplayToggle.checked = playbackConfig.value.display;
                }
            }

            trackGameplayToggle.addEventListener('change', () => {
                playbackConfig.value = { ...playbackConfig.value, gameplay: trackGameplayToggle.checked };
            });

            trackDisplayToggle.addEventListener('change', () => {
                playbackConfig.value = { ...playbackConfig.value, display: trackDisplayToggle.checked };
            });

            playbackConfig.on('change', updatePlaybackConfigUI);

            // Insert Mode toggle logic
            function updateInsertModeUI() {
                const isInsertMode = insertModeToggle.checked;
                insertModeLabel.textContent = isInsertMode ? getI18nText('record_insert_mode') : getI18nText('record_overwrite_mode');
                insertModeLabel.style.color = isInsertMode ? '#ddd' : '#ff6b6b'; // Red for destructive mode
            }

            insertModeToggle.addEventListener('change', () => {
                settingsRep.value = {
                    ...settingsRep.value,
                    insertMode: insertModeToggle.checked
                };
                updateInsertModeUI();
            });

            // Initialize from settings
            if (settingsRep.value && typeof settingsRep.value.insertMode === 'boolean') {
                insertModeToggle.checked = settingsRep.value.insertMode;
            } else {
                insertModeToggle.checked = true; // Default to Insert Mode
            }

            // Initialize static UI text
            updateStaticUI();
            updateInsertModeUI();

            // Update UI when language changes
            language.on('change', () => {
                updateStaticUI();
                updateInsertModeUI();
                renderTimeline();
                renderDisplayTimeline();
            });

            function updateTimerDisplay() {
                if (!matchTimer.value) return;

                let elapsed = matchTimer.value.offset;
                if (matchTimer.value.isRunning && matchTimer.value.startTime && matchTimer.value.mode === 'live') {
                    elapsed += (Date.now() - matchTimer.value.startTime);
                }

                // Handle Countdown vs Countup
                let displayTime = elapsed;
                if (gameTimeSettings.value && gameTimeSettings.value.useCountdown) {
                    const limit = (gameTimeSettings.value.limit || 1500) * 1000;
                    displayTime = Math.max(0, limit - elapsed);
                }

                const totalSeconds = Math.floor(displayTime / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                if (matchTimer.value.mode === 'standby') {
                    timerDisplay.innerText = "Standby";
                    timerDisplay.style.color = "#ffcc00";
                } else {
                    const modeStr = matchTimer.value.mode === 'playback' ? 'Playback' : 'Live';
                    timerDisplay.innerText = `${modeStr} - ${timeStr}`;
                    timerDisplay.style.color = "#ddd";
                }
            }

            matchTimer.on('change', (newValue) => {
                updateTimerDisplay();
                // We don't need a high-frequency interval here unless we want smooth live updates
                // But for Record panel, maybe 1s update is fine? Or 100ms if we want to see playback smoothly.
                // Let's use 100ms for consistency.
                if (newValue.isRunning) {
                    if (!window.recordTimerInterval) {
                        window.recordTimerInterval = setInterval(updateTimerDisplay, 100);
                    }
                } else {
                    if (window.recordTimerInterval) {
                        clearInterval(window.recordTimerInterval);
                        window.recordTimerInterval = null;
                    }
                }
            });

            gameTimeSettings.on('change', updateTimerDisplay);

            // Timer Edit Popup Logic
            function updatePopupDisplay() {
                const minutes = Math.floor(tempSeconds / 60);
                const seconds = tempSeconds % 60;
                popupDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            function openTimerPopup() {
                // Initialize with current timer value
                if (matchTimer.value) {
                    let elapsed = matchTimer.value.offset;
                    if (matchTimer.value.isRunning && matchTimer.value.startTime && matchTimer.value.mode === 'live') {
                        elapsed += (Date.now() - matchTimer.value.startTime);
                    }

                    tempSeconds = Math.floor(elapsed / 1000);
                    updatePopupDisplay();

                    // Show overlay first to calculate dimensions
                    timerPopup.style.display = 'block';
                    timerPopup.style.visibility = 'hidden';

                    // Position popup next to the button
                    const btnRect = timerEditBtn.getBoundingClientRect();
                    const popupRect = popupContent.getBoundingClientRect();

                    // Default: Position below the button for record.html (since it's in top bar)
                    let top = btnRect.bottom + 10;
                    let left = btnRect.left;

                    // Check if it goes off-screen horizontally
                    if (left + popupRect.width > window.innerWidth) {
                        left = window.innerWidth - popupRect.width - 10;
                    }

                    // Check if it goes off-screen vertically
                    if (top + popupRect.height > window.innerHeight) {
                        // Try above
                        top = btnRect.top - popupRect.height - 10;
                    }
                    if (left < 0) left = 10;

                    popupContent.style.top = `${top}px`;
                    popupContent.style.left = `${left}px`;

                    timerPopup.style.visibility = 'visible';
                }
            }

            function closeTimerPopup(save) {
                if (save) {
                    nodecg.sendMessage('timerControl', { action: 'edit', seconds: tempSeconds });
                }
                timerPopup.style.display = 'none';
            }

            timerEditBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent immediate closing
                openTimerPopup();
            });

            popupAdjustBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const adjust = parseInt(btn.dataset.adjust, 10);
                    tempSeconds += adjust;
                    if (tempSeconds < 0) tempSeconds = 0;
                    updatePopupDisplay();
                });
            });

            popupCancelBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                closeTimerPopup(false);
            });

            // Click outside to save and close
            timerPopup.addEventListener('click', (e) => {
                if (e.target === timerPopup) {
                    closeTimerPopup(true);
                }
            });

            // Prevent clicks inside content from closing
            popupContent.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            function getCardName(cardId) {
                const db = cardDatabase.value;
                if (db && db[cardId]) {
                    return db[cardId].name;
                }
                return cardId;
            }

            function formatOpSummary(op) {
                // Simplified summary for the timeline list
                const { type, payload } = op;
                const target = payload.target || '';
                switch (type) {
                    case 'ATTACK': return `Attack: ${payload.attackName}`;
                    case 'SET_POKEMON': return `Set: ${getCardName(payload.cardId)}`;
                    case 'KO_POKEMON': return `KO: ${target}`;
                    default: return `${type} (${target})`;
                }
            }

            function renderTimeline() {
                // Save expanded state before re-rendering
                const expandedIndices = new Set();
                const existingItems = timelineList.querySelectorAll('.timeline-item.expanded');
                existingItems.forEach(item => {
                    const index = parseInt(item.dataset.index, 10);
                    if (!isNaN(index)) {
                        expandedIndices.add(index);
                    }
                });

                timelineList.innerHTML = '';
                if (!timelineGameplay.value || timelineGameplay.value.length === 0) {
                    timelineList.innerHTML = '<div style="color: #666; padding: 10px;">No history recorded.</div>';
                    return;
                }

                const firstMover = firstMove.value || 'L';

                timelineGameplay.value.forEach((pack, index) => {
                    const item = document.createElement('div');
                    item.classList.add('timeline-item');
                    item.dataset.index = index;

                    // Restore expanded state if it was previously expanded
                    if (expandedIndices.has(index)) {
                        item.classList.add('expanded');
                    }

                    // Determine turn player and add class
                    const round = pack.round || 1;
                    const isOdd = round % 2 !== 0;
                    const isPlayerL = (firstMover === 'L' && isOdd) || (firstMover === 'R' && !isOdd);
                    item.classList.add(isPlayerL ? 'turn-l' : 'turn-r');

                    // Highlight active item
                    if (playbackStatus.value && playbackStatus.value.currentIndexGameplay === index) {
                        item.classList.add('active');
                        item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }

                    const opCount = pack.ops.length;

                    // In renderTimeline function, dynamically calculate modified status after creating item
                    const hasInserted = pack.ops.some(op => op.source === 'inserted');
                    const hasDeleted = pack.ops.some(op => op.deleted);
                    const isModified = hasInserted || hasDeleted;

                    if (isModified) {
                        item.classList.add('modified');
                    }

                    // Calculate the count of each type of operation
                    const nativeCount = pack.ops.filter(op => !op.source && !op.deleted).length;
                    const insertedCount = pack.ops.filter(op => op.source === 'inserted' && !op.deleted).length;
                    const deletedCount = pack.ops.filter(op => op.deleted).length;

                    // Modify HTML template, add modified badge after Round info (only shown when modified)
                    const modifiedBadge = isModified
                        ? `<span class="modified-badge" title="${getI18nText('record_opspack_modified_tooltip')}\n${getI18nText('record_native')}: ${nativeCount}, ${getI18nText('record_inserted')}: ${insertedCount}, ${getI18nText('record_deleted')}: ${deletedCount}">${getI18nText('record_modified')}</span>`
                        : '';

                    // Parse current timestamp
                    const [minutes, seconds] = pack.timestamp.split(':').map(Number);

                    // Create the operations list HTML
                    const operationsHTML = pack.ops.map((op, idx) => {
                        const source = op.source || 'native';
                        const isDeleted = op.deleted;
                        const sourceBadge = op.source === 'inserted' ? `<span class="operation-source-badge inserted">${getI18nText('record_inserted')}</span>` : '';
                        const deletedBadge = isDeleted ? `<span class="operation-source-badge deleted">${getI18nText('record_deleted')}</span>` : '';
                        const actionButton = isDeleted
                            ? `<button class="btn-restore-op" data-op-index="${idx}" title="Restore this operation">↩</button>`
                            : `<button class="btn-delete-op" data-op-index="${idx}" title="Delete this operation">×</button>`;
                        return `
                            <div class="operation-item ${source} ${isDeleted ? 'deleted-op' : ''}" data-op-index="${idx}">
                                <div class="operation-content">
                                    <span class="operation-number">${idx + 1}.</span> ${formatOpSummary(op)}${sourceBadge}${deletedBadge}
                                </div>
                                <div class="operation-actions">
                                    ${actionButton}
                                </div>
                            </div>
                        `;
                    }).join('');

                    // Modify timestamp display in timeline-header
                    item.innerHTML = `
						<div class="timeline-header">
							<button class="btn btn-sm btn-primary seek-btn" data-index="${index}" style="margin-left: 10px;">${getI18nText('record_seek')}</button>
							<span>
								<span class="timestamp-input-group">
									<input type="number" 
										   class="timestamp-input timestamp-minutes" 
										   min="0" 
										   max="99" 
										   value="${minutes}" 
										   data-index="${index}">
									<span class="timestamp-separator">:</span>
									<input type="number" 
										   class="timestamp-input timestamp-seconds" 
										   min="0" 
										   max="59" 
										   value="${seconds}" 
										   data-index="${index}">
								</span>
								| ${getI18nText('record_round')} ${pack.round || 1}${modifiedBadge} - ${pack.ops.filter(op => !op.deleted).length}/${opCount} ${getI18nText('record_ops')}</span>
							</span>
							<div>
								<button class="btn btn-sm btn-danger delete-btn" data-index="${index}" style="margin-left: 10px;">${getI18nText('delete')}</button>
							</div>
						</div>
						<div class="timeline-details">
							<div class="operations-list">
								${operationsHTML}
							</div>
						</div>
					`;

                    item.addEventListener('click', (e) => {
                        // Expand/collapse logic, but ignore clicks on any button
                        if (e.target.closest('button, input')) return;
                        item.classList.toggle('expanded');
                    });

                    // Event delegation for operations list
                    const opsListEl = item.querySelector('.operations-list');
                    opsListEl.addEventListener('click', (e) => {
                        const target = e.target;
                        const opIndex = parseInt(target.dataset.opIndex, 10);
                        if (target.classList.contains('btn-delete-op')) {
                            e.stopPropagation();
                            const opToDelete = pack.ops[opIndex];
                            const isNative = !opToDelete.source || opToDelete.source === 'native';

                            // Native operations can be restored, so delete directly without confirmation
                            // Inserted operations are permanently removed, so require confirmation
                            if (isNative) {
                                // Direct delete for native operations (can be restored)
                                nodecg.sendMessage('deleteOperation', { opsPackIndex: index, operationIndex: opIndex })
                                    .catch(err => alert('Failed to delete operation: ' + err.message));
                            } else {
                                // Confirm before deleting inserted operations (permanent)
                                const confirmMessage = `Are you sure you want to delete operation #${opIndex + 1} (${formatOpSummary(opToDelete)})?\n\nThis is an INSERTED operation and will be permanently removed.`;
                                if (confirm(confirmMessage)) {
                                    nodecg.sendMessage('deleteOperation', { opsPackIndex: index, operationIndex: opIndex })
                                        .catch(err => alert('Failed to delete operation: ' + err.message));
                                }
                            }
                        } else if (target.classList.contains('btn-restore-op')) {
                            e.stopPropagation();
                            nodecg.sendMessage('restoreOperation', { opsPackIndex: index, operationIndex: opIndex })
                                .catch(err => alert('Failed to restore operation: ' + err.message));
                        }
                    });

                    // New: Time input field event handling
                    const minutesInput = item.querySelector('.timestamp-minutes');
                    const secondsInput = item.querySelector('.timestamp-seconds');

                    function validateAndUpdateTimestamp(inputElement) {
                        const minutes = parseInt(minutesInput.value) || 0;
                        let seconds = parseInt(secondsInput.value) || 0;

                        // Validate seconds range
                        if (seconds < 0) seconds = 0;
                        if (seconds > 59) seconds = 59;

                        // Validate minutes range
                        const validMinutes = Math.max(0, Math.min(99, minutes));

                        // Update display values (handle invalid input)
                        minutesInput.value = validMinutes;
                        secondsInput.value = seconds;

                        // Check input validity
                        const isValid = seconds >= 0 && seconds <= 59 && validMinutes >= 0;

                        if (!isValid) {
                            inputElement.classList.add('invalid');
                            return;
                        }

                        inputElement.classList.remove('invalid');

                        // Build new timestamp
                        const newTimestamp = `${validMinutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                        // Only send update when timestamp actually changes
                        if (newTimestamp !== pack.timestamp) {
                            nodecg.sendMessage('editOpsPack', { index, newTimestamp })
                                .catch(err => {
                                    alert('Failed to update timestamp: ' + err);
                                    // Restore original value
                                    const [origMin, origSec] = pack.timestamp.split(':').map(Number);
                                    minutesInput.value = origMin;
                                    secondsInput.value = origSec;
                                });
                        }
                    }

                    // Use blur event (triggered on focus loss) to avoid frequent updates
                    minutesInput.addEventListener('blur', (e) => validateAndUpdateTimestamp(e.target));
                    secondsInput.addEventListener('blur', (e) => validateAndUpdateTimestamp(e.target));

                    // Support Enter key for quick confirmation
                    minutesInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.target.blur();
                        }
                    });
                    secondsInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.target.blur();
                        }
                    });

                    // Seconds input field: automatically handle values over 59
                    secondsInput.addEventListener('input', (e) => {
                        let value = parseInt(e.target.value);
                        if (value > 59) {
                            const extraMinutes = Math.floor(value / 60);
                            const newSeconds = value % 60;
                            const currentMinutes = parseInt(minutesInput.value) || 0;

                            minutesInput.value = currentMinutes + extraMinutes;
                            secondsInput.value = newSeconds;
                        }
                    });

                    const deleteBtn = item.querySelector('.delete-btn');
                    deleteBtn.addEventListener('click', () => {
                        // Analyze OpsPack composition
                        const nativeOps = pack.ops.filter(op => !op.source || op.source === 'native');
                        const insertedOps = pack.ops.filter(op => op.source === 'inserted');
                        const nativeCount = nativeOps.length;
                        const insertedCount = insertedOps.length;

                        // Build detailed confirmation message
                        let confirmMessage = getI18nText('record_delete_opspack_confirm') || 'Delete all operations in this OpsPack?';
                        confirmMessage += '\n\n';

                        if (nativeCount > 0) {
                            confirmMessage += `• ${nativeCount} ${getI18nText('record_native')} ${nativeCount === 1 ? 'operation' : 'operations'} will be marked as deleted (can be restored)\n`;
                        }

                        if (insertedCount > 0) {
                            confirmMessage += `• ${insertedCount} ${getI18nText('record_inserted')} ${insertedCount === 1 ? 'operation' : 'operations'} will be permanently removed\n`;
                        }

                        confirmMessage += '\n';

                        // Determine if OpsPack will be deleted
                        if (insertedCount > 0 && nativeCount === 0) {
                            confirmMessage += getI18nText('record_opspack_will_be_deleted') || 'The OpsPack itself will also be deleted.';
                        } else {
                            confirmMessage += getI18nText('record_opspack_will_be_kept') || 'The OpsPack will be kept for potential restoration.';
                        }

                        if (confirm(confirmMessage)) {
                            nodecg.sendMessage('deleteOpsPack', index)
                                .catch(err => alert('Failed to delete: ' + err));
                        }
                    });

                    const seekBtn = item.querySelector('.seek-btn');
                    seekBtn.addEventListener('click', () => {
                        if (confirm(`Restore to timestamp ${pack.timestamp}? This will reset the board and fast-forward.`)) {
                            nodecg.sendMessage('seekTimeline', index);
                        }
                    });

                    timelineList.appendChild(item);
                });
            }

            function renderDisplayTimeline() {
                // Save expanded state before re-rendering
                const expandedIndices = new Set();
                const existingItems = timelineDisplayList.querySelectorAll('.timeline-item.expanded');
                existingItems.forEach(item => {
                    const index = parseInt(item.dataset.index, 10);
                    if (!isNaN(index)) {
                        expandedIndices.add(index);
                    }
                });

                timelineDisplayList.innerHTML = '';
                if (!timelineDisplay.value || timelineDisplay.value.length === 0) {
                    timelineDisplayList.innerHTML = '<div style="color: #666; padding: 10px;">No display history recorded.</div>';
                    return;
                }

                timelineDisplay.value.forEach((op, index) => {
                    const item = document.createElement('div');
                    item.classList.add('timeline-item');
                    item.dataset.index = index;

                    // Restore expanded state if it was previously expanded
                    if (expandedIndices.has(index)) {
                        item.classList.add('expanded');
                    }

                    // Determine side and add class
                    let side = null;
                    if (op.payload && op.payload.side) {
                        side = op.payload.side;
                    } else if (op.type.endsWith('_L')) {
                        side = 'L';
                    } else if (op.type.endsWith('_R')) {
                        side = 'R';
                    }

                    if (side === 'L') item.classList.add('turn-l');
                    if (side === 'R') item.classList.add('turn-r');

                    // Highlight active item
                    if (playbackStatus.value && playbackStatus.value.currentIndexDisplay === index) {
                        item.classList.add('active');
                    }

                    let summary = '';
                    if (op.type === 'SHOW_CARD_L' || op.type === 'SHOW_CARD_R') {
                        summary = `Show Card (${op.payload.side}): ${getCardName(op.payload.cardId)}`;
                    } else if (op.type === 'SHOW_PRIZE_L' || op.type === 'SHOW_PRIZE_R') {
                        summary = `Show Prize (${op.payload.side})`;
                    } else if (op.type === 'HIDE_DISPLAY') {
                        summary = `Hide Display`;
                    } else if (op.type === 'TOGGLE_EXTRA_BENCH') {
                        summary = `Extra Bench (${op.payload.side}): ${op.payload.visible ? 'Show' : 'Hide'}`;
                    } else if (op.type === 'TOGGLE_PRIZE_TAKEN') {
                        summary = `Prize (${op.payload.side}) #${op.payload.index + 1}: ${op.payload.isTaken ? 'Taken' : 'Untaken'}`;
                    } else if (op.type === 'SET_PRIZE_CARD') {
                        summary = `Set Prize (${op.payload.side}) #${op.payload.index + 1}: ${op.payload.cardId}`;
                    } else if (op.type === 'CLEAR_PRIZE_CARDS') {
                        summary = `Clear Prizes (${op.payload.side})`;
                    } else {
                        summary = op.type;
                    }

                    // Apply similar modifications in renderDisplayTimeline function
                    const [minutes, seconds] = op.timestamp.split(':').map(Number);

                    item.innerHTML = `
            						<div class="timeline-header">
            							<button class="btn btn-sm btn-primary seek-btn" data-index="${index}" style="margin-left: 10px;">${getI18nText('record_seek')}</button>
            							<span>
            								<span class="timestamp-input-group">
            									<input type="number" 
            										   class="timestamp-input timestamp-minutes" 
            										   min="0" 
            										   max="99" 
            										   value="${minutes}" 
            										   data-index="${index}">
            									<span class="timestamp-separator">:</span>
            									<input type="number" 
            										   class="timestamp-input timestamp-seconds" 
            										   min="0" 
            										   max="59" 
            										   value="${seconds}" 
            										   data-index="${index}">
            								</span>
            								| ${summary}
            							</span>
            							<div>
            								<button class="btn btn-sm btn-danger delete-btn" data-index="${index}" style="margin-left: 10px;">${getI18nText('delete')}</button>
            							</div>
            						</div>
            					`;

                    // Add same input validation logic, but use editDisplayOp message
                    const minutesInput = item.querySelector('.timestamp-minutes');
                    const secondsInput = item.querySelector('.timestamp-seconds');

                    function validateAndUpdateTimestamp(inputElement) {
                        const minutes = parseInt(minutesInput.value) || 0;
                        let seconds = parseInt(secondsInput.value) || 0;

                        if (seconds < 0) seconds = 0;
                        if (seconds > 59) seconds = 59;
                        const validMinutes = Math.max(0, Math.min(99, minutes));

                        minutesInput.value = validMinutes;
                        secondsInput.value = seconds;

                        const isValid = seconds >= 0 && seconds <= 59 && validMinutes >= 0;

                        if (!isValid) {
                            inputElement.classList.add('invalid');
                            return;
                        }

                        inputElement.classList.remove('invalid');

                        const newTimestamp = `${validMinutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                        if (newTimestamp !== op.timestamp) {
                            nodecg.sendMessage('editDisplayOp', { index, newTimestamp })
                                .catch(err => {
                                    alert('Failed to update timestamp: ' + err);
                                    const [origMin, origSec] = op.timestamp.split(':').map(Number);
                                    minutesInput.value = origMin;
                                    secondsInput.value = origSec;
                                });
                        }
                    }

                    minutesInput.addEventListener('blur', (e) => validateAndUpdateTimestamp(e.target));
                    secondsInput.addEventListener('blur', (e) => validateAndUpdateTimestamp(e.target));
                    minutesInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') e.target.blur(); });
                    secondsInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') e.target.blur(); });

                    secondsInput.addEventListener('input', (e) => {
                        let value = parseInt(e.target.value);
                        if (value > 59) {
                            const extraMinutes = Math.floor(value / 60);
                            const newSeconds = value % 60;
                            const currentMinutes = parseInt(minutesInput.value) || 0;
                            minutesInput.value = currentMinutes + extraMinutes;
                            secondsInput.value = newSeconds;
                        }
                    });

                    const deleteBtn = item.querySelector('.delete-btn');
                    deleteBtn.addEventListener('click', () => {
                        if (confirm('Are you sure you want to delete this Display Op?')) {
                            nodecg.sendMessage('deleteDisplayOp', index)
                                .catch(err => alert('Failed to delete: ' + err));
                        }
                    });

                    const restoreBtn = item.querySelector('.seek-btn');
                    restoreBtn.addEventListener('click', () => {
                        const targetTime = op.timestamp;
                        if (confirm(`Restore to timestamp ${targetTime}? This will reset the board and fast-forward.`)) {
                            nodecg.sendMessage('seekToTimestamp', targetTime);
                        }
                    });

                    timelineDisplayList.appendChild(item);
                });
            }
            timelineGameplay.on('change', renderTimeline);
            timelineDisplay.on('change', renderDisplayTimeline);
            nodecg.listenFor('timelineRefreshed', () => {
                renderTimeline();
                renderDisplayTimeline();
            });

            nodecg.listenFor('opsPackMerged', (data) => {
                console.log(`OpsPack modified at ${data.timestamp}: ${data.newOpsCount} new ops appended, total ${data.totalOps} ops`);
                // UI will automatically refresh through timelineGameplay's change event
            });

            playbackStatus.on('change', (newVal) => {
                if (newVal) {
                    // timerDisplay.innerText = `Playback: ${newVal.currentTime}`; // Removed, using matchTimer
                    renderTimeline(); // Re-render to update highlights
                    renderDisplayTimeline(); // Re-render display timeline highlights

                    // Update Button States
                    // Replay button is always visible
                    // Toggle between Pause (when playing) and Resume (when not playing)
                    if (newVal.isPlaying) {
                        pauseBtn.style.display = 'inline-block';
                        resumeBtn.style.display = 'none';
                    } else {
                        pauseBtn.style.display = 'none';
                        resumeBtn.style.display = 'inline-block';
                    }
                }
            });

            playBtn.addEventListener('click', () => {
                if (confirm('Re-simulate entire timeline?')) {
                    nodecg.sendMessage('playTimeline');
                }
            });

            pauseBtn.addEventListener('click', () => {
                nodecg.sendMessage('pauseTimeline');
            });

            resumeBtn.addEventListener('click', () => {
                nodecg.sendMessage('resumeTimeline');
            });

            exportBtn.addEventListener('click', () => {
                nodecg.sendMessage('exportTimeline').then(jsonString => {
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(jsonString);
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    downloadAnchorNode.setAttribute("download", `match_data_${Date.now()}.json`);
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                }).catch(err => {
                    alert('Failed to export timeline: ' + err.message);
                });
            });

            importBtn.addEventListener('click', () => {
                importFile.click();
            });

            importFile.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const json = event.target.result;
                        // Validate JSON
                        JSON.parse(json);
                        if (confirm('Importing will overwrite the current timeline and decks. Continue?')) {
                            nodecg.sendMessage('importTimeline', json)
                                .then(() => alert('Import successful!'))
                                .catch(err => alert('Import failed: ' + err));
                        }
                    } catch (err) {
                        alert('Invalid JSON file.');
                    }
                };
                reader.readAsText(file);
                // Reset value so same file can be selected again
                importFile.value = '';
            });
        });
    </script>
</body>

</html>