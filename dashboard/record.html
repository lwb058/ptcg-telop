<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Records</title>
    <link rel="stylesheet" href="css/dashboard.css">
    <style>
        .timeline-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .timeline-item {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .timeline-item:hover {
            background: #3a3a3a;
        }

        .timeline-item.active {
            border-color: #299400;
            border-width: 3px;
            background: #2e3e2e;
        }

        .timeline-item.turn-l {
            background-color: rgba(35, 124, 165, 0.6);
        }

        .timeline-item.turn-r {
            background-color: rgba(176, 58, 58, 0.6);
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            color: #ddd;
        }

        .timeline-details {
            margin-top: 5px;
            font-size: 0.9em;
            color: #2d2d2d;
            display: none;
        }

        .timeline-item.expanded .timeline-details {
            display: block;
        }

        .controls-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #222;
            border-bottom: 1px solid #444;
            position: sticky;
            top: 0;
            z-index: 100;
        }
    </style>
</head>

<body>
    <div class="controls-bar">
        <div class="btn-group">
            <button id="play-btn" class="btn btn-primary">Replay</button>
            <button id="pause-btn" class="btn btn-warning" style="display: none;">Pause</button>
            <button id="resume-btn" class="btn btn-primary">Resume</button>
        </div>
        <div id="timer-display" style="font-family: monospace; font-size: 1.2em; color: #ddd; align-self: center;">
            Timer:00:00
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="insert-mode-toggle" checked style="width: auto; height: auto;">
            <label for="insert-mode-toggle" id="insert-mode-label" style="margin: 0; cursor: pointer;">Insert
                Mode</label>
        </div>
        <div
            style="display: flex; align-items: center; gap: 8px; margin-left: 10px; border-left: 1px solid #444; padding-left: 10px;">
            <span style="color: #aaa; font-size: 0.9em;">Tracks:</span>
            <input type="checkbox" id="track-gameplay-toggle" checked style="width: auto; height: auto;">
            <label for="track-gameplay-toggle" style="margin: 0; cursor: pointer; color: #ddd;">Gameplay</label>
            <input type="checkbox" id="track-display-toggle" checked style="width: auto; height: auto;">
            <label for="track-display-toggle" style="margin: 0; cursor: pointer; color: #ddd;">Display</label>
        </div>
        <div class="btn-group" style="margin-left: auto;">
            <button id="export-btn" class="btn btn-secondary">Export JSON</button>
            <button id="import-btn" class="btn btn-secondary">Import JSON</button>
        </div>
        <input type="file" id="import-file" style="display: none;" accept=".json">
    </div>

    <div class="panel-section">
        <h3>Timeline - GamePlay</h3>
        <div id="timeline-list" class="timeline-container">
            <!-- Timeline items will be injected here -->
        </div>
    </div>

    <div class="panel-section" style="margin-top: 20px; border-top: 1px solid #444; padding-top: 10px;">
        <h3>Timeline - Display</h3>
        <div id="timeline-display-list" class="timeline-container">
            <!-- Display Timeline items will be injected here -->
        </div>
    </div>
    </div>

    <script src="js/dashboard.js"></script>
    <script>
        NodeCG.waitForReplicants(
            nodecg.Replicant('timelineGameplay'),
            nodecg.Replicant('timelineDisplay'),
            nodecg.Replicant('playbackConfig'),
            nodecg.Replicant('cardDatabase'),
            nodecg.Replicant('firstMove'),
            nodecg.Replicant('ptcg-settings'),
            nodecg.Replicant('playbackStatus')
        ).then(() => {
            const timelineGameplay = nodecg.Replicant('timelineGameplay');
            const timelineDisplay = nodecg.Replicant('timelineDisplay');
            const playbackConfig = nodecg.Replicant('playbackConfig');
            const cardDatabase = nodecg.Replicant('cardDatabase');
            const firstMove = nodecg.Replicant('firstMove');
            const settingsRep = nodecg.Replicant('ptcg-settings');
            const playbackStatus = nodecg.Replicant('playbackStatus');
            const matchTimer = nodecg.Replicant('matchTimer');
            const gameTimeSettings = nodecg.Replicant('gameTimeSettings');
            const timelineList = document.getElementById('timeline-list');
            const timelineDisplayList = document.getElementById('timeline-display-list');
            const playBtn = document.getElementById('play-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const resumeBtn = document.getElementById('resume-btn');
            const exportBtn = document.getElementById('export-btn');
            const importBtn = document.getElementById('import-btn');
            const importFile = document.getElementById('import-file');
            const timerDisplay = document.getElementById('timer-display');
            const insertModeToggle = document.getElementById('insert-mode-toggle');
            const insertModeLabel = document.getElementById('insert-mode-label');
            const trackGameplayToggle = document.getElementById('track-gameplay-toggle');
            const trackDisplayToggle = document.getElementById('track-display-toggle');

            // Playback Config Logic
            function updatePlaybackConfigUI() {
                if (playbackConfig.value) {
                    trackGameplayToggle.checked = playbackConfig.value.gameplay;
                    trackDisplayToggle.checked = playbackConfig.value.display;
                }
            }

            trackGameplayToggle.addEventListener('change', () => {
                playbackConfig.value = { ...playbackConfig.value, gameplay: trackGameplayToggle.checked };
            });

            trackDisplayToggle.addEventListener('change', () => {
                playbackConfig.value = { ...playbackConfig.value, display: trackDisplayToggle.checked };
            });

            playbackConfig.on('change', updatePlaybackConfigUI);

            // Insert Mode toggle logic
            function updateInsertModeUI() {
                const isInsertMode = insertModeToggle.checked;
                insertModeLabel.textContent = isInsertMode ? 'Insert Mode' : 'Overwrite Mode';
                insertModeLabel.style.color = isInsertMode ? '#ddd' : '#ff6b6b'; // Red for destructive mode
            }

            insertModeToggle.addEventListener('change', () => {
                settingsRep.value = {
                    ...settingsRep.value,
                    insertMode: insertModeToggle.checked
                };
                updateInsertModeUI();
            });

            // Initialize from settings
            if (settingsRep.value && typeof settingsRep.value.insertMode === 'boolean') {
                insertModeToggle.checked = settingsRep.value.insertMode;
            } else {
                insertModeToggle.checked = true; // Default to Insert Mode
            }
            updateInsertModeUI();

            function updateTimerDisplay() {
                if (!matchTimer.value) return;

                let elapsed = matchTimer.value.offset;
                if (matchTimer.value.isRunning && matchTimer.value.startTime && matchTimer.value.mode === 'live') {
                    elapsed += (Date.now() - matchTimer.value.startTime);
                }

                // Handle Countdown vs Countup
                let displayTime = elapsed;
                if (gameTimeSettings.value && gameTimeSettings.value.useCountdown) {
                    const limit = (gameTimeSettings.value.limit || 1500) * 1000;
                    displayTime = Math.max(0, limit - elapsed);
                }

                const totalSeconds = Math.floor(displayTime / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                if (matchTimer.value.mode === 'standby') {
                    timerDisplay.innerText = "Standby";
                    timerDisplay.style.color = "#ffcc00";
                } else {
                    const modeStr = matchTimer.value.mode === 'playback' ? 'Playback' : 'Live';
                    timerDisplay.innerText = `${modeStr} - ${timeStr}`;
                    timerDisplay.style.color = "#ddd";
                }
            }

            matchTimer.on('change', (newValue) => {
                updateTimerDisplay();
                // We don't need a high-frequency interval here unless we want smooth live updates
                // But for Record panel, maybe 1s update is fine? Or 100ms if we want to see playback smoothly.
                // Let's use 100ms for consistency.
                if (newValue.isRunning) {
                    if (!window.recordTimerInterval) {
                        window.recordTimerInterval = setInterval(updateTimerDisplay, 100);
                    }
                } else {
                    if (window.recordTimerInterval) {
                        clearInterval(window.recordTimerInterval);
                        window.recordTimerInterval = null;
                    }
                }
            });

            gameTimeSettings.on('change', updateTimerDisplay);

            function getCardName(cardId) {
                const db = cardDatabase.value;
                if (db && db[cardId]) {
                    return db[cardId].name;
                }
                return cardId;
            }

            function formatOpSummary(op) {
                // Simplified summary for the timeline list
                const { type, payload } = op;
                const target = payload.target || '';
                switch (type) {
                    case 'ATTACK': return `Attack: ${payload.attackName}`;
                    case 'SET_POKEMON': return `Set: ${getCardName(payload.cardId)}`;
                    case 'KO_POKEMON': return `KO: ${target}`;
                    default: return `${type} (${target})`;
                }
            }

            function renderTimeline() {
                timelineList.innerHTML = '';
                if (!timelineGameplay.value || timelineGameplay.value.length === 0) {
                    timelineList.innerHTML = '<div style="color: #666; padding: 10px;">No history recorded.</div>';
                    return;
                }

                const firstMover = firstMove.value || 'L';

                timelineGameplay.value.forEach((pack, index) => {
                    const item = document.createElement('div');
                    item.classList.add('timeline-item');
                    item.dataset.index = index;

                    // Determine turn player and add class
                    const round = pack.round || 1;
                    const isOdd = round % 2 !== 0;
                    const isPlayerL = (firstMover === 'L' && isOdd) || (firstMover === 'R' && !isOdd);
                    item.classList.add(isPlayerL ? 'turn-l' : 'turn-r');

                    // Highlight active item
                    if (playbackStatus.value && playbackStatus.value.currentIndexGameplay === index) {
                        item.classList.add('active');
                        item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }

                    const opCount = pack.ops.length;
                    const summary = pack.ops.slice(0, 3).map(formatOpSummary).join(', ') + (opCount > 3 ? '...' : '');

                    item.innerHTML = `
                        <div class="timeline-header">
                            <button class="btn btn-sm btn-primary restore-btn" data-index="${index}" style="margin-left: 10px;">Restore</button>
                            <span>[${pack.timestamp}] Round ${pack.round || 1} - ${opCount} Ops</span>
                            <div>
                                <button class="btn btn-sm btn-secondary edit-btn" data-index="${index}" style="margin-left: 10px;">Edit</button>
                                <button class="btn btn-sm btn-danger delete-btn" data-index="${index}" style="margin-left: 10px;">Delete</button>
                            </div>
                        </div>
                        <div class="timeline-details">
                            ${summary}
                        </div>
                    `;

                    item.addEventListener('click', (e) => {
                        if (e.target.classList.contains('restore-btn') || e.target.classList.contains('edit-btn') || e.target.classList.contains('delete-btn')) return; // Don't toggle if clicking buttons
                        item.classList.toggle('expanded');
                    });

                    const editBtn = item.querySelector('.edit-btn');
                    editBtn.addEventListener('click', () => {
                        const currentTimestamp = pack.timestamp;
                        const newTimestamp = prompt(`Edit timestamp (format MM:SS):`, currentTimestamp);
                        if (newTimestamp !== null && newTimestamp !== currentTimestamp) {
                            // Validate format (MM:SS)
                            if (/^\d{2}:\d{2}$/.test(newTimestamp)) {
                                nodecg.sendMessage('editOpsPack', { index, newTimestamp })
                                    .catch(err => alert('Failed to update: ' + err));
                            } else {
                                alert('Invalid format. Please use MM:SS format.');
                            }
                        }
                    });

                    const deleteBtn = item.querySelector('.delete-btn');
                    deleteBtn.addEventListener('click', () => {
                        if (confirm('Are you sure you want to delete this OpsPack? This cannot be undone.')) {
                            nodecg.sendMessage('deleteOpsPack', index)
                                .catch(err => alert('Failed to delete: ' + err));
                        }
                    });

                    const seekBtn = item.querySelector('.restore-btn');
                    seekBtn.addEventListener('click', () => {
                        if (confirm(`Restore to timestamp ${pack.timestamp}? This will reset the board and fast-forward.`)) {
                            nodecg.sendMessage('seekTimeline', index);
                        }
                    });

                    timelineList.appendChild(item);
                });
            }

            function renderDisplayTimeline() {
                timelineDisplayList.innerHTML = '';
                if (!timelineDisplay.value || timelineDisplay.value.length === 0) {
                    timelineDisplayList.innerHTML = '<div style="color: #666; padding: 10px;">No display history recorded.</div>';
                    return;
                }

                timelineDisplay.value.forEach((op, index) => {
                    const item = document.createElement('div');
                    item.classList.add('timeline-item');
                    item.dataset.index = index;

                    // Determine side and add class
                    let side = null;
                    if (op.payload && op.payload.side) {
                        side = op.payload.side;
                    } else if (op.type.endsWith('_L')) {
                        side = 'L';
                    } else if (op.type.endsWith('_R')) {
                        side = 'R';
                    }

                    if (side === 'L') item.classList.add('turn-l');
                    if (side === 'R') item.classList.add('turn-r');

                    // Highlight active item
                    if (playbackStatus.value && playbackStatus.value.currentIndexDisplay === index) {
                        item.classList.add('active');
                    }

                    let summary = '';
                    if (op.type === 'SHOW_CARD_L' || op.type === 'SHOW_CARD_R') {
                        summary = `Show Card (${op.payload.side}): ${getCardName(op.payload.cardId)}`;
                    } else if (op.type === 'SHOW_PRIZE_L' || op.type === 'SHOW_PRIZE_R') {
                        summary = `Show Prize (${op.payload.side})`;
                    } else if (op.type === 'HIDE_DISPLAY') {
                        summary = `Hide Display`;
                    } else if (op.type === 'TOGGLE_EXTRA_BENCH') {
                        summary = `Extra Bench (${op.payload.side}): ${op.payload.visible ? 'Show' : 'Hide'}`;
                    } else if (op.type === 'TOGGLE_PRIZE_TAKEN') {
                        summary = `Prize (${op.payload.side}) #${op.payload.index + 1}: ${op.payload.isTaken ? 'Taken' : 'Untaken'}`;
                    } else if (op.type === 'SET_PRIZE_CARD') {
                        summary = `Set Prize (${op.payload.side}) #${op.payload.index + 1}: ${op.payload.cardId}`;
                    } else if (op.type === 'CLEAR_PRIZE_CARDS') {
                        summary = `Clear Prizes (${op.payload.side})`;
                    } else {
                        summary = op.type;
                    }

                    item.innerHTML = `
                        <div class="timeline-header">
                            <button class="btn btn-sm btn-primary restore-btn" data-index="${index}" style="margin-left: 10px;">Restore</button>
                            <span>[${op.timestamp}] ${summary}</span>
                            <div>
                                <button class="btn btn-sm btn-secondary edit-btn" data-index="${index}" style="margin-left: 10px;">Edit</button>
                                <button class="btn btn-sm btn-danger delete-btn" data-index="${index}" style="margin-left: 10px;">Delete</button>
                            </div>
                        </div>
                    `;

                    // Add Event Listeners
                    const editBtn = item.querySelector('.edit-btn');
                    editBtn.addEventListener('click', () => {
                        const currentTimestamp = op.timestamp;
                        const newTimestamp = prompt(`Edit timestamp (format MM:SS):`, currentTimestamp);
                        if (newTimestamp !== null && newTimestamp !== currentTimestamp) {
                            if (/^\d{2}:\d{2}$/.test(newTimestamp)) {
                                nodecg.sendMessage('editDisplayOp', { index, newTimestamp })
                                    .catch(err => alert('Failed to update: ' + err));
                            } else {
                                alert('Invalid format. Please use MM:SS format.');
                            }
                        }
                    });

                    const deleteBtn = item.querySelector('.delete-btn');
                    deleteBtn.addEventListener('click', () => {
                        if (confirm('Are you sure you want to delete this Display Op?')) {
                            nodecg.sendMessage('deleteDisplayOp', index)
                                .catch(err => alert('Failed to delete: ' + err));
                        }
                    });

                    const restoreBtn = item.querySelector('.restore-btn');
                    restoreBtn.addEventListener('click', () => {
                        const targetTime = op.timestamp;
                        if (confirm(`Restore to timestamp ${targetTime}? This will reset the board and fast-forward.`)) {
                            nodecg.sendMessage('seekToTimestamp', targetTime);
                        }
                    });

                    timelineDisplayList.appendChild(item);
                });
            }

            timelineGameplay.on('change', renderTimeline);
            timelineDisplay.on('change', renderDisplayTimeline);
            nodecg.listenFor('timelineRefreshed', () => {
                renderTimeline();
                renderDisplayTimeline();
            });

            playbackStatus.on('change', (newVal) => {
                if (newVal) {
                    // timerDisplay.innerText = `Playback: ${newVal.currentTime}`; // Removed, using matchTimer
                    renderTimeline(); // Re-render to update highlights
                    renderDisplayTimeline(); // Re-render display timeline highlights

                    // Update Button States
                    // Replay button is always visible
                    // Toggle between Pause (when playing) and Resume (when not playing)
                    if (newVal.isPlaying) {
                        pauseBtn.style.display = 'inline-block';
                        resumeBtn.style.display = 'none';
                    } else {
                        pauseBtn.style.display = 'none';
                        resumeBtn.style.display = 'inline-block';
                    }
                }
            });

            playBtn.addEventListener('click', () => {
                if (confirm('Re-simulate entire timeline?')) {
                    nodecg.sendMessage('playTimeline');
                }
            });

            pauseBtn.addEventListener('click', () => {
                nodecg.sendMessage('pauseTimeline');
            });

            resumeBtn.addEventListener('click', () => {
                nodecg.sendMessage('resumeTimeline');
            });

            exportBtn.addEventListener('click', () => {
                nodecg.sendMessage('exportTimeline').then(jsonString => {
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(jsonString);
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    downloadAnchorNode.setAttribute("download", `match_data_${Date.now()}.json`);
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                }).catch(err => {
                    alert('Failed to export timeline: ' + err.message);
                });
            });

            importBtn.addEventListener('click', () => {
                importFile.click();
            });

            importFile.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const json = event.target.result;
                        // Validate JSON
                        JSON.parse(json);
                        if (confirm('Importing will overwrite the current timeline and decks. Continue?')) {
                            nodecg.sendMessage('importTimeline', json)
                                .then(() => alert('Import successful!'))
                                .catch(err => alert('Import failed: ' + err));
                        }
                    } catch (err) {
                        alert('Invalid JSON file.');
                    }
                };
                reader.readAsText(file);
                // Reset value so same file can be selected again
                importFile.value = '';
            });
        });
    </script>
</body>

</html>