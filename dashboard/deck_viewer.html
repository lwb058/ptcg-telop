<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Deck Viewer</title>
    <style>
        body {
            font-family: sans-serif;
            background-color: #2f3a4f;
            color: #f0f0f0;
            margin: 0;
            padding: 1em;
        }
        .controls {
            margin-bottom: 1em;
        }
        .deck-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #4f5d7b;
            padding-bottom: 5px;
            margin-bottom: 1em;
        }
        .add-card-controls {
            display: flex;
            align-items: center;
        }
        .add-card-controls input {
            padding: 5px;
            margin-right: 5px;
        }
        .container {
            display: flex;
            gap: 20px;
        }
        .table-wrapper {
            /* Set a max-height and allow vertical scrolling. */
            /* Using vh is a bit risky, but 85vh should be safe for most panel sizes. */
            max-height: 85vh;
            overflow-y: auto;
            border: 1px solid #444;
            border-top: none;
        }
        .deck-table {
            border-collapse: collapse;
            width: 100%;
            table-layout: fixed;
        }
        .deck-table th, .deck-table td {
            border: 1px solid #444;
            padding: 8px;
            text-align: left;
        }
        /* Column widths */
        .deck-table th:nth-child(1) { width: 8%; }   /* 画像 */
        .deck-table th:nth-child(2) { width: auto; }  /* カード名 */
        .deck-table th:nth-child(3) { width: 20%; }  /* タイプ */
        .deck-table th:nth-child(4) { width: 10%; } /* ID */
        .deck-table th:nth-child(5) { width: 10%; }   /* 削除ボタン */

        .deck-table th {
            background-color: #3a455c;
            /* position:sticky is not reliable in NodeCG iframes, so we make the table header scroll with the content. */
        }
        .deck-table img {
            width: 45px;
            vertical-align: middle;
            cursor: pointer;
            transition: transform 0.1s ease-in-out;
        }
        .deck-table img:hover {
            transform: scale(1.1);
        }
        h2 {
            margin: 0;
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button id="clear-displays-btn">Clear Card Displays</button>
    </div>

    <div class="container">
        <div id="playerL-deck">
            <div class="deck-header">
                <h2 id="playerL-deck-title">Player L Deck</h2>
                <div class="add-card-controls">
                    <input type="text" id="add-card-id-L" placeholder="Enter Card ID to add">
                    <button id="add-card-btn-L">Add Card</button>
                </div>
            </div>
            <div class="table-wrapper">
                <table class="deck-table">
                    <thead>
                        <tr>
                            <th id="header-l-image">画像</th>
                            <th id="header-l-name">カード名</th>
                            <th id="header-l-type">タイプ</th>
                            <th id="header-l-id">ID</th>
                            <th id="header-l-delete">削除</th>
                        </tr>
                    </thead>
                    <tbody id="deckL-body">
                        <!-- Content will be generated by script -->
                    </tbody>
                </table>
            </div>
        </div>

        <div id="playerR-deck">
            <div class="deck-header">
                <h2 id="playerR-deck-title">Player R Deck</h2>
                <div class="add-card-controls">
                    <input type="text" id="add-card-id-R" placeholder="Enter Card ID to add">
                    <button id="add-card-btn-R">Add Card</button>
                </div>
            </div>
            <div class="table-wrapper">
                <table class="deck-table">
                    <thead>
                        <tr>
                            <th id="header-r-image">画像</th>
                            <th id="header-r-name">カード名</th>
                            <th id="header-r-type">タイプ</th>
                            <th id="header-r-id">ID</th>
                            <th id="header-r-delete">削除</th>
                        </tr>
                    </thead>
                    <tbody id="deckR-body">
                        <!-- Content will be generated by script -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        const cardToShowL = nodecg.Replicant('cardToShowL');
        const cardToShowR = nodecg.Replicant('cardToShowR');
        const deckL = nodecg.Replicant('deckL');
        const deckR = nodecg.Replicant('deckR');
        const playerL_name = nodecg.Replicant('playerL_name');
        const playerR_name = nodecg.Replicant('playerR_name');
        const database = nodecg.Replicant('cardDatabase');
        const settingsRep = nodecg.Replicant('ptcg-settings');
        const assetPaths = nodecg.Replicant('assetPaths');
        const i18nStrings = nodecg.Replicant('i18nStrings');
        const language = nodecg.Replicant('language');

        const deckLBody = document.getElementById('deckL-body');
        const deckRBody = document.getElementById('deckR-body');
        const clearButton = document.getElementById('clear-displays-btn');

        const addCardIdL = document.getElementById('add-card-id-L');
        const addCardBtnL = document.getElementById('add-card-btn-L');
        const addCardIdR = document.getElementById('add-card-id-R');
        const addCardBtnR = document.getElementById('add-card-btn-R');

        const playerLDeckTitle = document.getElementById('playerL-deck-title');
        const playerRDeckTitle = document.getElementById('playerR-deck-title');

        clearButton.addEventListener('click', () => {
            cardToShowL.value = '';
            cardToShowR.value = '';
        });

        const getI18nText = (key) => {
            if (!i18nStrings.value || !i18nStrings.value[key] || !language.value) {
                return key; // Fallback to key name if not found
            }
            return i18nStrings.value[key][language.value] || i18nStrings.value[key]['jp'] || key;
        };

        function updateUIText() {
            // Deck table headers
            document.getElementById('header-l-image').textContent = getI18nText('deck_viewer_header_image');
            document.getElementById('header-l-name').textContent = getI18nText('deck_viewer_header_card_name');
            document.getElementById('header-l-type').textContent = getI18nText('deck_viewer_header_type');
            document.getElementById('header-l-id').textContent = getI18nText('deck_viewer_header_id');
            document.getElementById('header-l-delete').textContent = getI18nText('delete');

            document.getElementById('header-r-image').textContent = getI18nText('deck_viewer_header_image');
            document.getElementById('header-r-name').textContent = getI18nText('deck_viewer_header_card_name');
            document.getElementById('header-r-type').textContent = getI18nText('deck_viewer_header_type');
            document.getElementById('header-r-id').textContent = getI18nText('deck_viewer_header_id');
            document.getElementById('header-r-delete').textContent = getI18nText('delete');
        }

        function handleAddCard(side, inputEl) {
            const cardId = inputEl.value.trim();
            if (cardId) {
                nodecg.sendMessage('addSingleCardToDeck', { side: side, cardId: cardId })
                    .then(() => {
                        inputEl.value = ''; // Clear input on success
                    })
                    .catch(err => {
                        console.error(`Error adding card for player ${side}:`, err);
                        alert(`Failed to add card ${cardId}. See console for details.`);
                    });
            }
        }

        addCardBtnL.addEventListener('click', () => {
            handleAddCard('L', addCardIdL);
        });
        addCardIdL.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') handleAddCard('L', addCardIdL);
        });

        addCardBtnR.addEventListener('click', () => {
            handleAddCard('R', addCardIdR);
        });
        addCardIdR.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') handleAddCard('R', addCardIdR);
        });

        NodeCG.waitForReplicants(deckL, deckR, database, playerL_name, playerR_name, i18nStrings, language).then(() => {
            // Set initial titles
            playerLDeckTitle.textContent = `${playerL_name.value || 'Player L'}'s Deck`;
            playerRDeckTitle.textContent = `${playerR_name.value || 'Player R'}'s Deck`;

            updateUIText();
            renderDeck(deckL.value, deckLBody, database.value, 'L');
            renderDeck(deckR.value, deckRBody, database.value, 'R');
        });

        playerL_name.on('change', (newValue) => {
            playerLDeckTitle.textContent = `${newValue || 'Player L'}'s Deck`;
        });
        playerR_name.on('change', (newValue) => {
            playerRDeckTitle.textContent = `${newValue || 'Player R'}'s Deck`;
        });

        deckL.on('change', (newValue) => {
            renderDeck(newValue, deckLBody, database.value, 'L');
        });

        deckR.on('change', (newValue) => {
            renderDeck(newValue, deckRBody, database.value, 'R');
        });

        language.on('change', () => {
            updateUIText();
            renderDeck(deckL.value, deckLBody, database.value, 'L');
            renderDeck(deckR.value, deckRBody, database.value, 'R');
        });

        assetPaths.on('change', () => {
            renderDeck(deckL.value, deckLBody, database.value, 'L');
            renderDeck(deckR.value, deckRBody, database.value, 'R');
        });

        // --- Hotkey Logic ---
        let hotkeys = { clearCard: ' ' }; // Default hotkey

        settingsRep.on('change', (newValue) => {
            if (newValue && newValue.hotkeys) {
                hotkeys = newValue.hotkeys;
            }
        });

        function checkHotkey(e, hotkeyString) {
            if (!hotkeyString || typeof hotkeyString !== 'string') return false;
            
            // Special case for space key
            if (hotkeyString.toLowerCase() === 'space' || hotkeyString === ' ') {
                return e.key === ' ';
            }

            const parts = hotkeyString.toLowerCase().split('+').map(p => p.trim());
            const key = parts.pop();

            if (e.key.toLowerCase() !== key) return false;
            if (parts.includes('ctrl') !== e.ctrlKey) return false;
            if (parts.includes('alt') !== e.altKey) return false;
            if (parts.includes('shift') !== e.shiftKey) return false;
            if (parts.includes('meta') !== e.metaKey) return false; // For Command key on Mac

            return true;
        }

        document.addEventListener('keydown', (e) => {
            // Ignore hotkeys if user is typing in an input field
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                return;
            }

            if (checkHotkey(e, hotkeys.clearCard)) {
                e.preventDefault();
                clearButton.click();
            }
        });

        function renderDeck(deck, tableBody, db, side) {
            if (!deck || !deck.cards || !db) {
                tableBody.innerHTML = '<tr><td colspan="5">Waiting for data...</td></tr>';
                return;
            }

            const supertypeOrder = { 'pokemon': 1, 'trainer': 2, 'energy': 3 };
            const trainerSubtypeOrder = { 'item': 1, 'tool': 2, 'supporter': 3, 'stadium': 4 };
            const energySubtypeOrder = { 'special energy': 1, 'basic energy': 2 };
            const pokemonTypeOrder = { '草': 1, '炎': 2, '水': 3, '雷': 4, '超': 5, '闘': 6, '悪': 7, '鋼': 8, '竜': 9, '無': 10, '妖': 11 };

            // Use a Set to get unique card IDs from the deck list
            const uniqueCardIds = [...new Set(deck.cards)];
            const sortableCards = uniqueCardIds.map(cardId => ({
                id: cardId,
                data: db[cardId]
            })).filter(card => card.data);

            sortableCards.sort((a, b) => {
                const aData = a.data;
                const bData = b.data;
                const supertypeComparison = (supertypeOrder[aData.supertype] || 99) - (supertypeOrder[bData.supertype] || 99);
                if (supertypeComparison !== 0) return supertypeComparison;

                if (aData.supertype === 'pokemon') {
                    const typeConversionMap = { '火': '炎', '斗': '闘', '恶': '悪', '钢': '鋼', '龙': '竜' , "无": "無"};
                    const getSortableType = (card) => (card?.pokemon?.color?.[0]) ? (typeConversionMap[card.pokemon.color[0]] || card.pokemon.color[0]) : null;
                    
                    const aSortType = getSortableType(aData);
                    const bSortType = getSortableType(bData);
                    const pokemonTypeComparison = (pokemonTypeOrder[aSortType] || 99) - (pokemonTypeOrder[bSortType] || 99);
                    if (pokemonTypeComparison !== 0) return pokemonTypeComparison;

                }
                else if (aData.supertype === 'trainer') {
                    const trainerSubtypeComparison = (trainerSubtypeOrder[aData.subtype] || 99) - (trainerSubtypeOrder[bData.subtype] || 99);
                    if (trainerSubtypeComparison !== 0) return trainerSubtypeComparison;
                } else if (aData.supertype === 'energy') {
                    const energyTypeComparison = (pokemonTypeOrder[aData.energy] || 99) - (pokemonTypeOrder[bData.energy] || 99);
                    if (energyTypeComparison !== 0) return energyTypeComparison;
                    const energySubtypeComparison = (energySubtypeOrder[aData.subtype] || 99) - (energySubtypeOrder[bData.subtype] || 99); // Basic vs Special
                    if (energySubtypeComparison !== 0) return energySubtypeComparison;
                }
                return a.id.localeCompare(b.id);
            });

            tableBody.innerHTML = '';
            for (const card of sortableCards) {
                const cardData = card.data;
                const row = document.createElement('tr');

                const imgCell = document.createElement('td');
                const img = document.createElement('img');

                const getCardImageUrl = (cardId) => {
                    if (!cardId || !assetPaths.value || !assetPaths.value.cardImgPath || !database.value) {
                        return '/assets/ptcg-telop/element/default.jpg';
                    }
                    const db = database.value;
                    const cardData = db ? db[cardId] : null;
                    const imageUrl = cardData ? cardData.image_url : null;
                    const extension = imageUrl ? imageUrl.substring(imageUrl.lastIndexOf('.')) : '.jpg';
                    return `/${assetPaths.value.cardImgPath}${cardId}${extension}`;
                };

                img.src = getCardImageUrl(card.id);
                img.title = getI18nText('deck_viewer_show_card_tip');
                img.onerror = () => { img.src = '/assets/ptcg-telop/element/default.jpg'; };
                img.onclick = () => {
                    const targetReplicant = (side === 'L') ? cardToShowL : cardToShowR;
                    const imageUrl = getCardImageUrl(card.id);
                    targetReplicant.value = imageUrl;
                };
                imgCell.appendChild(img);
                row.appendChild(imgCell);

                const nameCell = document.createElement('td');
                nameCell.textContent = cardData.name;
                row.appendChild(nameCell);

                const typeCell = document.createElement('td');
                let typeText = (cardData.supertype || '').charAt(0).toUpperCase() + (cardData.supertype || '').slice(1);
                if (cardData.supertype == 'pokemon') {
                    typeText =cardData.supertype
                    if(cardData.pokemon.option){
                        typeText += ` ${cardData.pokemon.option}`;
                    }
                    if(cardData.subtype){
                        typeText += ` ${cardData.subtype}`;
                    }
                }else{
                    typeText = cardData.subtype;
                }
                typeCell.textContent = typeText;
                row.appendChild(typeCell);

                const idCell = document.createElement('td');
                idCell.textContent = card.id;
                row.appendChild(idCell);

                const deleteCell = document.createElement('td');
                const deleteButton = document.createElement('button');
                deleteButton.textContent = getI18nText('delete');
                deleteButton.onclick = () => {
                    const playerName = side === 'L' ? (playerL_name.value || 'Player L') : (playerR_name.value || 'Player R');
                    if (confirm(`「${cardData.name}」を${playerName}のデッキから削除しますか？\n\nRemove "${cardData.name}" from ${playerName}'s deck?`)) {
                        nodecg.sendMessage('removeCardFromDeck', { side: side, cardId: card.id })
                            .catch(err => {
                                console.error(`Error removing card for player ${side}:`, err);
                                alert(`Failed to remove card ${card.id}. See console for details.`);
                            });
                    }
                };
                deleteCell.appendChild(deleteButton);
                row.appendChild(deleteCell);

                tableBody.appendChild(row);
            }
        }
    </script>

</body>
</html>