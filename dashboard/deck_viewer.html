<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Deck Viewer</title>
    <link rel="stylesheet" href="css/dashboard.css">
</head>

<body class="deck-viewer-body">
    <div class="controls">
        <button id="clear-displays-btn">Clear Card Displays</button>
    </div>

    <div class="container">
        <div id="playerL-deck">
            <div class="prize-section">
                <div class="prize-header">
                    <h3 id="prize-title-L">Prize Cards</h3>
                    <div class="header-center">
                        <button id="prize-show-L" class="btn btn-primary" style="width: 120px">Show</button>
                    </div>
                    <div class="prize-controls">
                        <button id="prize-clear-L" class="btn btn-danger">Clear</button>
                    </div>
                </div>
                <div class="prize-grid" id="prize-grid-L"></div>
            </div>
            <div class="deck-header">
                <h2 id="playerL-deck-title">Player L Deck</h2>
                <div class="view-controls">
                    <button class="view-btn" data-view="table" data-player="L">List</button>
                    <button class="view-btn active" data-view="icon" data-player="L">Grid</button>
                </div>
                <div class="add-card-controls">
                    <input type="text" id="add-card-id-L" placeholder="Enter Deck ID or Card ID">
                    <button id="add-card-btn-L">Import</button>
                </div>
            </div>
            <div class="table-wrapper" id="deckL-table-wrapper">
                <table class="deck-table">
                    <thead>
                        <tr>
                            <th id="header-l-image">画像</th>
                            <th id="header-l-name">カード名</th>
                            <th id="header-l-type">タイプ</th>
                            <th id="header-l-id">ID</th>
                            <th id="header-l-delete">削除</th>
                        </tr>
                    </thead>
                    <tbody id="deckL-body"></tbody>
                </table>
            </div>
            <div class="icon-view-wrapper" id="deckL-icon-wrapper"></div>
        </div>

        <div id="playerR-deck">
            <div class="prize-section">
                <div class="prize-header">
                    <h3 id="prize-title-R">Prize Cards</h3>
                    <div class="header-center">
                        <button id="prize-show-R" class="btn btn-primary" style="width: 120px">Show</button>
                    </div>
                    <div class="prize-controls">
                        <button id="prize-clear-R" class="btn btn-danger">Clear</button>
                    </div>
                </div>
                <div class="prize-grid" id="prize-grid-R"></div>
            </div>
            <div class="deck-header">
                <h2 id="playerR-deck-title">Player R Deck</h2>
                <div class="view-controls">
                    <button class="view-btn" data-view="table" data-player="R">List</button>
                    <button class="view-btn active" data-view="icon" data-player="R">Grid</button>
                </div>
                <div class="add-card-controls">
                    <input type="text" id="add-card-id-R" placeholder="Enter Deck ID or Card ID">
                    <button id="add-card-btn-R">Import</button>
                </div>
            </div>
            <div class="table-wrapper" id="deckR-table-wrapper">
                <table class="deck-table">
                    <thead>
                        <tr>
                            <th id="header-r-image">画像</th>
                            <th id="header-r-name">カード名</th>
                            <th id="header-r-type">タイプ</th>
                            <th id="header-r-id">ID</th>
                            <th id="header-r-delete">削除</th>
                        </tr>
                    </thead>
                    <tbody id="deckR-body"></tbody>
                </table>
            </div>
            <div class="icon-view-wrapper" id="deckR-icon-wrapper"></div>
        </div>
    </div>

    <script src="js/dashboard.js"></script>
    <script src="js/deck_importer.js"></script>
    <script>
        // Replicants
        var cardToShowL = nodecg.Replicant('cardToShowL');
        var cardToShowR = nodecg.Replicant('cardToShowR');
        var prizeCardsL = nodecg.Replicant('prizeCardsL');
        var prizeCardsR = nodecg.Replicant('prizeCardsR');
        var deckL = nodecg.Replicant('deckL');
        var deckR = nodecg.Replicant('deckR');
        var playerL_name = nodecg.Replicant('playerL_name');
        var playerR_name = nodecg.Replicant('playerR_name');
        var cardDatabase = nodecg.Replicant('cardDatabase');
        var settingsRep = nodecg.Replicant('ptcg-settings');
        var assetPaths = nodecg.Replicant('assetPaths');
        var i18nStrings = nodecg.Replicant('i18nStrings');
        var language = nodecg.Replicant('language');
        var deckLoadingStatus = nodecg.Replicant('deckLoadingStatus');

        // DOM Elements
        const deckLBody = document.getElementById('deckL-body');
        const deckRBody = document.getElementById('deckR-body');
        const deckLIconWrapper = document.getElementById('deckL-icon-wrapper');
        const deckRIconWrapper = document.getElementById('deckR-icon-wrapper');
        const clearButton = document.getElementById('clear-displays-btn');
        const addCardIdL = document.getElementById('add-card-id-L');
        const addCardBtnL = document.getElementById('add-card-btn-L');
        const addCardIdR = document.getElementById('add-card-id-R');
        const addCardBtnR = document.getElementById('add-card-btn-R');
        const playerLDeckTitle = document.getElementById('playerL-deck-title');
        const playerRDeckTitle = document.getElementById('playerR-deck-title');
        const prizeGridL = document.getElementById('prize-grid-L');
        const prizeGridR = document.getElementById('prize-grid-R');
        const prizeShowL = document.getElementById('prize-show-L');
        const prizeShowR = document.getElementById('prize-show-R');
        const prizeClearL = document.getElementById('prize-clear-L');
        const prizeClearR = document.getElementById('prize-clear-R');

        // Global State
        let deckViews = { L: 'icon', R: 'icon' };

        // --- Hotkey Handling ---
        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
        let hotkeys = {
            discard: 'Escape',
            apply: isMac ? 'Meta+S' : 'Control+S',
            clearSelection: 'Delete',
            clearCard: ' '
        };

        settingsRep.on('change', (newValue) => {
            if (newValue && newValue.hotkeys) {
                hotkeys.discard = newValue.hotkeys.discard || 'Escape';
                hotkeys.apply = newValue.hotkeys.apply || (isMac ? 'Meta+S' : 'Control+S');
                hotkeys.clearSelection = newValue.hotkeys.clearSelection || 'Delete';
                hotkeys.clearCard = newValue.hotkeys.clearCard || ' ';
            }
        });

        document.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || document.activeElement.tagName === 'SELECT') return;

            if (checkHotkey(e, hotkeys.clearCard)) {
                e.preventDefault();
                clearButton.click();
            }
        });

        // --- Helper Functions ---
        function updateUIText() {
            ['l', 'r'].forEach(s => {
                document.getElementById(`header-${s}-image`).textContent = getI18nText('deck_viewer_header_image');
                document.getElementById(`header-${s}-name`).textContent = getI18nText('deck_viewer_header_card_name');
                document.getElementById(`header-${s}-type`).textContent = getI18nText('deck_viewer_header_type');
                document.getElementById(`header-${s}-id`).textContent = getI18nText('deck_viewer_header_id');
                document.getElementById(`header-${s}-delete`).textContent = getI18nText('delete');
            });
            document.getElementById('prize-title-L').textContent = getI18nText('prize_cards');
            document.getElementById('prize-show-L').textContent = getI18nText('show');
            document.getElementById('prize-clear-L').textContent = getI18nText('clear');
            document.getElementById('prize-title-R').textContent = getI18nText('prize_cards');
            document.getElementById('prize-show-R').textContent = getI18nText('show');
            document.getElementById('prize-clear-R').textContent = getI18nText('clear');
        }
        function sortCards(cardIds, db) {
            const supertypeOrder = { 'pokemon': 1, 'trainer': 2, 'energy': 3 };
            const trainerSubtypeOrder = { 'item': 1, 'tool': 2, 'supporter': 3, 'stadium': 4 };
            const energySubtypeOrder = { 'special energy': 1, 'basic energy': 2 };
            const pokemonTypeOrder = { '草': 1, '炎': 2, '水': 3, '雷': 4, '超': 5, '闘': 6, '悪': 7, '鋼': 8, '竜': 9, '無': 10, '妖': 11 };
            const sortableCards = cardIds.map(cardId => ({ id: cardId, data: db[cardId] })).filter(card => card.data);
            sortableCards.sort((a, b) => {
                const aData = a.data;
                const bData = b.data;
                const supertypeComparison = (supertypeOrder[aData.supertype] || 99) - (supertypeOrder[bData.supertype] || 99);
                if (supertypeComparison !== 0) return supertypeComparison;
                if (aData.supertype === 'pokemon') {
                    const typeConversionMap = { '火': '炎', '斗': '闘', '恶': '悪', '钢': '鋼', '龙': '竜', "無": "無" };
                    const getSortableType = (card) => (card?.pokemon?.color?.[0]) ? (typeConversionMap[card.pokemon.color[0]] || card.pokemon.color[0]) : null;
                    const aSortType = getSortableType(aData);
                    const bSortType = getSortableType(bData);
                    const pokemonTypeComparison = (pokemonTypeOrder[aSortType] || 99) - (pokemonTypeOrder[bSortType] || 99);
                    if (pokemonTypeComparison !== 0) return pokemonTypeComparison;
                } else if (aData.supertype === 'trainer') {
                    const trainerSubtypeComparison = (trainerSubtypeOrder[aData.subtype] || 99) - (trainerSubtypeOrder[bData.subtype] || 99);
                    if (trainerSubtypeComparison !== 0) return trainerSubtypeComparison;
                } else if (aData.supertype === 'energy') {
                    const energyTypeComparison = (pokemonTypeOrder[aData.energy] || 99) - (pokemonTypeOrder[bData.energy] || 99);
                    if (energyTypeComparison !== 0) return energyTypeComparison;
                    const energySubtypeComparison = (energySubtypeOrder[aData.subtype] || 99) - (energySubtypeOrder[bData.subtype] || 99);
                    if (energySubtypeComparison !== 0) return energySubtypeComparison;
                }
                return a.id.localeCompare(b.id);
            });
            return sortableCards;
        }

        // --- Drag and Drop Handlers ---
        function handleDragStart(e) {
            e.dataTransfer.setData('text/plain', e.target.dataset.cardId);
            e.dataTransfer.effectAllowed = 'copy';
        }
        function handleDragOver(e) {
            e.preventDefault();
            // Check if the drag is a prize card move vs. a card from the deck
            if (e.dataTransfer.types.includes('application/json')) {
                e.dataTransfer.dropEffect = 'move'; // Internal move
            } else {
                e.dataTransfer.dropEffect = 'copy'; // New card from deck
            }
            e.currentTarget.classList.add('droppable-hover');
        }
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('droppable-hover');
        }
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('droppable-hover');

            const toSide = e.currentTarget.dataset.side;
            const toIndex = parseInt(e.currentTarget.dataset.index, 10);
            const prizeRep = toSide === 'L' ? prizeCardsL : prizeCardsR;
            const newPrizes = JSON.parse(JSON.stringify(prizeRep.value));

            // Case 1: Swapping two prize cards
            const prizeDragData = e.dataTransfer.getData('application/json');
            if (prizeDragData) {
                const { fromIndex: fromIndexStr, side: fromSide } = JSON.parse(prizeDragData);
                const fromIndex = parseInt(fromIndexStr, 10);

                if (fromSide !== toSide) return; // Cannot swap between players

                // Swap the prize objects
                const temp = newPrizes[toIndex];
                newPrizes[toIndex] = newPrizes[fromIndex];
                newPrizes[fromIndex] = temp;

                prizeRep.value = newPrizes;
                return;
            }

            // Case 2: Dropping a card from the deck list
            const cardId = e.dataTransfer.getData('text/plain');
            if (cardId) {
                newPrizes[toIndex] = { cardId: cardId, isTaken: false };
                prizeRep.value = newPrizes;
            }
        }

        // --- Render Functions ---
        function renderPrizes(side, prizeData, container) {
            if (!prizeData) return;
            container.innerHTML = '';
            for (let i = 0; i < 6; i++) {
                const prize = prizeData[i] || { cardId: null, isTaken: false };
                const slot = document.createElement('div');
                slot.className = 'prize-slot';
                slot.dataset.side = side;
                slot.dataset.index = i;

                if (prize.cardId) {
                    const img = document.createElement('img');
                    img.src = getCardImageUrl(prize.cardId);
                    img.draggable = true;
                    img.dataset.cardId = prize.cardId;
                    img.dataset.index = i;
                    img.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('application/json', JSON.stringify({ fromIndex: e.target.dataset.index, side: side }));
                        e.dataTransfer.effectAllowed = 'move';
                    });
                    slot.appendChild(img);

                    if (prize.isTaken) {
                        const overlay = document.createElement('div');
                        overlay.className = 'taken-overlay';
                        overlay.textContent = 'TAKEN';
                        slot.appendChild(overlay);
                    }

                    slot.addEventListener('click', () => {
                        const prizeRep = side === 'L' ? prizeCardsL : prizeCardsR;
                        const newPrizes = JSON.parse(JSON.stringify(prizeRep.value));
                        newPrizes[i].isTaken = !newPrizes[i].isTaken;
                        prizeRep.value = newPrizes;
                    });
                }

                slot.addEventListener('dragover', handleDragOver);
                slot.addEventListener('dragleave', handleDragLeave);
                slot.addEventListener('drop', handleDrop);
                container.appendChild(slot);
            }
        }

        function renderPlayerDeck(side, deck, db) {
            const view = deckViews[side];
            const tableWrapper = document.getElementById(`deck${side}-table-wrapper`);
            const iconWrapper = document.getElementById(`deck${side}-icon-wrapper`);

            if (view === 'table') {
                tableWrapper.style.display = 'block';
                iconWrapper.style.display = 'none';
                renderDeckTableView(deck, document.getElementById(`deck${side}-body`), db, side);
            } else { // 'icon' view
                tableWrapper.style.display = 'none';
                iconWrapper.style.display = 'block';
                renderDeckIconView(deck, iconWrapper, db, side);
            }
        }

        function renderDeckTableView(deck, tableBody, db, side) {
            if (!deck || !deck.cards || !db) {
                tableBody.innerHTML = '<tr><td colspan="5">Waiting for data...</td></tr>';
                return;
            }
            const uniqueCardIds = [...new Set(deck.cards)];
            const sortedCards = sortCards(uniqueCardIds, db);

            tableBody.innerHTML = '';
            for (const card of sortedCards) {
                const cardData = card.data;
                const row = document.createElement('tr');

                const imgCell = document.createElement('td');
                const img = document.createElement('img');
                img.src = getCardImageUrl(card.id);
                img.title = getI18nText('deck_viewer_show_card_tip');
                img.onerror = () => { img.src = '/assets/ptcg-telop/element/default.jpg'; };
                img.onclick = () => {
                    const targetReplicant = (side === 'L') ? cardToShowL : cardToShowR;
                    targetReplicant.value = getCardImageUrl(card.id);
                };
                img.draggable = true;
                img.dataset.cardId = card.id;
                img.addEventListener('dragstart', handleDragStart);
                imgCell.appendChild(img);
                row.appendChild(imgCell);

                const nameCell = document.createElement('td');
                nameCell.textContent = cardData.name;
                row.appendChild(nameCell);

                const typeCell = document.createElement('td');
                let typeText = cardData.supertype;
                if (cardData.supertype == 'pokemon') {
                    if (cardData.pokemon && cardData.pokemon.option) {
                        typeText += ` ${cardData.pokemon.option}`;
                    }
                    if (cardData.subtype) {
                        typeText += ` ${cardData.subtype}`;
                    }
                } else {
                    typeText = cardData.subtype;
                }
                typeCell.textContent = typeText;
                row.appendChild(typeCell);

                const idCell = document.createElement('td');
                idCell.textContent = card.id;
                row.appendChild(idCell);

                const deleteCell = document.createElement('td');
                const deleteButton = document.createElement('button');
                deleteButton.textContent = getI18nText('delete');
                deleteButton.onclick = () => {
                    const playerName = side === 'L' ? (playerL_name.value || 'Player L') : (playerR_name.value || 'Player R');
                    if (confirm(`「${cardData.name}」を${playerName}のデッキから削除しますか？\n\nRemove "${cardData.name}" from ${playerName}'s deck?`)) {
                        nodecg.sendMessage('removeCardFromDeck', { side: side, cardId: card.id })
                            .catch(err => {
                                console.error(`Error removing card for player ${side}:`, err);
                                alert(`Failed to remove card ${card.id}. See console for details.`);
                            });
                    }
                };
                deleteCell.appendChild(deleteButton);
                row.appendChild(deleteCell);

                tableBody.appendChild(row);
            }
        }

        function renderDeckIconView(deck, container, db, side) {
            if (!deck || !deck.cards || !db) {
                container.innerHTML = '<span>Waiting for data...</span>';
                return;
            }

            const uniqueCardIds = [...new Set(deck.cards)];
            const sortedCards = sortCards(uniqueCardIds, db);

            const groupedCards = { pokemon: [], trainer: [], energy: [] };
            for (const card of sortedCards) {
                if (card && card.data && groupedCards[card.data.supertype]) {
                    const count = deck.cards.filter(id => id === card.id).length;
                    groupedCards[card.data.supertype].push({ ...card, count });
                }
            }

            container.innerHTML = '';
            const supertypeDisplayOrder = ['pokemon', 'trainer', 'energy'];

            for (const supertype of supertypeDisplayOrder) {
                const cardsOfType = groupedCards[supertype];
                if (cardsOfType.length === 0) continue;

                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'card-category';

                const totalCount = cardsOfType.reduce((acc, card) => acc + card.count, 0);
                const title = document.createElement('h3');
                title.textContent = `${supertype.charAt(0).toUpperCase() + supertype.slice(1)} (${totalCount})`;
                categoryDiv.appendChild(title);

                const gridDiv = document.createElement('div');
                gridDiv.className = 'card-grid';

                for (const card of cardsOfType) {
                    const cardItemDiv = document.createElement('div');
                    cardItemDiv.className = 'card-item';

                    const img = document.createElement('img');
                    img.src = getCardImageUrl(card.id);
                    img.title = `${card.data.name}\n${getI18nText('deck_viewer_show_card_tip')}`;
                    img.onerror = () => { img.src = '/assets/ptcg-telop/element/default.jpg'; };
                    img.onclick = () => {
                        const targetReplicant = (side === 'L') ? cardToShowL : cardToShowR;
                        targetReplicant.value = getCardImageUrl(card.id);
                    };
                    img.draggable = true;
                    img.dataset.cardId = card.id;
                    img.addEventListener('dragstart', handleDragStart);
                    cardItemDiv.appendChild(img);

                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'delete-btn';
                    deleteButton.innerHTML = '&times;';
                    deleteButton.title = getI18nText('delete');
                    deleteButton.onclick = () => {
                        const playerName = side === 'L' ? (playerL_name.value || 'Player L') : (playerR_name.value || 'Player R');
                        if (confirm(`「${card.data.name}」を${playerName}のデッキから削除しますか？\n\nRemove "${card.data.name}" from ${playerName}'s deck?`)) {
                            nodecg.sendMessage('removeCardFromDeck', { side: side, cardId: card.id })
                                .catch(err => {
                                    console.error(`Error removing card for player ${side}:`, err);
                                    alert(`Failed to remove card ${card.id}. See console for details.`);
                                });
                        }
                    };
                    cardItemDiv.appendChild(deleteButton);
                    gridDiv.appendChild(cardItemDiv);
                }
                categoryDiv.appendChild(gridDiv);
                container.appendChild(categoryDiv);
            }
        }

        function renderAllDecksIfReady() {
            const db = cardDatabase.value;
            if (!db || Object.keys(db).length === 0) return;
            if (deckL.value) renderPlayerDeck('L', deckL.value, db);
            if (deckR.value) renderPlayerDeck('R', deckR.value, db);
        }

        // --- Event Listeners ---
        clearButton.addEventListener('click', () => {
            nodecg.sendMessageToBundle('_clearCard', 'ptcg-telop');
        });

        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const player = btn.dataset.player;
                const view = btn.dataset.view;
                deckViews[player] = view;
                document.querySelectorAll(`.view-btn[data-player="${player}"]`).forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                renderPlayerDeck(player, player === 'L' ? deckL.value : deckR.value, cardDatabase.value);
            });
        });

        prizeShowL.addEventListener('click', () => nodecg.sendMessageToBundle('_showPrizeCards', 'ptcg-telop', { side: 'L', cards: prizeCardsL.value }));
        prizeShowR.addEventListener('click', () => nodecg.sendMessageToBundle('_showPrizeCards', 'ptcg-telop', { side: 'R', cards: prizeCardsR.value }));
        prizeClearL.addEventListener('click', () => {
            if (confirm('Clear Player L prize cards?')) {
                prizeCardsL.value = Array.from({ length: 6 }, () => ({ cardId: null, isTaken: false }));
            }
        });
        prizeClearR.addEventListener('click', () => {
            if (confirm('Clear Player R prize cards?')) {
                prizeCardsR.value = Array.from({ length: 6 }, () => ({ cardId: null, isTaken: false }));
            }
        });

        // --- Replicant Change Listeners ---
        playerL_name.on('change', (newValue) => { playerLDeckTitle.textContent = `${newValue || 'Player L'}'s Deck`; });
        playerR_name.on('change', (newValue) => { playerRDeckTitle.textContent = `${newValue || 'Player R'}'s Deck`; });
        deckL.on('change', renderAllDecksIfReady);
        deckR.on('change', renderAllDecksIfReady);
        cardDatabase.on('change', renderAllDecksIfReady);
        language.on('change', () => { updateUIText(); renderAllDecksIfReady(); });
        assetPaths.on('change', renderAllDecksIfReady);
        prizeCardsL.on('change', (newValue) => renderPrizes('L', newValue, prizeGridL));
        prizeCardsR.on('change', (newValue) => renderPrizes('R', newValue, prizeGridR));

        // --- Init ---
        NodeCG.waitForReplicants(deckL, deckR, cardDatabase, playerL_name, playerR_name, i18nStrings, language, deckLoadingStatus, prizeCardsL, prizeCardsR).then(() => {
            playerLDeckTitle.textContent = `${playerL_name.value || 'Player L'}'s Deck`;
            playerRDeckTitle.textContent = `${playerR_name.value || 'Player R'}'s Deck`;
            updateUIText();
            renderAllDecksIfReady();
            renderPrizes('L', prizeCardsL.value, prizeGridL);
            renderPrizes('R', prizeCardsR.value, prizeGridR);

            // Setup the shared deck importers
            setupDeckImporter({ side: 'L', inputId: 'add-card-id-L', buttonId: 'add-card-btn-L' });
            setupDeckImporter({ side: 'R', inputId: 'add-card-id-R', buttonId: 'add-card-btn-R' });
        });
    </script>

</body>

</html>