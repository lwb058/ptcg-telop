<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Director Panel</title>
    <link rel="stylesheet" href="css/dashboard.css">
</head>

<body>

    <div class="panel-section">
        <h3>Game Setup & Timer</h3>
        <div style="display: flex; gap: 10px; align-items: center;">
            <div class="form-group" style="flex: 1; margin-bottom: 0;">
                <label for="first-player-select" data-i18n="first_move">First Move:</label>
                <select id="first-player-select">
                    <option value="">--Select--</option>
                    <option value="L">Left Player</option>
                    <option value="R">Right Player</option>
                </select>
            </div>
            <div class="timer-module"
                style="flex: 1; display: flex; align-items: center; gap: 5px; background: #333; padding: 5px; border-radius: 4px;">
                <div id="timer-display"
                    style="font-family: monospace; font-size: 1.5em; font-weight: bold; color: #fff;">00:00</div>
                <button id="timer-toggle-btn" class="btn btn-primary" style="padding: 2px 8px;">Start</button>
                <button id="timer-edit-btn" class="btn btn-secondary" style="padding: 2px 8px;">Edit</button>
            </div>
        </div>
    </div>

    <div class="panel-section">
        <h3>
            <div style="display: flex; align-items: center; justify-content: space-between;">Draft (Next OpsPack)
                <div class="form-group" style="margin-bottom: 0; justify-content: center;">
                    <input type="checkbox" id="auto-apply-checkbox" style="transform: scale(1.2); flex-grow: 0;">
                    <label for="auto-apply-checkbox" style="margin-left: 5px;">Auto-Apply</label>
                </div>
            </div>
        </h3>
        <div id="queue-manual-controls">
            <div id="op-buttons-container" class="flex-container" style="margin-bottom: 10px;">
                <button id="discard-op-btn" class="btn btn-danger">Discard (Esc)</button>
                <button id="apply-op-btn" class="btn btn-primary">Apply (Shift+S)</button>
            </div>
            <div class="operation-queue" id="operation-queue">
                <!-- Operations will be listed here -->
            </div>
        </div>
        <div id="auto-apply-warning" class="btn"
            style="display: none; width: 100%; box-sizing: border-box; font-weight: 800; color:#ff4040; background-color: black; pointer-events: none;">
            \\\\\\ WARNING: Auto-Apply Activated \\\\\\
        </div>
    </div>

    <div class="panel-section">
        <h3>Danger Zone</h3>
        <div class="flex-container" style="align-items: center;">
            <button id="restart-btn" class="btn btn-danger" style="flex: 1;">Restart Game</button>
            <button id="reset-system-btn" class="btn btn-superdanger" style="flex: 1;">Reset System</button>
        </div>
    </div>

    <script src="js/dashboard.js"></script>
    <script>
        NodeCG.waitForReplicants(
            nodecg.Replicant('operationQueue'),
            nodecg.Replicant('draft_currentTurn'),
            nodecg.Replicant('ptcg-settings'),
            nodecg.Replicant('playerL_name'),
            nodecg.Replicant('playerR_name'),
            nodecg.Replicant('cardDatabase'),
            nodecg.Replicant('firstMove'), // Added
            ...Array(18).fill(0).map((_, i) => { // Add all 18 slots
                const side = i < 9 ? 'L' : 'R';
                const index = i % 9;
                return nodecg.Replicant(`draft_slot${side}${index}`);
            })
        ).then(() => {
            // --- Replicant Setup ---
            const operationQueue = nodecg.Replicant('operationQueue');
            const draft_currentTurn = nodecg.Replicant('draft_currentTurn');
            const settingsRep = nodecg.Replicant('ptcg-settings');
            const playerL_name = nodecg.Replicant('playerL_name');
            const playerR_name = nodecg.Replicant('playerR_name');
            const cardDatabase = nodecg.Replicant('cardDatabase');
            const firstMove = nodecg.Replicant('firstMove');
            const matchTimer = nodecg.Replicant('matchTimer'); // Added
            const gameTimeSettings = nodecg.Replicant('gameTimeSettings'); // Added
            const slots = [];
            for (let i = 0; i < 9; i++) {
                slots.push(nodecg.Replicant(`draft_slotL${i}`));
                slots.push(nodecg.Replicant(`draft_slotR${i}`));
            }

            // --- DOM Element Setup ---
            const firstPlayerSelect = document.getElementById('first-player-select');
            const operationQueueEl = document.getElementById('operation-queue');
            const discardOpBtn = document.getElementById('discard-op-btn');
            const applyOpBtn = document.getElementById('apply-op-btn');
            const autoApplyWarning = document.getElementById('auto-apply-warning');
            const autoApplyCheckbox = document.getElementById('auto-apply-checkbox');
            const resetSystemBtn = document.getElementById('reset-system-btn');
            const restartBtn = document.getElementById('restart-btn');

            // Timer DOM
            const timerDisplay = document.getElementById('timer-display');
            const timerToggleBtn = document.getElementById('timer-toggle-btn');
            const timerEditBtn = document.getElementById('timer-edit-btn');

            // --- Core Functions ---
            function getCardName(slotId) {
                const db = cardDatabase.value;
                const slot = slots.find(s => s.name === `draft_${slotId}`);
                if (slot && slot.value && slot.value.cardId && db && db[slot.value.cardId]) {
                    return db[slot.value.cardId].name;
                }
                return slotId; // Fallback to slotId if name not found
            };

            function formatOperation(op) {
                const { type, payload } = op;
                const targetName = payload.target ? getCardName(payload.target) : '';

                switch (type) {
                    case 'SET_POKEMON':
                        return `<b>${payload.target}</b>: Set <b>${getCardName(payload.target)}</b>`;
                    case 'REPLACE_POKEMON':
                        return `<b>${targetName}</b>: ${payload.actionType} to <b>${getCardName(payload.target)}</b>`;
                    case 'SET_DAMAGE':
                        return `<b>${targetName}</b>: Set DMG to <b>${payload.value}</b>`;
                    case 'SET_EXTRA_HP':
                        return `<b>${targetName}</b>: Set Ex.HP to <b>${payload.value}</b>`;
                    case 'SET_TOOLS':
                        const toolNames = payload.tools.map(id => cardDatabase.value[id]?.name || 'Unknown').join(', ');
                        return `<b>${targetName}</b>: Set Tools to <b>[${toolNames}]</b>`;
                    case 'REMOVE_POKEMON':
                        return `<b>${targetName}</b>: Remove from play`;
                    case 'KO_POKEMON':
                        return `<b>${targetName}</b>: K.O.`;
                    case 'SET_AILMENTS':
                        return `<b>${targetName}</b>: Set Ailments to <b>[${payload.ailments.join(', ')}]</b>`;
                    case 'SET_ABILITY_USED':
                        return `<b>${targetName}</b>: Ability status set to <b>${payload.status}</b>`;
                    case 'SET_ENERGIES':
                        return `<b>${targetName}</b>: Set Energies (<b>${payload.energies.length} total</b>)`;
                    case 'SWITCH_POKEMON':
                        return `<b>${targetName}</b>: Switch to <b>${payload.target}</b>`;
                    case 'ATTACK':
                        const attackerName = getCardName(payload.attackerSlotId);
                        const targetNames = payload.targets && payload.targets.length > 0
                            ? payload.targets.map(getCardName).join(', ')
                            : null;

                        let description = `<b>${attackerName}</b> uses <b>${payload.attackName}</b>`;
                        if (targetNames) {
                            description += ` on <b>${targetNames}</b>`;
                        }
                        if (payload.damage > 0) {
                            description += ` for <b>${payload.damage}</b> DMG`;
                            if (payload.isWeakness) {
                                description += ` (Weakness)`;
                            }
                        }
                        return description;
                    case 'SET_TURN':
                        const turnPlayer = payload.side === 'L' ? (playerL_name.value || 'Left') : (playerR_name.value || 'Right');
                        return `<b>TURN</b>: Set turn to <b>${turnPlayer}</b>`;
                    case 'SET_ACTION_STATUS':
                        return `<b>${payload.target.replace('_', ' ')}</b>: Set to <b>${payload.status}</b>`;
                    case 'SET_SIDES':
                        return `<b>${payload.target}</b>: Set remaining to <b>${payload.value}</b>`;
                    case 'SET_STADIUM':
                        const stadiumName = payload.cardId ? cardDatabase.value[payload.cardId]?.name : 'None';
                        return `<b>STADIUM</b>: Set to <b>${stadiumName}</b>`;
                    default:
                        return `<b>${op.type}</b>: ${JSON.stringify(op.payload)}`;
                }
            }

            function updateFirstPlayerDropdown() {
                const lName = playerL_name.value || 'Left Player';
                const rName = playerR_name.value || 'Right Player';
                const currentValue = firstPlayerSelect.value;

                firstPlayerSelect.innerHTML = `
                    <option value="">--Select--</option>
                    <option value="L">${lName}</option>
                    <option value="R">${rName}</option>
                `;
                firstPlayerSelect.value = currentValue;
            }

            const renderQueue = () => {
                operationQueueEl.innerHTML = '';
                if (!operationQueue.value) return;
                operationQueue.value.forEach(op => {
                    const item = document.createElement('div');
                    item.classList.add('operation-item');
                    item.dataset.opId = op.id;
                    item.innerHTML = formatOperation(op);
                    operationQueueEl.appendChild(item);
                });
            };

            // --- Timer Logic ---
            let timerInterval;
            function updateTimerDisplay() {
                if (!matchTimer.value) return;

                let elapsed = matchTimer.value.offset;
                if (matchTimer.value.isRunning && matchTimer.value.startTime && matchTimer.value.mode === 'live') {
                    elapsed += (Date.now() - matchTimer.value.startTime);
                }
                // In playback mode, offset is the current time, and startTime is used by playback loop but not for display calculation here

                // Handle Countdown vs Countup
                let displayTime = elapsed;
                if (gameTimeSettings.value && gameTimeSettings.value.useCountdown) {
                    const limit = (gameTimeSettings.value.limit || 1500) * 1000;
                    displayTime = Math.max(0, limit - elapsed);
                }

                const totalSeconds = Math.floor(displayTime / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                // Update button state based on mode
                if (matchTimer.value.mode === 'playback') {
                    timerToggleBtn.textContent = 'Playback';
                    timerToggleBtn.disabled = true;
                    timerToggleBtn.classList.remove('btn-primary', 'btn-warning');
                    timerToggleBtn.classList.add('btn-secondary');
                } else {
                    timerToggleBtn.disabled = false;
                    if (matchTimer.value.isRunning) {
                        timerToggleBtn.textContent = 'Stop';
                        timerToggleBtn.classList.remove('btn-primary');
                        timerToggleBtn.classList.add('btn-warning');
                    } else {
                        timerToggleBtn.textContent = 'Start';
                        timerToggleBtn.classList.remove('btn-warning');
                        timerToggleBtn.classList.add('btn-primary');
                    }
                }
            }

            // --- Event Listeners ---
            firstPlayerSelect.addEventListener('change', (e) => {
                firstMove.value = e.target.value;
            });

            discardOpBtn.addEventListener('click', () => nodecg.sendMessage('discardQueue'));

            // Updated Apply Button Logic
            applyOpBtn.addEventListener('click', () => {
                // Use applyOpsPack instead of applyQueue
                nodecg.sendMessage('applyOpsPack');

                // Cooldown UI
                applyOpBtn.disabled = true;
                applyOpBtn.textContent = 'Applying...';
                setTimeout(() => {
                    applyOpBtn.disabled = false;
                    const currentHotkeys = hotkeyManager.hotkeys;
                    applyOpBtn.textContent = `Apply (${currentHotkeys.apply})`;
                }, 2000);
            });

            resetSystemBtn.addEventListener('click', () => {
                if (confirm('Are you sure you want to reset the entire system? This cannot be undone.')) {
                    nodecg.sendMessage('resetSystem');
                    nodecg.sendMessage('timerControl', { action: 'reset' }); // Also reset timer
                }
            });
            restartBtn.addEventListener('click', () => {
                if (confirm('Are you sure you want to restart game? This cannot be undone.')) {
                    nodecg.sendMessage('reStart');
                    nodecg.sendMessage('timerControl', { action: 'reset' }); // Also reset timer
                }
            });
            autoApplyCheckbox.addEventListener('change', (e) => {
                settingsRep.value.autoApply = e.target.checked;
            });

            // Timer Controls
            timerToggleBtn.addEventListener('click', () => {
                const action = matchTimer.value.isRunning ? 'stop' : 'start';
                nodecg.sendMessage('timerControl', { action });
            });

            timerEditBtn.addEventListener('click', () => {
                const currentSeconds = Math.floor(matchTimer.value.offset / 1000);
                const newSecondsStr = prompt('Enter elapsed time in seconds:', currentSeconds);
                if (newSecondsStr !== null) {
                    const newSeconds = parseInt(newSecondsStr, 10);
                    if (!isNaN(newSeconds)) {
                        nodecg.sendMessage('timerControl', { action: 'edit', seconds: newSeconds });
                    }
                }
            });

            // --- Replicant Listeners ---
            const hotkeyManager = new HotkeyManager(nodecg, settingsRep);

            operationQueue.on('change', renderQueue);

            draft_currentTurn.on('change', (newValue) => {
                // The turn radio buttons are gone, so this listener is now empty.
                // It can be removed if no other logic is added here.
            });

            firstMove.on('change', (newValue) => {
                firstPlayerSelect.value = newValue;
            });

            settingsRep.on('change', (newValue) => {
                const autoApply = !!newValue.autoApply;
                autoApplyCheckbox.checked = autoApply;

                const queueManualControls = document.getElementById('queue-manual-controls');
                autoApplyWarning.style.display = autoApply ? 'block' : 'none';
                queueManualControls.style.display = autoApply ? 'none' : 'block';

                // Update button labels with hotkeys
                const currentHotkeys = hotkeyManager.hotkeys;
                discardOpBtn.textContent = `Discard (${currentHotkeys.discard})`;
                applyOpBtn.textContent = `Apply (${currentHotkeys.apply})`;
            });

            playerL_name.on('change', (newName) => {
                updateFirstPlayerDropdown();
            });

            playerR_name.on('change', (newName) => {
                updateFirstPlayerDropdown();
            });

            matchTimer.on('change', (newValue) => {
                updateTimerDisplay();
                // Start/Stop interval based on running state
                if (newValue.isRunning) {
                    if (!timerInterval) {
                        timerInterval = setInterval(updateTimerDisplay, 100);
                    }
                } else {
                    if (timerInterval) {
                        clearInterval(timerInterval);
                        timerInterval = null;
                    }
                }
            });

            gameTimeSettings.on('change', updateTimerDisplay);

            // Initial setup
            renderQueue();

            // --- Hotkey Logic ---
            hotkeyManager.on('discard', () => discardOpBtn.click());
            hotkeyManager.on('apply', () => applyOpBtn.click());

            hotkeyManager.on('hotkeysChanged', (newHotkeys) => {
                discardOpBtn.textContent = `Discard (${newHotkeys.discard})`;
                applyOpBtn.textContent = `Apply (${newHotkeys.apply})`;
            });

            // Initial label update
            const initialHotkeys = hotkeyManager.hotkeys;
            discardOpBtn.textContent = `Discard (${initialHotkeys.discard})`;
            applyOpBtn.textContent = `Apply (${initialHotkeys.apply})`;
        });
    </script>
</body>

</html>