<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Director Panel</title>
    <link rel="stylesheet" href="css/dashboard.css">
    <style>
        /* Timer Edit Popup Styles */
        .timer-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
        }

        .timer-popup-content {
            position: absolute;
            background: #222;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            text-align: center;
            min-width: 250px;
        }

        .timer-popup-display {
            font-family: monospace;
            font-size: 2em;
            margin-bottom: 15px;
            color: #fff;
            background: #000;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .timer-popup-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .timer-popup-btn {
            padding: 8px;
            font-size: 0.9em;
            cursor: pointer;
            background: #333;
            color: #ddd;
            border: 1px solid #555;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .timer-popup-btn:hover {
            background: #444;
            border-color: #777;
        }

        .timer-popup-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            border-top: 1px solid #333;
            padding-top: 10px;
        }
    </style>
</head>

<body>

    <div class="panel-section">
        <h3>
            <div style="display: flex; align-items: center; justify-content: space-between;">Game Setup
                <div class="form-group" style="margin-bottom: 0; justify-content: center;">
                    <label for="first-player-select" data-i18n="first_move">First Move:</label>
                    <select id="first-player-select">
                        <option value="">--Select--</option>
                        <option value="L">Left Player</option>
                        <option value="R">Right Player</option>
                    </select>
                </div>
            </div>
        </h3>
        <div style="display: flex; gap: 10px; align-items: center;">
            <div class="timer-module"
                style="flex: 1; display: flex; align-items: center; justify-content: space-between; gap: 5px; background: #333; padding: 5px; border-radius: 4px;">

                <button id="timer-toggle-btn" class="btn btn-primary"
                    style="min-width:80px; padding: 2px 8px;">Start</button>
                <div id="timer-display"
                    style="font-family: monospace; font-size: 1.5em; font-weight: bold; color: #fff;">
                    00:00</div><button id="timer-edit-btn" class="btn btn-secondary"
                    style="padding: 2px 8px;">Edit</button>
            </div>
        </div>
    </div>
    </div>

    <!-- Timer Edit Popup -->
    <div id="timer-popup" class="timer-popup-overlay">
        <div class="timer-popup-content">
            <div id="popup-timer-display" class="timer-popup-display">00:00</div>
            <div class="timer-popup-controls">
                <button class="timer-popup-btn" data-adjust="30">+30s</button>
                <button class="timer-popup-btn" data-adjust="5">+5s</button>
                <button class="timer-popup-btn" data-adjust="1">+1s</button>
                <button class="timer-popup-btn" data-adjust="-30">-30s</button>
                <button class="timer-popup-btn" data-adjust="-5">-5s</button>
                <button class="timer-popup-btn" data-adjust="-1">-1s</button>
            </div>
            <div class="timer-popup-actions">
                <button id="timer-popup-cancel" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div class="panel-section">
        <h3>
            <div style="display: flex; align-items: center; justify-content: space-between;">Operation Queue
                <div class="form-group" style="margin-bottom: 0; justify-content: center;">
                    <input type="checkbox" id="auto-apply-checkbox" style="transform: scale(1.2); flex-grow: 0;">
                    <label for="auto-apply-checkbox" style="margin-left: 5px;">Auto-Apply</label>
                </div>
            </div>
        </h3>
        <div id="queue-manual-controls">
            <div id="op-buttons-container" class="flex-container" style="margin-bottom: 10px;">
                <button id="discard-op-btn" class="btn btn-danger">Discard (Esc)</button>
                <button id="apply-op-btn" class="btn btn-primary">Apply (Shift+S)</button>
            </div>
            <div class="operation-queue" id="operation-queue">
                <!-- Operations will be listed here -->
            </div>
        </div>
        <div id="auto-apply-warning" class="btn"
            style="display: none; width: 100%; box-sizing: border-box; font-weight: 800; color:#ff4040; background-color: black; pointer-events: none;">
            \\\\\\ WARNING: Auto-Apply Activated \\\\\\
        </div>
    </div>

    <div class="panel-section">
        <h3>Danger Zone</h3>
        <div class="flex-container" style="align-items: center;">
            <button id="restart-btn" class="btn btn-danger" style="flex: 1;">Restart Game</button>
            <button id="reset-system-btn" class="btn btn-superdanger" style="flex: 1;">Reset System</button>
        </div>
    </div>

    <script src="js/dashboard.js"></script>
    <script>
        NodeCG.waitForReplicants(
            nodecg.Replicant('operationQueue'),
            nodecg.Replicant('draft_currentTurn'),
            nodecg.Replicant('ptcg-settings'),
            nodecg.Replicant('playerL_name'),
            nodecg.Replicant('playerR_name'),
            nodecg.Replicant('cardDatabase'),
            nodecg.Replicant('firstMove'),
            nodecg.Replicant('matchTimer'),
            nodecg.Replicant('gameTimeSettings'),
            ...Array(18).fill(0).map((_, i) => {
                const side = i < 9 ? 'L' : 'R';
                const index = i % 9;
                return nodecg.Replicant(`draft_slot${side}${index}`);
            })
        ).then(() => {
            // --- Replicant Setup ---
            const operationQueue = nodecg.Replicant('operationQueue');
            const draft_currentTurn = nodecg.Replicant('draft_currentTurn');
            const settingsRep = nodecg.Replicant('ptcg-settings');
            const playerL_name = nodecg.Replicant('playerL_name');
            const playerR_name = nodecg.Replicant('playerR_name');
            const cardDatabase = nodecg.Replicant('cardDatabase');
            const firstMove = nodecg.Replicant('firstMove');
            const matchTimer = nodecg.Replicant('matchTimer');
            const gameTimeSettings = nodecg.Replicant('gameTimeSettings');
            const slots = [];
            for (let i = 0; i < 9; i++) {
                slots.push(nodecg.Replicant(`draft_slotL${i}`));
                slots.push(nodecg.Replicant(`draft_slotR${i}`));
            }

            // --- DOM Element Setup ---
            const firstPlayerSelect = document.getElementById('first-player-select');
            const operationQueueEl = document.getElementById('operation-queue');
            const discardOpBtn = document.getElementById('discard-op-btn');
            const applyOpBtn = document.getElementById('apply-op-btn');
            const autoApplyWarning = document.getElementById('auto-apply-warning');
            const autoApplyCheckbox = document.getElementById('auto-apply-checkbox');
            const resetSystemBtn = document.getElementById('reset-system-btn');
            const restartBtn = document.getElementById('restart-btn');

            // Timer DOM
            const timerDisplay = document.getElementById('timer-display');
            const timerToggleBtn = document.getElementById('timer-toggle-btn');
            const timerEditBtn = document.getElementById('timer-edit-btn');

            // Popup Elements
            const timerPopup = document.getElementById('timer-popup');
            const popupContent = timerPopup.querySelector('.timer-popup-content');
            const popupDisplay = document.getElementById('popup-timer-display');
            const popupCancelBtn = document.getElementById('timer-popup-cancel');
            const popupAdjustBtns = timerPopup.querySelectorAll('.timer-popup-btn');

            let tempSeconds = 0;


            // --- Core Functions ---
            function getCardName(slotId) {
                const db = cardDatabase.value;
                const slot = slots.find(s => s.name === `draft_${slotId}`);
                if (slot && slot.value && slot.value.cardId && db && db[slot.value.cardId]) {
                    return db[slot.value.cardId].name;
                }
                return slotId;
            };

            function formatOperation(op) {
                const { type, payload } = op;
                const targetName = payload.target ? getCardName(payload.target) : '';

                switch (type) {
                    case 'SET_POKEMON':
                        return `<b>${payload.target}</b>: Set <b>${getCardName(payload.target)}</b>`;
                    case 'REPLACE_POKEMON':
                        return `<b>${targetName}</b>: ${payload.actionType} to <b>${getCardName(payload.target)}</b>`;
                    case 'SET_DAMAGE':
                        return `<b>${targetName}</b>: Set DMG to <b>${payload.value}</b>`;
                    case 'SET_EXTRA_HP':
                        return `<b>${targetName}</b>: Set Ex.HP to <b>${payload.value}</b>`;
                    case 'SET_TOOLS':
                        const toolNames = payload.tools.map(id => cardDatabase.value[id]?.name || 'Unknown').join(', ');
                        return `<b>${targetName}</b>: Set Tools to <b>[${toolNames}]</b>`;
                    case 'REMOVE_POKEMON':
                        return `<b>${targetName}</b>: Remove from play`;
                    case 'KO_POKEMON':
                        return `<b>${targetName}</b>: K.O.`;
                    case 'SET_AILMENTS':
                        return `<b>${targetName}</b>: Set Ailments to <b>[${payload.ailments.join(', ')}]</b>`;
                    case 'SET_ABILITY_USED':
                        return `<b>${targetName}</b>: Ability status set to <b>${payload.status}</b>`;
                    case 'SET_ENERGIES':
                        return `<b>${targetName}</b>: Set Energies (<b>${payload.energies.length} total</b>)`;
                    case 'SWITCH_POKEMON':
                        return `<b>${targetName}</b>: Switch to <b>${payload.target}</b>`;
                    case 'ATTACK':
                        const attackerName = getCardName(payload.attackerSlotId);
                        const targetNames = payload.targets && payload.targets.length > 0
                            ? payload.targets.map(getCardName).join(', ')
                            : null;

                        let description = `<b>${attackerName}</b> uses <b>${payload.attackName}</b>`;
                        if (targetNames) {
                            description += ` on <b>${targetNames}</b>`;
                        }
                        if (payload.damage > 0) {
                            description += ` for <b>${payload.damage}</b> DMG`;
                            if (payload.isWeakness) {
                                description += ` (Weakness)`;
                            }
                        }
                        return description;
                    case 'SET_TURN':
                        const turnPlayer = payload.side === 'L' ? (playerL_name.value || 'Left') : (playerR_name.value || 'Right');
                        return `<b>TURN</b>: Set turn to <b>${turnPlayer}</b>`;
                    case 'SET_ACTION_STATUS':
                        return `<b>${payload.target.replace('_', ' ')}</b>: Set to <b>${payload.status}</b>`;
                    case 'SET_SIDES':
                        return `<b>${payload.target}</b>: Set remaining to <b>${payload.value}</b>`;
                    case 'SET_STADIUM':
                        const stadiumName = payload.cardId ? cardDatabase.value[payload.cardId]?.name : 'None';
                        return `<b>STADIUM</b>: Set to <b>${stadiumName}</b>`;
                    default:
                        return `<b>${op.type}</b>: ${JSON.stringify(op.payload)}`;
                }
            }

            function updateFirstPlayerDropdown() {
                const lName = playerL_name.value || 'Left Player';
                const rName = playerR_name.value || 'Right Player';
                const currentValue = firstPlayerSelect.value;

                firstPlayerSelect.innerHTML = `
                    <option value="">--Select--</option>
                    <option value="L">${lName}</option>
                    <option value="R">${rName}</option>
                `;
                firstPlayerSelect.value = currentValue;
            }

            const renderQueue = () => {
                operationQueueEl.innerHTML = '';
                if (!operationQueue.value) return;
                operationQueue.value.forEach(op => {
                    const item = document.createElement('div');
                    item.classList.add('operation-item');
                    item.dataset.opId = op.id;
                    item.innerHTML = formatOperation(op);
                    operationQueueEl.appendChild(item);
                });
            };

            // --- Timer Logic ---
            let timerInterval;
            function updateTimerDisplay() {
                if (!matchTimer.value) return;

                // Use server-calculated elapsed time to avoid client-server time sync issues
                let elapsed = matchTimer.value.elapsed || 0;

                // Handle Countdown vs Countup
                let displayTime = elapsed;
                if (gameTimeSettings.value && gameTimeSettings.value.useCountdown) {
                    const limit = (gameTimeSettings.value.limit || 1500) * 1000;
                    displayTime = Math.max(0, limit - elapsed);
                }

                const totalSeconds = Math.floor(displayTime / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;

                if (matchTimer.value.mode === 'standby') {
                    timerDisplay.textContent = "Standby";
                    timerDisplay.style.color = "#ffcc00";
                } else {
                    timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    timerDisplay.style.color = "#fff";
                }

                // Update button state based on mode
                if (matchTimer.value.mode === 'playback') {
                    timerToggleBtn.textContent = 'Playback';
                    timerToggleBtn.disabled = true;
                    timerToggleBtn.classList.remove('btn-primary', 'btn-warning');
                    timerToggleBtn.classList.add('btn-secondary');
                } else {
                    timerToggleBtn.disabled = false;
                    if (matchTimer.value.isRunning) {
                        timerToggleBtn.textContent = 'Stop';
                        timerToggleBtn.classList.remove('btn-primary');
                        timerToggleBtn.classList.add('btn-warning');
                    } else {
                        timerToggleBtn.textContent = 'Start';
                        timerToggleBtn.classList.remove('btn-warning');
                        timerToggleBtn.classList.add('btn-primary');
                    }
                }
            }

            // --- Event Listeners ---
            firstPlayerSelect.addEventListener('change', (e) => {
                firstMove.value = e.target.value;
            });

            discardOpBtn.addEventListener('click', () => nodecg.sendMessage('discardQueue'));

            // Updated Apply Button Logic
            applyOpBtn.addEventListener('click', () => {
                // Use applyOpsPack instead of applyQueue
                nodecg.sendMessage('applyOpsPack');

                // Cooldown UI
                applyOpBtn.disabled = true;
                applyOpBtn.textContent = 'Applying...';
                setTimeout(() => {
                    applyOpBtn.disabled = false;
                    const currentHotkeys = hotkeyManager.hotkeys;
                    applyOpBtn.textContent = `Apply (${currentHotkeys.apply})`;
                }, 2000);
            });

            resetSystemBtn.addEventListener('click', () => {
                if (confirm('Are you sure you want to reset the entire system? This cannot be undone.')) {
                    nodecg.sendMessage('resetSystem');
                    nodecg.sendMessage('timerControl', { action: 'reset' }); // Also reset timer
                }
            });
            restartBtn.addEventListener('click', () => {
                if (confirm('Are you sure you want to restart game? This cannot be undone.')) {
                    nodecg.sendMessage('reStart');
                    nodecg.sendMessage('timerControl', { action: 'reset' }); // Also reset timer
                }
            });
            autoApplyCheckbox.addEventListener('change', (e) => {
                settingsRep.value.autoApply = e.target.checked;
            });

            // Timer Controls
            timerToggleBtn.addEventListener('click', () => {
                const action = matchTimer.value.isRunning ? 'stop' : 'start';
                nodecg.sendMessage('timerControl', { action });
            });

            // Timer Edit Popup Logic
            function updatePopupDisplay() {
                const minutes = Math.floor(tempSeconds / 60);
                const seconds = tempSeconds % 60;
                popupDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            function openTimerPopup() {
                // Initialize with current timer value
                if (matchTimer.value) {
                    // Use server-calculated elapsed time
                    let elapsed = matchTimer.value.elapsed || 0;

                    tempSeconds = Math.floor(elapsed / 1000);
                    updatePopupDisplay();

                    // Show overlay first to calculate dimensions
                    timerPopup.style.display = 'block';
                    timerPopup.style.visibility = 'hidden';

                    // Position popup next to the button
                    const btnRect = timerEditBtn.getBoundingClientRect();
                    const popupRect = popupContent.getBoundingClientRect();

                    // Default: Position to the right of the button
                    let top = btnRect.top;
                    let left = btnRect.right + 10;

                    // Check if it goes off-screen horizontally
                    if (left + popupRect.width > window.innerWidth) {
                        // Try left side
                        left = btnRect.left - popupRect.width - 10;
                    }

                    // Check if it goes off-screen vertically
                    if (top + popupRect.height > window.innerHeight) {
                        top = window.innerHeight - popupRect.height - 10;
                    }
                    if (top < 0) top = 10; // Safety check

                    popupContent.style.top = `${top}px`;
                    popupContent.style.left = `${left}px`;

                    timerPopup.style.visibility = 'visible';
                }
            }

            function closeTimerPopup(save) {
                if (save) {
                    nodecg.sendMessage('timerControl', { action: 'edit', seconds: tempSeconds });
                }
                timerPopup.style.display = 'none';
            }

            timerEditBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent immediate closing
                openTimerPopup();
            });

            popupAdjustBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const adjust = parseInt(btn.dataset.adjust, 10);
                    tempSeconds += adjust;
                    if (tempSeconds < 0) tempSeconds = 0;
                    updatePopupDisplay();
                });
            });

            popupCancelBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                closeTimerPopup(false);
            });

            // Click outside to save and close
            timerPopup.addEventListener('click', (e) => {
                if (e.target === timerPopup) {
                    closeTimerPopup(true);
                }
            });

            // Prevent clicks inside content from closing
            popupContent.addEventListener('click', (e) => {
                e.stopPropagation();
            });


            // --- Replicant Listeners ---
            const hotkeyManager = new HotkeyManager(nodecg, settingsRep);

            operationQueue.on('change', renderQueue);

            firstMove.on('change', (newValue) => {
                firstPlayerSelect.value = newValue;
            });

            settingsRep.on('change', (newValue) => {
                const autoApply = !!newValue.autoApply;
                autoApplyCheckbox.checked = autoApply;

                const queueManualControls = document.getElementById('queue-manual-controls');
                autoApplyWarning.style.display = autoApply ? 'block' : 'none';
                queueManualControls.style.display = autoApply ? 'none' : 'block';

                // Update button labels with hotkeys
                const currentHotkeys = hotkeyManager.hotkeys;
                discardOpBtn.textContent = `Discard (${currentHotkeys.discard})`;
                applyOpBtn.textContent = `Apply (${currentHotkeys.apply})`;
            });

            playerL_name.on('change', (newName) => {
                updateFirstPlayerDropdown();
            });

            playerR_name.on('change', (newName) => {
                updateFirstPlayerDropdown();
            });

            matchTimer.on('change', (newValue) => {
                updateTimerDisplay();
                // Start/Stop interval based on running state
                if (newValue.isRunning) {
                    if (!timerInterval) {
                        timerInterval = setInterval(updateTimerDisplay, 100);
                    }
                } else {
                    if (timerInterval) {
                        clearInterval(timerInterval);
                        timerInterval = null;
                    }
                }
            });

            gameTimeSettings.on('change', updateTimerDisplay);

            // Initial setup
            renderQueue();

            // --- Hotkey Logic ---
            hotkeyManager.on('discard', () => discardOpBtn.click());
            hotkeyManager.on('apply', () => applyOpBtn.click());

            // Listen for the trigger from master_panel
            nodecg.listenFor('triggerApplyButton', () => {
                applyOpBtn.click();
            });

            hotkeyManager.on('hotkeysChanged', (newHotkeys) => {
                discardOpBtn.textContent = `Discard (${newHotkeys.discard})`;
                applyOpBtn.textContent = `Apply (${newHotkeys.apply})`;
            });

            // Initial label update
            const initialHotkeys = hotkeyManager.hotkeys;
            discardOpBtn.textContent = `Discard (${initialHotkeys.discard})`;
            applyOpBtn.textContent = `Apply (${initialHotkeys.apply})`;
        });
    </script>
</body>

</html>