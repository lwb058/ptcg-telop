<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Master Control Panel</title>
    <link rel="stylesheet" href="css/dashboard.css">
</head>

<body>
    <div class="horizontal-panels">
        <div class="panel-section info-zone">
            <h3>Info Module</h3>
            <div class="flex-container" style="align-items: flex-start;">
                <div>
                    <p>Turn: <span id="turn-count">1</span></p>
                    <p>Total Pokemons: <span id="total-pokemons">0</span></p>
                    <p>Battle Energy: <span id="battle-energy-l">L: 0</span> | <span id="battle-energy-r">R: 0</span>
                    </p>
                </div>
            </div>
            <hr style="border: none; border-top: 1px solid #eee; margin: 10px 0;">
            <div class="flex-container" style="justify-content: center; align-items: center;">
                <label id="turn-l-label"><input type="radio" name="turn" id="turn-l" value="L"> Left Player</label>
                <button id="end-turn-btn" class="btn btn-metal" style="margin: 0 20px;">End Turn</button>
                <label id="turn-r-label"><input type="radio" name="turn" id="turn-r" value="R"> Right Player</label>
            </div>
        </div>

        <div class="panel-section">
            <h3>
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    Develop Module
                    <div class="form-group" style="margin-bottom: 0;">
                        <input type="checkbox" id="show-opponent-field-checkbox" style="transform: scale(1.2);">
                        <label for="show-opponent-field-checkbox" style="margin-left: 5px;">Show Opponent</label>
                    </div>
                </div>
            </h3>
            <div id="pokemon-source-grid" class="pokemon-source-grid" style="margin-bottom: 10px;">
                <!-- Pokémon cards from the deck will be rendered here by JavaScript -->
            </div>
            <div id="field-wrapper">
                <div id="field-container-L" style="display: none;"></div>
                <div id="field-container-R" style="display: none;"></div>
            </div>
            <hr style="border: none; border-top: 1px solid #eee; margin: 10px 0;">
            <div id="energy-tool-buttons" class="energy-tool-grid">
                <button class="energy-btn"><img src="/assets/ptcg-telop/icons/草.png" title="草" class="energy-icon"
                        data-energy-type="草" draggable="true"></button>
                <button class="energy-btn"><img src="/assets/ptcg-telop/icons/炎.png" title="炎" class="energy-icon"
                        data-energy-type="炎" draggable="true"></button>
                <button class="energy-btn"><img src="/assets/ptcg-telop/icons/水.png" title="水" class="energy-icon"
                        data-energy-type="水" draggable="true"></button>
                <button class="energy-btn"><img src="/assets/ptcg-telop/icons/雷.png" title="雷" class="energy-icon"
                        data-energy-type="雷" draggable="true"></button>
                <button class="energy-btn"><img src="/assets/ptcg-telop/icons/超.png" title="超" class="energy-icon"
                        data-energy-type="超" draggable="true"></button>
                <button class="energy-btn"><img src="/assets/ptcg-telop/icons/闘.png" title="闘" class="energy-icon"
                        data-energy-type="闘" draggable="true"></button>
                <button class="energy-btn"><img src="/assets/ptcg-telop/icons/悪.png" title="悪" class="energy-icon"
                        data-energy-type="悪" draggable="true"></button>
                <button class="energy-btn"><img src="/assets/ptcg-telop/icons/鋼.png" title="鋼" class="energy-icon"
                        data-energy-type="鋼" draggable="true"></button>
                <button class="energy-btn"><img src="/assets/ptcg-telop/icons/妖.png" title="妖" class="energy-icon"
                        data-energy-type="妖" draggable="true"></button>
                <button class="energy-btn"><img src="/assets/ptcg-telop/icons/無.png" title="無" class="energy-icon"
                        data-energy-type="無" draggable="true"></button>
                <button class="energy-btn"><img src="/assets/ptcg-telop/icons/全.png" title="全" class="energy-icon"
                        data-energy-type="全" draggable="true"></button>
                <!-- Special Enrgy & Tool cards will be rendered here by JavaScript -->
            </div>
            <div id="pokemon-action-drop-zones" class="pokemon-action-drop-zones">
                <div id="pokemon-remove-drop-zone" class="pokemon-action-drop-zone remove-zone">
                    Drop here to Remove
                </div>
                <div id="pokemon-ko-drop-zone" class="pokemon-action-drop-zone ko-zone">
                    Drop here to K.O.
                </div>
            </div>
        </div>

        <div class="panel-section">
            <h3>
                <div style="display: flex; justify-content: space-between; align-items: center; ">
                    Field Module
                    <button id="toggle-field-height-btn" class="btn" style="padding: 2px 8px; font-size: 12px;">
                        Collapse Field</button>
                </div>
            </h3>
            <div style="justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <div class="form-group" style="align-items: center; margin-bottom: 0;">
                    <div style="display:flex; flex-direction: column;">
                        <label for="stadium-list" style="display:flex; justify-content: end;">Stadium:</label>
                        <div style="display:flex; flex-direction: row;">
                            <input type="checkbox" id="stadium-used-checkbox" style="transform: scale(1.5);">
                            <label for="stadium-used-checkbox" style="margin-left: 5px; font-size: 18px;">Used</label>
                        </div>
                    </div>
                    <div id="stadium-list" class="stadium-list">
                        <!-- Stadium will be rendered here by JavaScript -->
                    </div>
                </div>
            </div>
            <div class="form-group" style="flex-direction: column; align-items: stretch; margin-bottom: 10px;">
                <div id="damage-transfer-control"
                    style="padding:5px; display: flex; align-items: center; justify-content: center; gap: 10px; border-radius: 4px 4px 0px 0px; background: lightgrey">
                    <label for="damage-transfer-amount" data-i18n="DC-Transfer">Damage Transfer:</label>
                    <input type="number" id="damage-transfer-amount" class="compact-input" value="30" min="10" step="10"
                        style="width: 60px;">
                    <span style="border-left: 1px solid #303157; margin-left: 5px; padding-left: 15px;">Damage:</span>
                    <div id="damage-pool" style="display: flex; gap: 5px;">
                        <div class="damage-counter pool-item" draggable="true" data-damage-amount="10">10</div>
                        <div class="damage-counter pool-item" draggable="true" data-damage-amount="20">20</div>
                        <div class="damage-counter pool-item" draggable="true" data-damage-amount="30">30</div>
                        <div class="damage-counter pool-item" draggable="true" data-damage-amount="50">50</div>
                        <div class="damage-counter pool-item" draggable="true" data-damage-amount="130">130</div>
                    </div>
                </div>
                <div id="battle-field" class="battle-field-container">
                    <!-- Battle field will be rendered here by JavaScript -->
                </div>
                <div id="batch-damage-drop-zone" data-i18n="batch_damage_drop_zone_text">
                </div>
            </div>
            <div id="attack-zone-flex-container" class="flex-container">
                <div class="form-group" style="flex-grow: 3;">
                    <label for="attacker" data-i18n="attacker">Attacker</label>
                    <select id="attacker" class="truncate-select"></select>
                </div>
                <div class="form-group" style="flex-grow: 3;">
                    <label for="attack-select" style="flex: none;" data-i18n="waza">Move</label>
                    <select id="attack-select" class="truncate-select"></select>
                </div>
                <div class="form-group" style="flex-grow: 2; margin-bottom: 0;">
                    <label for="damage" style="min-width: 60px; margin-right: 5px;" data-i18n="damage">Damage</label>
                    <input type="number" id="damage" class="compact-input" value="0" min="0" step="10">
                </div>
            </div>
            <div class="flex-container" style="align-items: center; gap: 15px;">
                <button id="aim-btn" class="btn btn-info" style="flex-grow: 1; height: fit-content;">Aim</button>
                <div class="form-group"
                    style="flex-grow: 1; margin-bottom: 0; justify-content: center; align-items: center;">
                    <label for="weakness-check" style="margin-right: 5px;" data-i18n="weakness">Weakness</label>
                    <input type="checkbox" id="weakness-check" style="transform: scale(1.2);">
                </div>
                <div class="form-group"
                    style="flex-grow: 1; margin-bottom: 0; justify-content: center; align-items: center;">
                    <label for="resistance-check" style="margin-right: 5px;" data-i18n="resistance">Resistance</label>
                    <input type="checkbox" id="resistance-check" style="transform: scale(1.2);">
                </div>
                <button id="attack-btn" class="btn btn-lightning"
                    style="flex-grow: 1; height: fit-content;">Attack</button>
                <button id="ko-0hp-btn" class="btn btn-danger" style="flex-grow: 1; height: fit-content;">K.O</button>
            </div>
        </div>

        <div class="panel-section">
            <h3>
                <div style="display: flex; justify-content: space-between; align-items: center; ">
                    Shortcut Module
                </div>
            </h3>
            <div class="select-zone-grid" style="margin-bottom: 10px;">
                <button id="select-clear-btn" class="btn btn-black" data-i18n="clear">Clear</button>
                <button id="select-reverse-btn" class="btn btn-lightning" data-i18n="reverse">Reverse</button>
                <button id="select-basic-btn" class="btn btn-grass" data-i18n="select_basic">Basic</button>
                <button id="select-stage2-btn" class="btn btn-grass" data-i18n="select_stage2">Stage 2</button>
                <button id="select-with-energy-btn" class="btn select-btn" data-i18n="select_with_energy">エネ付き</button>
                <button id="select-with-ability-btn" class="btn select-btn"
                    data-i18n="select_with_ability">特性あり</button>
                <button id="select-with-rule-btn" class="btn select-btn" data-i18n="select_with_rule">ルール持ち</button>
                <button id="select-opponent-all-btn" class="btn select-btn"
                    data-i18n="select_opponent_all">相手全体</button>
            </div>
            <hr style="border: none; border-top: 1px solid #eee; margin: 10px 0;">
            <div id="extrahp-shortcuts">
                <h4
                    style="text-align:center; margin-top: 10px; margin-bottom: 5px; font-size: 12px; font-weight: bold; color: #555;">
                    ↓↓↓ ExtraHP Adjust ↓↓↓</h4>
                <div class="grid-container"
                    style="grid-template-columns: repeat(2, 1fr); gap: 5px; margin-bottom: 10px;">
                </div>
                <div class="grid-container" style="grid-template-columns: repeat(5, 1fr); gap: 5px;">
                    <button class="btn btn-grass" data-extrahp-adj="+30">+30 MaxHP</button>
                    <button class="btn btn-grass" data-extrahp-adj="+50">+50 MaxHP</button>
                    <button class="btn btn-grass" data-extrahp-adj="+100">+100 MaxHP</button>
                    <button class="btn btn-fire" data-extrahp-adj="-30">-30 MaxHP</button>
                    <button class="btn btn-black" data-extrahp-set="0">No ExtraHP</button>
                </div>
            </div>
        </div>
    </div>
    <script src="js/dashboard.js"></script>
    <script>
        // --- Global Replicant Declarations ---
        var playerL_name, playerR_name, cardDatabase, selections, draft_currentTurn,
            deckL, deckR, draft_stadium, settingsRep, assetPaths, i18nStrings,
            language, cardToShowL, cardToShowR, operationQueue, turnCount, slots = [];

        NodeCG.waitForReplicants(
            nodecg.Replicant('playerL_name'),
            nodecg.Replicant('playerR_name'),
            nodecg.Replicant('cardDatabase'),
            nodecg.Replicant('selections'),
            nodecg.Replicant('deckL'),
            nodecg.Replicant('deckR'),
            nodecg.Replicant('draft_stadium'),
            nodecg.Replicant('ptcg-settings'), // Listen for settings
            nodecg.Replicant('assetPaths'),
            nodecg.Replicant('i18nStrings'),
            nodecg.Replicant('language'),
            nodecg.Replicant('cardToShowL'),
            nodecg.Replicant('cardToShowR'),
            nodecg.Replicant('operationQueue'),
            nodecg.Replicant('turnCount'),
            ...Array(18).fill(0).map((_, i) => { // Changed from 12 to 18
                const side = i < 9 ? 'L' : 'R';
                const index = i % 9;
                return nodecg.Replicant(`draft_slot${side}${index}`);
            })
        ).then(() => {
            let hotkeys = {
                discard: 'Escape',
                apply: 'Shift+S',
                clearSelection: 'Delete',
                clearCard: 'Space'
            };

            // --- Replicant Assignments ---
            playerL_name = nodecg.Replicant('playerL_name');
            playerR_name = nodecg.Replicant('playerR_name');
            cardDatabase = nodecg.Replicant('cardDatabase');
            selections = nodecg.Replicant('selections');
            draft_currentTurn = nodecg.Replicant('draft_currentTurn');
            deckL = nodecg.Replicant('deckL');
            deckR = nodecg.Replicant('deckR');
            draft_stadium = nodecg.Replicant('draft_stadium');
            settingsRep = nodecg.Replicant('ptcg-settings');
            assetPaths = nodecg.Replicant('assetPaths');
            i18nStrings = nodecg.Replicant('i18nStrings');
            language = nodecg.Replicant('language');
            cardToShowL = nodecg.Replicant('cardToShowL');
            cardToShowR = nodecg.Replicant('cardToShowR');
            operationQueue = nodecg.Replicant('operationQueue');
            turnCount = nodecg.Replicant('turnCount');
            for (let i = 0; i < 9; i++) { // Changed from 6 to 9
                slots.push(nodecg.Replicant(`draft_slotL${i}`));
                slots.push(nodecg.Replicant(`draft_slotR${i}`));
            }

            // --- DOM Element Setup ---
            const totalPokemonsEl = document.getElementById('total-pokemons');
            const battleEnergyLEl = document.getElementById('battle-energy-l');
            const battleEnergyREl = document.getElementById('battle-energy-r');
            const turnCountEl = document.getElementById('turn-count');
            const showOpponentCheckbox = document.getElementById('show-opponent-field-checkbox');
            const fieldWrapper = document.getElementById('field-wrapper');
            const fieldContainerL = document.getElementById('field-container-L');
            const fieldContainerR = document.getElementById('field-container-R');
            let isTabPressed = false;
            const pokemonSourceContainer = document.getElementById('pokemon-source-grid');
            const btnSelectClear = document.getElementById('select-clear-btn');
            const btnSelectReverse = document.getElementById('select-reverse-btn');
            const btnSelectWithEnergy = document.getElementById('select-with-energy-btn');
            const btnSelectWithAbility = document.getElementById('select-with-ability-btn');
            const btnSelectWithRule = document.getElementById('select-with-rule-btn');
            const btnSelectOpponentAll = document.getElementById('select-opponent-all-btn');
            const btnKo0hp = document.getElementById('ko-0hp-btn');
            const damageShortcutsContainer = document.getElementById('damage-shortcuts');
            const selectBasicBtn = document.getElementById('select-basic-btn');
            const selectStage2Btn = document.getElementById('select-stage2-btn');
            const extrahpShortcutsContainer = document.getElementById('extrahp-shortcuts');
            const energyToolsContainer = document.getElementById('energy-tool-buttons');
            const battleField = document.getElementById('battle-field');
            const toggleFieldHeightBtn = document.getElementById('toggle-field-height-btn');
            const attackerSelect = document.getElementById('attacker');
            const attackSelect = document.getElementById('attack-select');
            const damageInput = document.getElementById('damage');
            const weaknessCheck = document.getElementById('weakness-check');
            const attackBtn = document.getElementById('attack-btn');
            const aimBtn = document.getElementById('aim-btn');
            const stadiumList = document.getElementById('stadium-list');
            const stadiumUsedCheckbox = document.getElementById('stadium-used-checkbox');
            const damagePool = document.getElementById('damage-pool');
            const batchDamageDropZone = document.getElementById('batch-damage-drop-zone');
            const pokemonActionDropZones = document.getElementById('pokemon-action-drop-zones');
            const pokemonRemoveDropZone = document.getElementById('pokemon-remove-drop-zone');
            const pokemonKoDropZone = document.getElementById('pokemon-ko-drop-zone');

            const turnLRadio = document.getElementById('turn-l');
            const turnRRadio = document.getElementById('turn-r');
            const endTurnBtn = document.getElementById('end-turn-btn');

            // --- Global Drag Handlers for Batch Damage Zone ---
            document.body.addEventListener('dragstart', (e) => {
                if (e.target.classList.contains('pool-item')) {
                    batchDamageDropZone.classList.add('show');
                }
                // Show Pokemon action drop zones when dragging from pokemon-drop-target
                const pokemonCard = e.target.closest('.pokemon-drop-target');
                if (pokemonCard && !pokemonCard.classList.contains('empty-slot') && (e.target === pokemonCard || e.target.tagName === 'IMG')) {
                    pokemonActionDropZones.classList.add('show');
                }
            });
            document.body.addEventListener('dragend', () => {
                batchDamageDropZone.classList.remove('show');
                pokemonActionDropZones.classList.remove('show');
                document.body.classList.remove('dragging-energy');
            });


            // --- Batch Damage Drop Zone Logic ---
            batchDamageDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.currentTarget.classList.add('over');
            });
            batchDamageDropZone.addEventListener('dragleave', (e) => {
                e.currentTarget.classList.remove('over');
            });
            batchDamageDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.currentTarget.classList.remove('over');

                const isDamageAdd = e.dataTransfer.types.includes('application/ptcg-damage-add');
                if (!isDamageAdd) return;

                const amountToAdd = parseInt(e.dataTransfer.getData('text/plain'), 10);
                const currentSelections = selections.value || [];

                if (isNaN(amountToAdd) || currentSelections.length === 0) {
                    return;
                }

                currentSelections.forEach(slotId => {
                    const slotReplicant = slots.find(s => s.name === `draft_${slotId}`);
                    if (slotReplicant && slotReplicant.value && slotReplicant.value.cardId) {
                        const currentDamage = slotReplicant.value.damage || 0;
                        const newDamage = currentDamage + amountToAdd;
                        queueOrUpdateOperation('SET_DAMAGE', { target: slotId, value: newDamage });
                    }
                });
            });

            // --- Pokemon Action Drop Zones Logic ---
            // Remove Zone
            pokemonRemoveDropZone.addEventListener('dragover', (e) => {
                const isPokemonSwap = e.dataTransfer.types.includes('application/ptcg-pokemon-swap');
                if (isPokemonSwap) {
                    e.preventDefault();
                    e.currentTarget.classList.add('over');
                }
            });
            pokemonRemoveDropZone.addEventListener('dragleave', (e) => {
                e.currentTarget.classList.remove('over');
            });
            pokemonRemoveDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.currentTarget.classList.remove('over');

                const isPokemonSwap = e.dataTransfer.types.includes('application/ptcg-pokemon-swap');
                if (isPokemonSwap) {
                    const sourceSlotId = e.dataTransfer.getData('text/plain');
                    if (sourceSlotId) {
                        // Use REMOVE_POKEMON operation to match the Remove button behavior
                        queueOperation('REMOVE_POKEMON', {
                            target: sourceSlotId,
                            cardName: getCardName(sourceSlotId) // Enrich payload
                        });
                    }
                }
            });

            // K.O. Zone
            pokemonKoDropZone.addEventListener('dragover', (e) => {
                const isPokemonSwap = e.dataTransfer.types.includes('application/ptcg-pokemon-swap');
                if (isPokemonSwap) {
                    e.preventDefault();
                    e.currentTarget.classList.add('over');
                }
            });
            pokemonKoDropZone.addEventListener('dragleave', (e) => {
                e.currentTarget.classList.remove('over');
            });
            pokemonKoDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.currentTarget.classList.remove('over');

                const isPokemonSwap = e.dataTransfer.types.includes('application/ptcg-pokemon-swap');
                if (isPokemonSwap) {
                    const sourceSlotId = e.dataTransfer.getData('text/plain');
                    if (sourceSlotId) {
                        // K.O. the Pokemon
                        queueOperation('KO_POKEMON', {
                            target: sourceSlotId,
                            cardName: getCardName(sourceSlotId) // Enrich payload
                        });
                    }
                }
            });

            damagePool.addEventListener('dragstart', (e) => {
                if (e.target.classList.contains('pool-item')) {
                    e.dataTransfer.setData('application/ptcg-damage-add', 'true');
                    e.dataTransfer.setData('text/plain', e.target.dataset.damageAmount);
                    e.dataTransfer.effectAllowed = 'copy';
                }
            });

            function updateUIStrings() {
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.dataset.i18n;
                    el.textContent = getI18nText(key);
                });
            }

            /**
             * Renders a specific player's field into the given container.
             */
            function renderField(side, container) {
                const db = cardDatabase.value;
                container.innerHTML = '<h3>↓↓↓ Drop Pokémon & Tools & Energy Here ↓↓↓</h3>';

                if (!side || !db) {
                    container.innerHTML += '<p style="color: #888; text-align: center;">No player to display.</p>';
                    return;
                }

                const playerPrefix = `slot${side}`;

                // --- Pre-calculate max tool counts for alignment ---
                const getSlotValue = (index) => slots.find(s => s.name === `draft_${playerPrefix}${index}`)?.value;
                const getToolCount = (slotValue) => (slotValue && slotValue.cardId && slotValue.attachedToolIds) ? slotValue.attachedToolIds.length : 0;

                const mainRowSlots = [0, 1, 2, 3, 4, 5].map(getSlotValue);
                const extraRowSlots = [6, 7, 8].map(getSlotValue);

                const maxToolsInMainRow = Math.max(1, ...mainRowSlots.map(getToolCount));
                const maxToolsInExtraRow = Math.max(1, ...extraRowSlots.map(getToolCount));

                // --- Render Rows ---
                const mainRowContainer = document.createElement('div');
                mainRowContainer.className = 'pokemon-field-row';

                mainRowSlots.forEach((slotValue, i) => {
                    if (slotValue && slotValue.cardId) {
                        mainRowContainer.appendChild(createPokemonCardElement(slotValue, `${playerPrefix}${i}`, maxToolsInMainRow));
                    } else {
                        mainRowContainer.appendChild(createEmptySlotElement(`${playerPrefix}${i}`));
                    }
                });
                container.appendChild(mainRowContainer);

                const extraRowContainer = document.createElement('div');
                extraRowContainer.className = 'pokemon-field-row';
                let hasExtraBenchPokemon = false;

                extraRowSlots.forEach((slotValue, i) => {
                    const index = i + 6;
                    if (slotValue && slotValue.cardId) {
                        extraRowContainer.appendChild(createPokemonCardElement(slotValue, `${playerPrefix}${index}`, maxToolsInExtraRow));
                        hasExtraBenchPokemon = true;
                    } else {
                        const placeholder = document.createElement('div');
                        extraRowContainer.appendChild(placeholder);
                    }
                });

                if (hasExtraBenchPokemon) {
                    container.appendChild(extraRowContainer);
                }
            }

            /**
             * Renders both players' fields and updates visibility.
             */
            function renderCurrentPlayerField() {
                renderField('L', fieldContainerL);
                renderField('R', fieldContainerR);
                updateDevelopModuleState();
            }

            /**
             * Determines the side to display based on turn, checkbox, and hotkey.
             */
            function getEffectiveDisplaySide() {
                const baseTurn = draft_currentTurn.value;
                const isOpponentView = showOpponentCheckbox.checked;

                // Determine the "intended" view based on turn and checkbox
                let intendedSide = baseTurn;
                if (isOpponentView && baseTurn) {
                    intendedSide = baseTurn === 'L' ? 'R' : 'L';
                }

                // Apply hotkey toggle
                let finalSide = intendedSide;
                if (isTabPressed && intendedSide) {
                    finalSide = intendedSide === 'L' ? 'R' : 'L';
                }
                return finalSide;
            }

            function updateDevelopModuleState() {
                const finalSide = getEffectiveDisplaySide();

                // 1. Update Field Visibility
                if (finalSide === 'L') {
                    fieldContainerL.style.display = 'block';
                    fieldContainerR.style.display = 'none';
                } else if (finalSide === 'R') {
                    fieldContainerL.style.display = 'none';
                    fieldContainerR.style.display = 'block';
                } else {
                    fieldContainerL.style.display = 'none';
                    fieldContainerR.style.display = 'none';
                }

                // 2. Update Pokemon Source Grid
                updatePokemonSourceGrid();

                // 3. Update Energy and Tool Buttons
                updateEnergyAndToolButtons();
            }

            // --- Hotkey Listeners ---
            // Uses global checkHotkey from dashboard.js

            /**
             * Creates a DOM element for a Pokémon card.
             * @param {object} slotValue - The value of the slot replicant.
             * @param {string} slotId - The ID of the slot (e.g., 'slotL0').
             * @param {number} maxToolsInRow - The maximum number of tools in this Pokémon's row.
             * @returns {HTMLElement} The created element.
             */
            function createPokemonCardElement(slotValue, slotId, maxToolsInRow) {
                const cardData = cardDatabase.value[slotValue.cardId];
                const cardEl = document.createElement('div');
                cardEl.className = 'pokemon-drop-target';
                if (slotId.endsWith('0')) {
                    cardEl.classList.add('battle-zone-pokemon');
                }
                cardEl.dataset.slotId = slotId;
                cardEl.draggable = true; // Make the entire card element draggable

                // --- Ability Toggle ---
                const abilityWrapper = document.createElement('div');
                abilityWrapper.className = 'field-ability-wrapper';

                const hasAbility = cardData.pokemon && cardData.pokemon.abilities && cardData.pokemon.abilities.length > 0;

                const abilityBtn = document.createElement('button');
                abilityBtn.className = 'ability-btn';
                abilityBtn.textContent = getI18nText('ability');

                if (hasAbility) {
                    if (slotValue.abilityUsed) {
                        abilityBtn.classList.add('used');
                    }
                    abilityBtn.title = 'Toggle Ability Used';
                    abilityBtn.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent card drag
                        const newStatus = !slotValue.abilityUsed;
                        queueOrUpdateOperation('SET_ABILITY_USED', { target: slotId, status: newStatus });
                    });
                } else {
                    abilityBtn.disabled = true;
                }
                abilityWrapper.appendChild(abilityBtn);
                cardEl.appendChild(abilityWrapper);


                const img = document.createElement('img');
                img.src = getCardImageUrl(slotValue.cardId);
                cardEl.appendChild(img);

                // --- Display attached energies ---
                const energyContainer = document.createElement('div');
                energyContainer.className = 'attached-energy-container';

                const attachedEnergies = slotValue.attachedEnergy || [];
                attachedEnergies.forEach((energy, index) => {
                    let energyEl;
                    if (energy.startsWith('special:')) {
                        const cardId = energy.substring(8); // 'special:'.length
                        const cardData = cardDatabase.value[cardId];
                        energyEl = document.createElement('div');
                        energyEl.className = 'attached-special-energy-icon';
                        energyEl.style.backgroundImage = getCardImageUrl(cardId, true);
                        energyEl.title = cardData ? `Click to remove ${cardData.name}` : 'Click to remove Special Energy';
                    } else {
                        energyEl = document.createElement('img');
                        energyEl.src = `/assets/ptcg-telop/icons/${energy}.png`;
                        energyEl.className = 'attached-energy-icon';
                        energyEl.title = `Click to remove ${energy}`;
                    }

                    energyEl.draggable = true;
                    // Use a generic identifier for both types
                    energyEl.dataset.energyIdentifier = energy;
                    energyEl.dataset.sourceSlot = slotId;
                    energyEl.dataset.energyIndex = index;

                    energyEl.addEventListener('click', () => {
                        const currentEnergies = [...(slotValue.attachedEnergy || [])];
                        currentEnergies.splice(index, 1);
                        queueOrUpdateOperation('SET_ENERGIES', {
                            target: slotId,
                            energies: currentEnergies,
                            targetName: getCardName(slotId)
                        });
                    });
                    energyContainer.appendChild(energyEl);
                });
                cardEl.appendChild(energyContainer);

                // --- Display attached tool ---
                const toolContainer = document.createElement('div');
                toolContainer.className = 'attached-tool-container';

                const attachedTools = slotValue.attachedToolIds || [];
                const toolLimit = (settingsRep.value && settingsRep.value.toolLimit) || 4;

                // 1. Render existing tools
                attachedTools.forEach(toolId => {
                    const toolData = cardDatabase.value[toolId];
                    if (toolData) {
                        const toolIconDiv = document.createElement('div');
                        toolIconDiv.className = 'attached-tool-icon';
                        toolIconDiv.title = `Click to remove ${toolData.name}`;
                        toolIconDiv.style.backgroundImage = getCardImageUrl(toolId, true);
                        toolIconDiv.dataset.toolId = toolId;
                        toolContainer.appendChild(toolIconDiv);
                    }
                });

                // 2. Add a flexible placeholder if this slot has fewer tools than the max in its row
                if (attachedTools.length < maxToolsInRow) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'tool-placeholder';
                    placeholder.textContent = 'Tool'; // Always add text
                    toolContainer.appendChild(placeholder);
                }

                // 3. Add click listeners for removal
                toolContainer.querySelectorAll('.attached-tool-icon').forEach(icon => {
                    icon.addEventListener('click', () => {
                        const toolIdToRemove = icon.dataset.toolId;
                        const currentTools = slotValue.attachedToolIds || [];
                        const indexToRemove = currentTools.indexOf(toolIdToRemove);
                        if (indexToRemove > -1) {
                            const newTools = [...currentTools];
                            newTools.splice(indexToRemove, 1);
                            queueOrUpdateOperation('SET_TOOLS', {
                                target: slotId,
                                tools: newTools,
                                targetName: getCardName(slotId),
                                toolNames: newTools.map(tid => (cardDatabase.value && cardDatabase.value[tid]) ? cardDatabase.value[tid].name : tid)
                            });
                        }
                    });
                });

                // Add the special drop zone for "manual turn attachment"
                const manualAttachZone = document.createElement('div');
                manualAttachZone.className = 'manual-attach-zone';
                manualAttachZone.textContent = getI18nText('manually_attach');
                manualAttachZone.title = 'Set as Turn Energy';
                toolContainer.appendChild(manualAttachZone); // NEW: Append to toolContainer

                cardEl.appendChild(toolContainer);

                return cardEl;
            }

            function createEmptySlotElement(slotId) {
                const emptyEl = document.createElement('div');
                emptyEl.className = 'pokemon-drop-target empty-slot';
                if (slotId.endsWith('0')) {
                    emptyEl.classList.add('battle-zone-pokemon');
                }
                emptyEl.dataset.slotId = slotId;
                emptyEl.textContent = slotId.endsWith('0') ? 'Battle' : 'Bench';
                return emptyEl;
            }


            // --- Helper Functions ---
            const getOccupiedSlots = () => slots.filter(s => s.value && s.value.cardId).map(s => s.name.replace('draft_', ''));
            const getCardName = (slotId) => {
                const db = cardDatabase.value;
                const slot = slots.find(s => s.name === `draft_${slotId}`);
                if (slot && slot.value && slot.value.cardId && db && db[slot.value.cardId]) {
                    return db[slot.value.cardId].name;
                }
                return slotId; // Fallback to slotId if name not found
            };

            // --- UI Update Functions ---
            const updateTotalPokemons = () => {
                totalPokemonsEl.textContent = getOccupiedSlots().length;
            };
            const updateBattleEnergyCounts = () => {
                const slotL0 = slots.find(s => s.name === 'draft_slotL0');
                const slotR0 = slots.find(s => s.name === 'draft_slotR0');

                const energyCountL = (slotL0 && slotL0.value && slotL0.value.attachedEnergy) ? slotL0.value.attachedEnergy.length : 0;
                const energyCountR = (slotR0 && slotR0.value && slotR0.value.attachedEnergy) ? slotR0.value.attachedEnergy.length : 0;

                if (battleEnergyLEl) {
                    battleEnergyLEl.textContent = `L: ${energyCountL}`;
                }
                if (battleEnergyREl) {
                    battleEnergyREl.textContent = `R: ${energyCountR}`;
                }
            };
            const updateTurnCount = () => {
                if (turnCountEl && turnCount.value) {
                    turnCountEl.textContent = turnCount.value;
                }
            }

            // --- Event Listeners for UI Updates ---
            turnCount.on('change', () => {
                updateTurnCount();
            });
            showOpponentCheckbox.addEventListener('change', () => {
                updateDevelopModuleState();
            });
            playerL_name.on('change', (newName) => {
                const radio = document.getElementById('turn-l');
                if (radio && radio.nextSibling.nodeType === Node.TEXT_NODE) {
                    radio.nextSibling.textContent = ` ${newName || 'Left Player'}`;
                }
            });

            playerR_name.on('change', (newName) => {
                const radio = document.getElementById('turn-r');
                if (radio && radio.nextSibling.nodeType === Node.TEXT_NODE) {
                    radio.nextSibling.textContent = ` ${newName || 'Right Player'}`;
                }
            });

            const handleTurnChange = (e) => {
                const newTurn = e.target.value;
                if (newTurn && newTurn !== draft_currentTurn.value) {
                    const pName = newTurn === 'L' ? (playerL_name.value || 'Left Player') : (playerR_name.value || 'Right Player');
                    queueOrUpdateOperation('SET_TURN', {
                        side: newTurn,
                        playerName: pName // Enrich
                    });
                }
            };

            turnLRadio.addEventListener('change', handleTurnChange);
            turnRRadio.addEventListener('change', handleTurnChange);

            endTurnBtn.addEventListener('click', () => {
                const currentTurn = draft_currentTurn.value;
                const nextTurn = currentTurn === 'L' ? 'R' : 'L';
                const pName = nextTurn === 'L' ? (playerL_name.value || 'Left Player') : (playerR_name.value || 'Right Player');
                queueOrUpdateOperation('SET_TURN', {
                    side: nextTurn,
                    playerName: pName // Enrich
                });
            });

            // --- Selection Button Logic ---
            btnSelectClear.addEventListener('click', () => {
                selections.value = [];
            });
            btnSelectReverse.addEventListener('click', () => {
                const allSlots = getOccupiedSlots();
                const current = selections.value || [];
                selections.value = allSlots.filter(id => !current.includes(id));
            });
            btnSelectWithEnergy.addEventListener('click', () => {
                const selected = [];
                slots.forEach(slot => {
                    if (slot.value && slot.value.cardId && slot.value.attachedEnergy && slot.value.attachedEnergy.length > 0) {
                        selected.push(slot.name.replace('draft_', ''));
                    }
                });
                selections.value = selected;
            });
            btnSelectWithAbility.addEventListener('click', () => {
                const db = cardDatabase.value;
                if (!db) return;
                const selected = [];
                slots.forEach(slot => {
                    const card = slot.value && slot.value.cardId ? db[slot.value.cardId] : null;
                    if (card && card.pokemon && card.pokemon.abilities && card.pokemon.abilities.length > 0) {
                        selected.push(slot.name.replace('draft_', ''));
                    }
                });
                selections.value = selected;
            });
            btnSelectWithRule.addEventListener('click', () => {
                const db = cardDatabase.value;
                if (!db) return;
                const ruleSubtypes = ['ex', 'VSTAR', 'VMAX', 'V-UNION', 'V', 'GX', 'EX', 'BREAK'];
                const selected = [];
                slots.forEach(slot => {
                    const card = slot.value && slot.value.cardId ? db[slot.value.cardId] : null;
                    if (card && card.subtype && ruleSubtypes.includes(card.subtype)) {
                        selected.push(slot.name.replace('draft_', ''));
                    }
                });
                selections.value = selected;
            });

            btnSelectOpponentAll.addEventListener('click', () => {
                const currentTurn = draft_currentTurn.value;
                if (!currentTurn) {
                    alert('Current turn is not set.');
                    return;
                }
                const opponentSide = currentTurn === 'L' ? 'R' : 'L';
                const opponentPrefix = `slot${opponentSide}`;

                const opponentSlots = getOccupiedSlots().filter(slotId => slotId.startsWith(opponentPrefix));
                selections.value = opponentSlots;
            });

            btnKo0hp.addEventListener('click', () => {
                slots.forEach(slot => {
                    if (slot.value && slot.value.cardId && slot.value.isKO) {
                        const targetId = slot.name.replace('draft_', '');
                        queueOperation('KO_POKEMON', {
                            target: targetId,
                            cardName: getCardName(targetId) // Enrich payload
                        });
                    }
                });
            });

            // --- Evolution Stage Selection Buttons ---
            const createEvoSelectHandler = (evolvesValue) => {
                return () => {
                    const db = cardDatabase.value;
                    if (!db) return;

                    const selected = [];
                    slots.forEach(slot => {
                        if (slot.value && slot.value.cardId) {
                            const card = db[slot.value.cardId];
                            if (card && card.pokemon && card.pokemon.evolves === evolvesValue) {
                                selected.push(slot.name.replace('draft_', ''));
                            }
                        }
                    });
                    selections.value = selected;
                };
            };

            if (selectBasicBtn) {
                selectBasicBtn.addEventListener('click', createEvoSelectHandler('たね'));
            }

            if (selectStage2Btn) {
                selectStage2Btn.addEventListener('click', createEvoSelectHandler('2 進化'));
            }

            // --- Extra HP Shortcut Module Logic ---
            extrahpShortcutsContainer.addEventListener('click', (e) => {
                const target = e.target.closest('button');
                if (!target) return;

                const currentSelections = selections.value;
                if (!currentSelections || currentSelections.length === 0) {
                    console.log('No Pokémon selected for Extra HP adjustment.');
                    return;
                }

                const adjValue = parseInt(target.dataset.extrahpAdj, 10);
                const setValue = target.dataset.extrahpSet !== undefined ? parseInt(target.dataset.extrahpSet, 10) : NaN;

                currentSelections.forEach(slotId => {
                    const slotReplicant = slots.find(s => s.name === `draft_${slotId}`);
                    if (slotReplicant && slotReplicant.value && slotReplicant.value.cardId) {
                        let newExtraHp;
                        if (!isNaN(setValue)) {
                            // Handle "Set to" logic
                            newExtraHp = setValue;
                        } else if (!isNaN(adjValue)) {
                            // Handle adjustment logic
                            const currentExtraHp = parseInt(slotReplicant.value.extraHp || 0, 10);
                            newExtraHp = currentExtraHp + adjValue;
                        }

                        if (newExtraHp !== undefined) {
                            queueOrUpdateOperation('SET_EXTRA_HP', { target: slotId, value: newExtraHp });
                        }
                    }
                });
            });

            // --- Energy & Tool Module Logic (Drag and Drop) ---
            // 1. DRAG START: Set data when dragging an energy or tool
            energyToolsContainer.addEventListener('dragstart', (e) => {
                const target = e.target;
                // Handle Basic Energy (IMG tag)
                if (target.tagName === 'IMG' && target.dataset.energyType) {
                    document.body.classList.add('dragging-energy'); // Add class
                    e.dataTransfer.setData('application/ptcg-energy-drag', 'true');
                    e.dataTransfer.setData('text/plain', target.dataset.energyType);
                    e.dataTransfer.effectAllowed = 'copy';
                }
                // Handle Special Energy (DIV tag)
                else if (target.dataset.specialEnergyId) {
                    document.body.classList.add('dragging-energy'); // Add class
                    e.dataTransfer.setData('application/ptcg-energy-drag', 'true');
                    e.dataTransfer.setData('text/plain', `special:${target.dataset.specialEnergyId}`);
                    e.dataTransfer.effectAllowed = 'copy';
                }
                // Handle Tool (now a DIV tag)
                else if (target.dataset.toolId) {
                    e.dataTransfer.setData('application/ptcg-tool-drag', 'true');
                    e.dataTransfer.setData('text/plain', target.dataset.toolId);
                    e.dataTransfer.effectAllowed = 'copy';
                }
            });

            pokemonSourceContainer.addEventListener('dragstart', (e) => {
                const target = e.target;
                if (target.tagName === 'IMG' && target.dataset.pokemonId) {
                    e.dataTransfer.setData('application/ptcg-pokemon-place', 'true');
                    e.dataTransfer.setData('text/plain', target.dataset.pokemonId);
                    e.dataTransfer.effectAllowed = 'copy';
                }
            });


            // Listen for drag start on the field itself (for moving attached energies)
            fieldWrapper.addEventListener('dragstart', (e) => {
                const target = e.target;
                if (target.dataset.energyIdentifier) { // Check for the generic identifier
                    const moveData = {
                        type: 'move',
                        sourceSlot: target.dataset.sourceSlot,
                        energyIndex: parseInt(target.dataset.energyIndex, 10),
                        energyIdentifier: target.dataset.energyIdentifier // Pass the full identifier
                    };
                    e.dataTransfer.setData('application/ptcg-energy-drag', 'true');
                    e.dataTransfer.setData('application/json', JSON.stringify(moveData));
                    e.dataTransfer.effectAllowed = 'move';
                }
            });

            // Listen for drag start on the field itself (for moving Pokémon)
            fieldWrapper.addEventListener('dragstart', (e) => {
                const sourceCard = e.target.closest('.pokemon-drop-target');
                // Ensure we are dragging a Pokémon card itself, not an energy/tool on it.
                // The check `e.target === sourceCard` or `e.target.tagName === 'IMG'` ensures this.
                if (sourceCard && !sourceCard.classList.contains('empty-slot') && (e.target === sourceCard || e.target.tagName === 'IMG')) {
                    const sourceSlotId = sourceCard.dataset.slotId;
                    e.dataTransfer.setData('application/ptcg-pokemon-swap', 'true');
                    e.dataTransfer.setData('text/plain', sourceSlotId);
                    e.dataTransfer.effectAllowed = 'move';
                }
            });


            // 2. DRAG OVER: Allow dropping and provide visual feedback
            fieldWrapper.addEventListener('dragover', (e) => {
                const isEnergyDrag = e.dataTransfer.types.includes('application/ptcg-energy-drag');
                const isToolDrag = e.dataTransfer.types.includes('application/ptcg-tool-drag');
                const isPokemonPlace = e.dataTransfer.types.includes('application/ptcg-pokemon-place');
                const isPokemonSwap = e.dataTransfer.types.includes('application/ptcg-pokemon-swap');
                const target = e.target.closest('.pokemon-drop-target');

                if (target) {
                    if ((isEnergyDrag || isToolDrag) && !target.classList.contains('empty-slot')) {
                        e.preventDefault();
                        target.style.boxShadow = '0 0 10px 3px #4a69bd';
                    } else if (isPokemonPlace) {
                        e.preventDefault();
                        target.style.boxShadow = '0 0 10px 3px #3498db';
                    } else if (isPokemonSwap) {
                        e.preventDefault();
                    }
                }
            });

            fieldWrapper.addEventListener('dragleave', (e) => {
                const target = e.target.closest('.pokemon-drop-target');
                if (target) {
                    target.style.boxShadow = ''; // Remove highlight
                }
            });

            // 3. DROP: Handle the attachment
            fieldWrapper.addEventListener('drop', (e) => {
                e.preventDefault();
                const dropTarget = e.target.closest('.pokemon-drop-target');
                if (!dropTarget) return;

                dropTarget.style.boxShadow = ''; // Remove highlight on drop
                const destinationSlotId = dropTarget.dataset.slotId;
                if (!destinationSlotId) return;

                const isEnergyDrag = e.dataTransfer.types.includes('application/ptcg-energy-drag');
                const isToolDrag = e.dataTransfer.types.includes('application/ptcg-tool-drag');
                const isPokemonSwap = e.dataTransfer.types.includes('application/ptcg-pokemon-swap');
                const isPokemonPlace = e.dataTransfer.types.includes('application/ptcg-pokemon-place');

                if (isPokemonPlace) {
                    // --- Handle POKEMON placement (from source grid) ---
                    const draggedCardId = e.dataTransfer.getData('text/plain');
                    if (!draggedCardId) return;

                    const isTargetEmpty = dropTarget.classList.contains('empty-slot');

                    if (isTargetEmpty) {
                        // Drop on an empty slot -> SET_POKEMON
                        const db = cardDatabase.value;
                        const cardName = (db && db[draggedCardId]) ? db[draggedCardId].name : draggedCardId;
                        queueOperation('SET_POKEMON', {
                            target: destinationSlotId,
                            cardId: draggedCardId,
                            cardName: cardName // Enrich payload
                        });
                    } else {
                        // Drop on an existing pokemon -> determine actionType
                        const slotReplicant = slots.find(s => s.name === `draft_${destinationSlotId}`);
                        if (!slotReplicant || !slotReplicant.value || !slotReplicant.value.cardId) return;

                        const sourceCardId = slotReplicant.value.cardId;

                        // Prevent dropping the same card onto itself
                        if (draggedCardId === sourceCardId) return;

                        const db = cardDatabase.value;
                        if (!db) return;

                        const sourceCardData = db[sourceCardId];
                        const draggedCardData = db[draggedCardId];

                        let actionType = 'Replace'; // Default action

                        if (sourceCardData && sourceCardData.pokemon && draggedCardData && draggedCardData.pokemon) {
                            const sourceEvolvesFrom = sourceCardData.pokemon.evolvesFrom || [];
                            const draggedEvolvesFrom = draggedCardData.pokemon.evolvesFrom || [];

                            if (draggedEvolvesFrom.includes(sourceCardData.name)) {
                                actionType = 'Evolve';
                            } else if (sourceEvolvesFrom.includes(draggedCardData.name)) {
                                actionType = 'Devolve';
                            }
                        }

                        const cardName = (db && db[draggedCardId]) ? db[draggedCardId].name : draggedCardId;
                        queueOrUpdateOperation('REPLACE_POKEMON', {
                            target: destinationSlotId,
                            cardId: draggedCardId,
                            actionType: actionType,
                            cardName: cardName, // Name of new card
                            targetName: getCardName(destinationSlotId) // Name of old card
                        });

                        // Reset ability used status after replacing
                        queueOrUpdateOperation('SET_ABILITY_USED', { target: destinationSlotId, status: false });
                    }
                } else if (isToolDrag) {
                    // --- Handle TOOL attachment ---
                    const toolId = e.dataTransfer.getData('text/plain');
                    if (!toolId) return;

                    const slotReplicant = slots.find(s => s.name === `draft_${destinationSlotId}`);
                    if (!slotReplicant || !slotReplicant.value) return;

                    const toolLimit = (settingsRep.value && settingsRep.value.toolLimit) || 4;
                    const currentTools = slotReplicant.value.attachedToolIds || [];
                    if (currentTools.length < toolLimit) {
                        const newTools = [...currentTools, toolId];
                        const db = cardDatabase.value;
                        const toolNames = newTools.map(tid => (db && db[tid]) ? db[tid].name : tid);
                        queueOrUpdateOperation('SET_TOOLS', {
                            target: destinationSlotId,
                            tools: newTools,
                            targetName: getCardName(destinationSlotId),
                            toolNames: toolNames
                        });
                    } else {
                        // Optional: Add a visual warning to the user in the future
                        console.warn(`Tool limit of ${toolLimit} reached for ${destinationSlotId}`);
                    }

                } else if (isEnergyDrag) {
                    // --- Handle ENERGY attachment ---
                    const moveDataJSON = e.dataTransfer.getData('application/json');

                    if (moveDataJSON) {
                        // Handle MOVE operation
                        const moveData = JSON.parse(moveDataJSON);
                        const { sourceSlot, energyIndex, energyIdentifier } = moveData; // Changed from energyType

                        if (sourceSlot === destinationSlotId) return; // Do nothing if dropped on itself

                        // Remove from source
                        const sourceReplicant = slots.find(s => s.name === `draft_${sourceSlot}`);
                        if (sourceReplicant && sourceReplicant.value) {
                            const sourceEnergies = [...(sourceReplicant.value.attachedEnergy || [])];
                            sourceEnergies.splice(energyIndex, 1);
                            // Removing energy is also a SET_ENERGIES op
                            queueOrUpdateOperation('SET_ENERGIES', {
                                target: sourceSlot,
                                energies: sourceEnergies,
                                targetName: getCardName(sourceSlot)
                            });
                        }

                        // Add to destination
                        const destReplicant = slots.find(s => s.name === `draft_${destinationSlotId}`);
                        if (destReplicant && destReplicant.value) {
                            const destEnergies = [...(destReplicant.value.attachedEnergy || []), energyIdentifier]; // Use identifier
                            queueOrUpdateOperation('SET_ENERGIES', {
                                target: destinationSlotId,
                                energies: destEnergies,
                                targetName: getCardName(destinationSlotId)
                            });
                        }

                    } else {
                        // Handle COPY operation (from energy grid)
                        const energyIdentifier = e.dataTransfer.getData('text/plain'); // Changed from energyType
                        if (!energyIdentifier) return;

                        const slotReplicant = slots.find(s => s.name === `draft_${destinationSlotId}`);
                        if (!slotReplicant || !slotReplicant.value || !slotReplicant.value.cardId) {
                            console.warn(`Attempted to drop energy on empty slot ${destinationSlotId}`);
                            return;
                        }

                        const isManualAttach = e.target.classList.contains('manual-attach-zone');
                        const currentEnergies = slotReplicant.value.attachedEnergy || [];
                        const finalEnergies = [...currentEnergies, energyIdentifier]; // Use identifier

                        queueOrUpdateOperation('SET_ENERGIES', {
                            target: destinationSlotId,
                            energies: finalEnergies,
                            targetName: getCardName(destinationSlotId)
                        });

                        if (isManualAttach) {
                            const turn = draft_currentTurn.value;
                            const actionStatusTarget = `action_energy_${turn}`;
                            queueOrUpdateOperation('SET_ACTION_STATUS', { target: actionStatusTarget, status: true });
                        }
                    }
                } else if (isPokemonSwap) {
                    // --- Handle POKEMON swap ---
                    const sourceSlotId = e.dataTransfer.getData('text/plain');
                    if (sourceSlotId && destinationSlotId && sourceSlotId !== destinationSlotId) {
                        // Queue the switch operation
                        // Queue the switch operation
                        queueOperation('SWITCH_POKEMON', {
                            source: sourceSlotId,
                            target: destinationSlotId,
                            sourceName: getCardName(sourceSlotId),
                            targetName: getCardName(destinationSlotId)
                        });

                        // Check for auto-retreat logic
                        const settings = settingsRep.value || {};
                        const isRetreat = sourceSlotId.endsWith('0'); // Dragged from a battle slot

                        if (isRetreat && settings.autoRetreatToggle) {
                            const turn = draft_currentTurn.value;
                            if (turn) {
                                const actionStatusTarget = `action_retreat_${turn}`;
                                queueOrUpdateOperation('SET_ACTION_STATUS', { target: actionStatusTarget, status: true });
                            }
                        }
                    }
                }
            });

            function updatePokemonSourceGrid() {
                const db = cardDatabase.value;
                const deckLVal = deckL.value;
                const deckRVal = deckR.value;
                const displayTurn = getEffectiveDisplaySide();
                pokemonSourceContainer.innerHTML = ''; // Clear previous

                if (!db || !deckLVal || !deckRVal || !displayTurn) {
                    return; // Exit if data is not ready
                }

                const targetDeck = displayTurn === 'L' ? deckLVal.cards : deckRVal.cards;
                if (!targetDeck) return;

                const uniquePokemonIds = [...new Set(targetDeck)].filter(id => {
                    const card = db[id];
                    return card && card.supertype === 'pokemon';
                });

                // Split into basic and evolved
                const basicPokemonIds = uniquePokemonIds.filter(id => db[id]?.pokemon?.evolves === 'たね');
                const evolvedPokemonIds = uniquePokemonIds.filter(id => db[id]?.pokemon?.evolves !== 'たね');

                const createRow = (ids) => {
                    const row = document.createElement('div');
                    row.className = 'pokemon-source-grid';
                    ids.forEach(id => {
                        const card = db[id];
                        const btn = document.createElement('button');
                        btn.className = 'pokemon-btn';

                        const img = document.createElement('img');
                        img.src = getCardImageUrl(id);
                        img.title = card.name;
                        img.className = 'pokemon-icon';
                        img.dataset.pokemonId = id; // New data attribute
                        img.draggable = true;

                        btn.appendChild(img);
                        row.appendChild(btn);
                    });
                    return row;
                };

                if (evolvedPokemonIds.length > 0) {
                    const evolvedRow = createRow(evolvedPokemonIds);
                    pokemonSourceContainer.appendChild(evolvedRow);
                }

                if (basicPokemonIds.length > 0) {
                    const basicRow = createRow(basicPokemonIds);
                    pokemonSourceContainer.appendChild(basicRow);
                }

                // Change main container style from grid to flex column
                pokemonSourceContainer.style.display = 'flex';
                pokemonSourceContainer.style.flexDirection = 'column';
            }

            function updateEnergyAndToolButtons() {
                const settings = settingsRep.value || {};
                const db = cardDatabase.value;
                const deckLVal = deckL.value;
                const deckRVal = deckR.value;
                const displayTurn = getEffectiveDisplaySide();

                // Clear previous dynamic buttons (both special energy and tools)
                energyToolsContainer.querySelectorAll('.dynamic-btn').forEach(btn => btn.remove());

                const energyIcons = energyToolsContainer.querySelectorAll('img[data-energy-type]');

                if (!db) { // Need database to proceed
                    energyIcons.forEach(icon => icon.parentElement.style.display = 'none');
                    return;
                }

                const specialEnergies = new Map();
                const toolCards = new Map();

                if (settings.showDeckEnergyOnly) {
                    // --- DECK-ONLY LOGIC ---
                    if (!deckLVal || !deckRVal || !displayTurn) {
                        // Hide all if data is missing
                        energyIcons.forEach(icon => icon.parentElement.style.display = 'none');
                        return;
                    }

                    const deckEnergies = new Set();
                    const targetDeck = displayTurn === 'L' ? deckLVal.cards : deckRVal.cards;
                    const uniqueCardIds = [...new Set(targetDeck || [])];

                    uniqueCardIds.forEach(id => {
                        const card = db[id];
                        if (!card) return;

                        if (card.supertype === 'energy') {
                            if (card.subtype === 'basic energy' && card.energy) {
                                deckEnergies.add(card.energy);
                            } else if (card.subtype !== 'basic energy') {
                                if (!specialEnergies.has(id)) specialEnergies.set(id, card);
                            }
                        } else if (card.supertype === 'trainer' && card.subtype === 'tool') {
                            if (!toolCards.has(id)) toolCards.set(id, card);
                        }
                    });

                    energyIcons.forEach(icon => {
                        const energyType = icon.dataset.energyType;
                        const parentButton = icon.parentElement;
                        if (parentButton.tagName !== 'BUTTON') return;
                        // Show only if it's in the deck
                        parentButton.style.display = deckEnergies.has(energyType) ? '' : 'none';
                    });

                } else {
                    // --- SHOW-ALL LOGIC ---
                    // 1. Show all basic energy icons
                    energyIcons.forEach(icon => {
                        if (icon.parentElement.tagName === 'BUTTON') {
                            icon.parentElement.style.display = '';
                        }
                    });

                    // 2. Find all special energies and tools in the entire database
                    for (const id in db) {
                        const card = db[id];
                        if (card) {
                            if (card.supertype === 'energy' && card.subtype !== 'basic energy') {
                                if (!specialEnergies.has(id)) specialEnergies.set(id, card);
                            } else if (card.supertype === 'trainer' && card.subtype === 'tool') {
                                if (!toolCards.has(id)) toolCards.set(id, card);
                            }
                        }
                    }
                }

                // --- COMMON LOGIC: Render all found special energies and tools ---
                const createButton = (card, id, typeClass, dataType, dataAttribute) => {
                    const btn = document.createElement('button');
                    // A generic class for clearing, and a specific class for styling
                    btn.className = `energy-btn dynamic-btn ${typeClass}-btn`;

                    const div = document.createElement('div');
                    div.className = `${typeClass}-icon`; // e.g., 'special-energy-icon' or 'tool-card-icon'
                    div.style.backgroundImage = getCardImageUrl(id, true);
                    div.title = card.name;
                    div.draggable = true;
                    div.dataset[dataAttribute] = id;

                    btn.appendChild(div);
                    energyToolsContainer.appendChild(btn);
                };

                specialEnergies.forEach((card, id) => createButton(card, id, 'special-energy', 'specialEnergyId', 'specialEnergyId'));
                toolCards.forEach((card, id) => createButton(card, id, 'tool-card', 'toolId', 'toolId'));
            }




            // --- Targeting View Logic ---
            if (toggleFieldHeightBtn) {
                toggleFieldHeightBtn.addEventListener('click', () => {
                    const currentHeight = battleField.style.height;
                    if (currentHeight === '215px') {
                        battleField.style.height = '430px';
                        toggleFieldHeightBtn.textContent = 'Collapse';
                    } else {
                        battleField.style.height = '215px';
                        toggleFieldHeightBtn.textContent = 'Expand';
                    }
                });
            }

            /**
             * Creates a DOM element for a Pokémon card in the targeting view.
             * @param {string} slotId - The ID of the slot (e.g., 'slotL0').
             * @param {object} slotValue - The value of the slot replicant.
             * @returns {HTMLElement} The created element.
             */
            function createTargetingCardElement(slotId, slotValue) {
                const cardEl = document.createElement('div');
                cardEl.className = 'pokemon-target-card';
                cardEl.dataset.slotId = slotId;
                cardEl.draggable = true;

                if (slotValue && slotValue.isKO) {
                    cardEl.classList.add('is-ko');
                }

                if (slotValue && slotValue.cardId) {
                    const img = document.createElement('img');
                    img.src = getCardImageUrl(slotValue.cardId);
                    cardEl.appendChild(img);

                    const damage = slotValue.damage || 0;
                    if (damage > 0) {
                        const damageCounter = document.createElement('div');
                        damageCounter.className = 'damage-counter on-pokemon';
                        damageCounter.textContent = damage;
                        damageCounter.draggable = true;

                        damageCounter.addEventListener('dragstart', (e) => {
                            e.stopPropagation(); // Prevent card drag when dragging counter
                            e.dataTransfer.setData('application/ptcg-damage-transfer', 'true');
                            e.dataTransfer.setData('text/plain', slotId);
                            e.dataTransfer.effectAllowed = 'move';
                        });

                        cardEl.appendChild(damageCounter);
                    }
                } else {
                    cardEl.classList.add('empty-target-slot');
                }

                // Add click listener to toggle selection
                cardEl.addEventListener('click', () => {
                    const currentSelections = selections.value || [];
                    const index = currentSelections.indexOf(slotId);
                    let newSelections = [...currentSelections];

                    if (index > -1) {
                        newSelections.splice(index, 1);
                    } else {
                        newSelections.push(slotId);
                    }
                    selections.value = newSelections;
                });

                return cardEl;
            }

            /**
             * Renders the entire battlefield in the targeting view, from the current player's perspective.
             */
            function renderTargetingField() {
                if (!battleField) return;
                battleField.innerHTML = ''; // Clear view

                const turn = draft_currentTurn.value;
                if (!turn) return;

                const currentPlayerId = turn;
                const opponentPlayerId = turn === 'L' ? 'R' : 'L';
                const currentSelections = selections.value || [];

                // Helper to create a row container
                const createRow = (className) => {
                    const row = document.createElement('div');
                    row.className = `targeting-row ${className}`;
                    return row;
                };

                // Helper to populate a row with Pokémon cards (including empty slots); for extra bench (6-8), only render if occupied
                const populateRow = (row, side, indices, onlyIfOccupied = false) => {
                    let hasPokemon = false;
                    indices.forEach(i => {
                        const slotId = `slot${side}${i}`;
                        const slot = slots.find(s => s.name === `draft_${slotId}`);
                        const slotValue = slot ? slot.value : null;

                        // Skip empty slots if onlyIfOccupied is true (for extra bench 6-8)
                        if (onlyIfOccupied && (!slotValue || !slotValue.cardId)) {
                            return;
                        }

                        // Create a card element
                        const card = createTargetingCardElement(slotId, slotValue);

                        // Check if this slot has a Pokémon
                        if (slotValue && slotValue.cardId) {
                            hasPokemon = true;
                            if (currentSelections.includes(slotId)) {
                                card.classList.add('is-targeted');
                            }
                        }

                        row.appendChild(card);
                    });
                    return hasPokemon; // Return true if at least one Pokémon was added
                };

                const opponentBenchRow = createRow('bench opponent-row');
                const opponentBattleRow = createRow('battle opponent-row');
                const playerBattleRow = createRow('battle player-row');
                const playerBenchRow = createRow('bench player-row');

                // For bench rows, render slots 1-5 with empty placeholders
                const hasOpponentBench = populateRow(opponentBenchRow, opponentPlayerId, [1, 2, 3, 4, 5]);
                const hasOpponentBattle = populateRow(opponentBattleRow, opponentPlayerId, [0]);
                const hasPlayerBattle = populateRow(playerBattleRow, currentPlayerId, [0]);
                const hasPlayerBench = populateRow(playerBenchRow, currentPlayerId, [1, 2, 3, 4, 5]);

                // Add extra bench slots (6-8) to the SAME row, but only if occupied
                populateRow(opponentBenchRow, opponentPlayerId, [6, 7, 8], true);
                populateRow(playerBenchRow, currentPlayerId, [6, 7, 8], true);

                // Always append rows to show empty slots as placeholders
                // Opponent side
                battleField.appendChild(opponentBenchRow);
                battleField.appendChild(opponentBattleRow);

                // Add separator
                const separator = document.createElement('div');
                separator.className = 'target-view-separator';
                battleField.appendChild(separator);

                // Player side
                battleField.appendChild(playerBattleRow);
                battleField.appendChild(playerBenchRow);
            }

            // --- Logic for dragging and dropping to swap Pokémon in the targeting view --- 
            battleField.addEventListener('dragstart', e => {
                if (e.target.classList.contains('damage-counter')) {
                    return;
                }
                const sourceCard = e.target.closest('.pokemon-target-card');
                if (sourceCard && !sourceCard.classList.contains('empty-target-slot')) {
                    const sourceSlotId = sourceCard.dataset.slotId;
                    e.dataTransfer.setData('application/ptcg-pokemon-swap', 'true');
                    e.dataTransfer.setData('text/plain', sourceSlotId);
                    e.dataTransfer.effectAllowed = 'move';
                }
            });

            battleField.addEventListener('dragover', e => {
                const isDamageTransfer = e.dataTransfer.types.includes('application/ptcg-damage-transfer');
                const isDamageAdd = e.dataTransfer.types.includes('application/ptcg-damage-add');
                const isPokemonSwap = e.dataTransfer.types.includes('application/ptcg-pokemon-swap');
                const targetCard = e.target.closest('.pokemon-target-card');

                if (targetCard) { // Dragging over a Pokémon card
                    if (isDamageTransfer || isDamageAdd || isPokemonSwap) {
                        e.preventDefault();
                        if ((isDamageTransfer || isDamageAdd) && !targetCard.classList.contains('empty-target-slot')) {
                            targetCard.classList.add('over');
                        }
                        if (isPokemonSwap) {
                            targetCard.style.boxShadow = '0 0 10px 3px #3498db';
                        }
                    }
                } else if ((isDamageTransfer || isDamageAdd) && e.currentTarget.contains(e.target)) { // Dragging over an empty area within battleField
                    e.preventDefault();
                    e.currentTarget.classList.add('over'); // Highlight the field itself
                }
            });

            battleField.addEventListener('dragleave', e => {
                const targetCard = e.target.closest('.pokemon-target-card');
                if (targetCard) {
                    targetCard.classList.remove('over');
                    targetCard.style.boxShadow = '';
                } else { // Leaving the battleField itself
                    e.currentTarget.classList.remove('over');
                }
            });

            battleField.addEventListener('drop', e => {
                e.preventDefault();
                const dropTarget = e.target.closest('.pokemon-target-card');

                e.currentTarget.classList.remove('over');
                if (dropTarget) {
                    dropTarget.classList.remove('over');
                    dropTarget.style.boxShadow = '';
                }

                const isDamageTransfer = e.dataTransfer.types.includes('application/ptcg-damage-transfer');
                const isDamageAdd = e.dataTransfer.types.includes('application/ptcg-damage-add');
                const isPokemonSwap = e.dataTransfer.types.includes('application/ptcg-pokemon-swap');

                if (!dropTarget) {
                    if (isDamageTransfer) {
                        const sourceSlotId = e.dataTransfer.getData('text/plain');
                        const sourceReplicant = slots.find(s => s.name === `draft_${sourceSlotId}`);
                        if (sourceReplicant) {
                            const currentDamage = sourceReplicant.value.damage || 0;
                            const transferAmount = parseInt(document.getElementById('damage-transfer-amount').value, 10);
                            const newDamage = Math.max(0, currentDamage - transferAmount);

                            queueOrUpdateOperation('SET_DAMAGE', {
                                target: sourceSlotId,
                                value: newDamage
                            });
                        }
                    }
                    return;
                }

                const destinationSlotId = dropTarget.dataset.slotId;

                if (isDamageTransfer) {
                    const sourceSlotId = e.dataTransfer.getData('text/plain');

                    if (sourceSlotId && destinationSlotId && sourceSlotId !== destinationSlotId && !dropTarget.classList.contains('empty-target-slot')) {
                        const sourceReplicant = slots.find(s => s.name === `draft_${sourceSlotId}`);
                        const destReplicant = slots.find(s => s.name === `draft_${destinationSlotId}`);

                        if (sourceReplicant && destReplicant) {
                            const sourceDamage = sourceReplicant.value.damage || 0;
                            const destDamage = destReplicant.value.damage || 0;
                            const transferAmount = parseInt(document.getElementById('damage-transfer-amount').value, 10);

                            const actualTransfer = Math.min(sourceDamage, transferAmount);

                            if (actualTransfer > 0) {
                                queueOrUpdateOperation('SET_DAMAGE', {
                                    target: sourceSlotId,
                                    value: sourceDamage - actualTransfer
                                });
                                queueOrUpdateOperation('SET_DAMAGE', {
                                    target: destinationSlotId,
                                    value: destDamage + actualTransfer
                                });
                            }
                        }
                    }
                } else if (isDamageAdd) {
                    const amountToAdd = parseInt(e.dataTransfer.getData('text/plain'), 10);

                    if (destinationSlotId && !isNaN(amountToAdd) && !dropTarget.classList.contains('empty-target-slot')) {
                        const destReplicant = slots.find(s => s.name === `draft_${destinationSlotId}`);
                        if (destReplicant) {
                            const destDamage = destReplicant.value.damage || 0;
                            queueOrUpdateOperation('SET_DAMAGE', {
                                target: destinationSlotId,
                                value: destDamage + amountToAdd
                            });
                        }
                    }
                } else if (isPokemonSwap) {
                    const sourceSlotId = e.dataTransfer.getData('text/plain');

                    if (sourceSlotId && destinationSlotId && sourceSlotId !== destinationSlotId) {
                        const sourceSide = sourceSlotId.charAt(4);
                        const destinationSide = destinationSlotId.charAt(4);

                        // Allow swapping with empty slots (removed empty slot check)
                        if (sourceSide === destinationSide) {
                            queueOperation('SWITCH_POKEMON', {
                                source: sourceSlotId,
                                target: destinationSlotId,
                                sourceName: getCardName(sourceSlotId),
                                targetName: getCardName(destinationSlotId)
                            });
                        }
                    }
                }
            });

            const resistanceCheck = document.getElementById('resistance-check');

            /**
             * Recalculates the final damage from scratch and updates the UI.
             * This is the single source of truth for damage calculation.
             */
            function recalculateFinalDamage() {
                const db = cardDatabase.value;
                const attackerSlotId = attackerSelect.value;
                const attackName = attackSelect.value;

                // 1. Determine Base Damage from the selected attack
                let baseDamage = 0;
                if (db && attackerSlotId && attackName) {
                    const attackerSlotReplicant = slots.find(s => s.name === `draft_${attackerSlotId}`);
                    const attackerCardId = attackerSlotReplicant?.value?.cardId;
                    const attachedToolIds = attackerSlotReplicant?.value?.attachedToolIds || [];

                    if (attackerCardId && db[attackerCardId]) {
                        const cardData = db[attackerCardId];
                        let allAttacks = [];
                        if (cardData.pokemon?.attacks) {
                            allAttacks.push(...cardData.pokemon.attacks);
                        }
                        attachedToolIds.forEach(toolId => {
                            if (db[toolId]?.trainer?.attacks) {
                                allAttacks.push(...db[toolId].trainer.attacks);
                            }
                        });

                        const selectedAttack = allAttacks.find(attack => attack.name === attackName);

                        if (selectedAttack) {
                            if (selectedAttack.damage) {
                                const damageString = String(selectedAttack.damage);
                                const match = damageString.match(/\d+/);
                                baseDamage = match ? parseInt(match[0], 10) : 0;
                            } else if (selectedAttack.text) {
                                const regex = /匹に、(?:それぞれ)?(\d+)ダメージ。/;
                                const textMatch = selectedAttack.text.match(regex);
                                if (textMatch && textMatch[1]) {
                                    baseDamage = parseInt(textMatch[1], 10);
                                }
                            }
                        }
                    }
                }

                // 2. Apply Weakness and Resistance
                let finalDamage = baseDamage;
                const settings = settingsRep.value || {};
                if (settings.weaknessDamage) {
                    if (weaknessCheck.checked) {
                        finalDamage *= 2;
                    }
                    if (resistanceCheck.checked) {
                        finalDamage -= 30;
                    }
                }

                // 3. Update the input field with the final, non-negative damage
                damageInput.value = Math.max(0, finalDamage);
            }

            /**
             * Automatically checks for weakness and resistance based on the attacker and the selected battle zone target.
             */
            function updateWeaknessAndResistanceChecks() {
                const settings = settingsRep.value || {};
                if (!settings.weaknessDamage) {
                    weaknessCheck.checked = false;
                    resistanceCheck.checked = false;
                    return;
                }

                const db = cardDatabase.value;
                if (!db) {
                    weaknessCheck.checked = false;
                    resistanceCheck.checked = false;
                    return;
                }

                // Get info for the selected attacker
                const attackerSlotId = attackerSelect.value;
                if (!attackerSlotId) {
                    weaknessCheck.checked = false;
                    resistanceCheck.checked = false;
                    return;
                }
                const attackerSlotReplicant = slots.find(s => s.name === `draft_${attackerSlotId}`);
                const attackerCardId = attackerSlotReplicant?.value?.cardId;
                const attackerCard = attackerCardId ? db[attackerCardId] : null;
                const attackerTypes = attackerCard?.pokemon?.color;
                if (!attackerTypes || attackerTypes.length === 0) {
                    weaknessCheck.checked = false;
                    resistanceCheck.checked = false;
                    return;
                }

                // Get info for the selected battle zone target
                const currentSelections = selections.value || [];
                const targetSlotId = currentSelections.find(id => id.endsWith('0')); // Only care about the Pokémon in the battle slot
                if (!targetSlotId) {
                    weaknessCheck.checked = false;
                    resistanceCheck.checked = false;
                    return;
                }
                const targetSlotReplicant = slots.find(s => s.name === `draft_${targetSlotId}`);
                const targetCardId = targetSlotReplicant?.value?.cardId;
                const targetCard = targetCardId ? db[targetCardId] : null;

                // Check Weakness
                const targetWeaknesses = targetCard?.pokemon?.weaknesses;
                if (!targetWeaknesses || targetWeaknesses.length === 0) {
                    weaknessCheck.checked = false;
                } else {
                    const weaknessTypes = targetWeaknesses.map(w => w.type);
                    weaknessCheck.checked = attackerTypes.some(type => weaknessTypes.includes(type));
                }

                // Check Resistance
                const targetResistances = targetCard?.pokemon?.resistances;
                if (!targetResistances || targetResistances.length === 0) {
                    resistanceCheck.checked = false;
                } else {
                    const resistanceTypes = targetResistances.map(r => r.type);
                    resistanceCheck.checked = attackerTypes.some(type => resistanceTypes.includes(type));
                }

                // After updating checks, always recalculate damage
                recalculateFinalDamage();
            }

            // When the weakness or resistance checkbox is manually clicked, recalculate the damage.
            weaknessCheck.addEventListener('change', recalculateFinalDamage);
            resistanceCheck.addEventListener('change', recalculateFinalDamage);

            /**
             * Finds all attacks for a Pokémon and its entire pre-evolution line by
             * searching within the combined decks. This version correctly handles multiple
             * cards with the same name (e.g., different Ralts cards).
             * @param {string} cardId - The starting card ID from the slot.
             * @param {object} db - The full card database.
             * @param {Array<string>} deckCardIds - An array of all card IDs in both decks.
             * @returns {Array} An array of attack objects.
             */
            function getAllAttacksForPokemon(cardId, db, deckCardIds) {
                const startCardData = db[cardId];
                if (!cardId || !db || !startCardData) {
                    return [];
                }

                let allAttacks = [];
                // 1. Add attacks from the starting Pokémon, tagging them with the source name.
                if (startCardData.pokemon?.attacks) {
                    const attacksWithSource = startCardData.pokemon.attacks.map(attack => ({
                        ...attack,
                        source: startCardData.name
                    }));
                    allAttacks.push(...attacksWithSource);
                }

                // 2. Prepare a queue to process the names of all pre-evolutions.
                const namesToProcess = new Set();
                if (startCardData.pokemon?.evolvesFrom) {
                    startCardData.pokemon.evolvesFrom.forEach(name => namesToProcess.add(name));
                }

                const processedNames = new Set();

                // 3. Iterate through the pre-evolution name queue, finding all matching cards in the deck.
                while (namesToProcess.size > 0) {
                    // Get the next name from the queue
                    const currentName = namesToProcess.values().next().value;
                    namesToProcess.delete(currentName);

                    // If this name has already been processed, skip to prevent infinite loops.
                    if (processedNames.has(currentName)) {
                        continue;
                    }
                    processedNames.add(currentName);

                    // Find all cards in the deck with the same name as the current pre-evolution.
                    const matchingPreEvoIds = deckCardIds.filter(id => db[id] && db[id].name === currentName);

                    matchingPreEvoIds.forEach(preEvoCardId => {
                        const cardData = db[preEvoCardId];
                        if (cardData) {
                            // Add its attacks, tagging them with the source name.
                            if (cardData.pokemon?.attacks) {
                                const attacksWithSource = cardData.pokemon.attacks.map(attack => ({
                                    ...attack,
                                    source: cardData.name
                                }));
                                allAttacks.push(...attacksWithSource);
                            }
                            // Add its pre-evolution names to the queue for the next round of processing.
                            if (cardData.pokemon?.evolvesFrom) {
                                cardData.pokemon.evolvesFrom.forEach(name => {
                                    if (!processedNames.has(name)) { // Optimization
                                        namesToProcess.add(name);
                                    }
                                });
                            }
                        }
                    });
                }
                return allAttacks;
            }


            function updateAttackDropdown() {
                attackSelect.innerHTML = ''; // Clear it
                const TM_SOURCE_ID = '-TM-';

                const attackerSlotId = attackerSelect.value;
                if (!attackerSlotId) {
                    damageInput.value = 0; // Also clear damage if no attacker
                    return;
                }

                const db = cardDatabase.value;
                const attackerSlotReplicant = slots.find(s => s.name === `draft_${attackerSlotId}`);
                if (!attackerSlotReplicant || !attackerSlotReplicant.value) return;

                const attackerCardId = attackerSlotReplicant.value.cardId;
                const attachedToolIds = attackerSlotReplicant.value.attachedToolIds || [];

                if (!attackerCardId || !db) return;

                const attackerCardData = db[attackerCardId];
                if (!attackerCardData) return;
                const attackerName = attackerCardData.name;

                // Combine cards from both decks for an efficient search scope.
                const deckLIds = deckL.value?.cards || [];
                const deckRIds = deckR.value?.cards || [];
                const combinedDeckIds = [...new Set([...deckLIds, ...deckRIds])];

                // Use the new function to get all attacks from the evolution line
                let allAttacks = getAllAttacksForPokemon(attackerCardId, db, combinedDeckIds);

                // Check for tool cards that grant attacks
                attachedToolIds.forEach(toolId => {
                    if (db[toolId]) {
                        const toolData = db[toolId];
                        // Check if the tool is a "Technical Machine" and has attacks
                        if (toolData.trainer?.attacks) {
                            const toolAttacks = toolData.trainer.attacks.map(attack => ({
                                ...attack,
                                source: TM_SOURCE_ID
                            }));
                            allAttacks.push(...toolAttacks);
                        }
                    }
                });

                if (allAttacks.length > 0) {
                    const uniqueAttackNames = new Set();
                    const uniqueAttacks = allAttacks.filter(attack => {
                        if (attack.name && !uniqueAttackNames.has(attack.name)) {
                            uniqueAttackNames.add(attack.name);
                            return true;
                        }
                        return false;
                    });

                    // Group attacks by their source for the dropdown
                    const groupedAttacks = uniqueAttacks.reduce((acc, attack) => {
                        const source = attack.source;
                        if (!acc[source]) {
                            acc[source] = [];
                        }
                        acc[source].push(attack);
                        return acc;
                    }, {});

                    // 1. Add attacks from the current Pokémon (no group)
                    if (groupedAttacks[attackerName]) {
                        groupedAttacks[attackerName].forEach(attack => {
                            const option = document.createElement('option');
                            option.value = attack.name;
                            option.textContent = attack.name;
                            attackSelect.appendChild(option);
                        });
                        delete groupedAttacks[attackerName]; // Remove from map to avoid re-processing
                    }

                    // 2. Add attacks from Technical Machine
                    if (groupedAttacks[TM_SOURCE_ID]) {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = TM_SOURCE_ID;
                        groupedAttacks[TM_SOURCE_ID].forEach(attack => {
                            const option = document.createElement('option');
                            option.value = attack.name;
                            option.textContent = attack.name;
                            optgroup.appendChild(option);
                        });
                        attackSelect.appendChild(optgroup);
                        delete groupedAttacks[TM_SOURCE_ID]; // Remove from map to avoid re-processing
                    }

                    // 3. Add attacks from other sources (pre-evolutions) in optgroups
                    Object.keys(groupedAttacks).forEach(sourceName => {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = sourceName;
                        groupedAttacks[sourceName].forEach(attack => {
                            const option = document.createElement('option');
                            option.value = attack.name;
                            option.textContent = attack.name;
                            optgroup.appendChild(option);
                        });
                        attackSelect.appendChild(optgroup);
                    });

                    if (attackSelect.options.length > 0) {
                        attackSelect.selectedIndex = 0;
                    }
                }
                // After updating attacks, also update the damage input
                recalculateFinalDamage();
            }

            function updateAttackerDropdown() {
                const db = cardDatabase.value;
                const turn = draft_currentTurn.value;
                if (!db || !turn) return;

                const currentValue = attackerSelect.value;
                attackerSelect.innerHTML = '<option value="">Select Attacker</option>';

                const availableAttackers = getOccupiedSlots().filter(slotId => slotId.startsWith(`slot${turn}`));

                const battleSlotId = `slot${turn}0`;
                const battlePokemon = availableAttackers.find(id => id === battleSlotId);
                const benchPokemon = availableAttackers.filter(id => id !== battleSlotId).sort(); // Sort bench for consistency

                // Add Battle Pokémon first
                if (battlePokemon) {
                    const option = document.createElement('option');
                    option.value = battlePokemon;
                    option.textContent = getCardName(battlePokemon);
                    attackerSelect.appendChild(option);
                }

                // Add separator if there are both battle and bench Pokémon
                if (battlePokemon && benchPokemon.length > 0) {
                    const separator = document.createElement('option');
                    separator.disabled = true;
                    separator.textContent = '──── Bench ────';
                    attackerSelect.appendChild(separator);
                }

                // Add Bench Pokémon
                benchPokemon.forEach(slotId => {
                    const option = document.createElement('option');
                    option.value = slotId;
                    option.textContent = getCardName(slotId);
                    attackerSelect.appendChild(option);
                });

                // Reselect the correct value
                if (availableAttackers.includes(currentValue)) {
                    attackerSelect.value = currentValue;
                } else if (battlePokemon) {
                    attackerSelect.value = battleSlotId;
                } else if (benchPokemon.length > 0) {
                    attackerSelect.value = benchPokemon[0];
                }

                // After updating the dropdown, the attack list and weakness should also be updated
                // based on the new state of the attacker dropdown.
                updateAttackDropdown();
                updateWeaknessAndResistanceChecks();
            }

            attackerSelect.addEventListener('change', () => {
                updateAttackDropdown();
                updateWeaknessAndResistanceChecks();
            });

            // Aim at opponent's battle pokemon
            aimBtn.addEventListener('click', () => {
                const currentTurn = draft_currentTurn.value;
                if (currentTurn === 'L') {
                    selections.value = getOccupiedSlots().filter(id => id === 'slotR0');
                } else if (currentTurn === 'R') {
                    selections.value = getOccupiedSlots().filter(id => id === 'slotL0');
                }
            });

            attackSelect.addEventListener('change', recalculateFinalDamage);

            attackBtn.addEventListener('click', () => {
                const attackerSlotId = attackerSelect.value;
                const attackName = attackSelect.value;
                const targets = selections.value;
                const damage = parseInt(damageInput.value, 10);
                const isWeakness = weaknessCheck.checked;

                if (!attackerSlotId) {
                    alert('No attacker selected!');
                    return;
                }

                if (!attackName) {
                    alert('No attack selected!');
                    return;
                }

                if (isNaN(damage) || damage < 0) {
                    alert('Please enter a valid damage amount.');
                    return;
                }

                const attackerSlotReplicant = slots.find(s => s.name === `draft_${attackerSlotId}`);
                const attackerCardId = attackerSlotReplicant ? attackerSlotReplicant.value.cardId : null;

                if (!attackerCardId) {
                    alert('Attacker slot is empty or invalid data.');
                    return;
                }

                queueOperation('ATTACK', {
                    attackerSlotId: attackerSlotId,
                    attackerCardId: attackerCardId,
                    attackName: attackName,
                    targets: targets || [],
                    damage: damage,
                    isWeakness: isWeakness,
                    attackerName: getCardName(attackerSlotId), // Enrich
                    targetNames: (targets || []).map(getCardName) // Enrich
                });
            });

            // --- Stadium Logic ---
            function updateStadiumButtons() {
                const db = cardDatabase.value;
                const deckLVal = deckL.value;
                const deckRVal = deckR.value;
                if (!db || !deckLVal || !deckRVal) return;

                const combinedCards = [...(deckLVal.cards || []), ...(deckRVal.cards || [])];
                const uniqueCardIds = [...new Set(combinedCards)];

                const stadiumCards = uniqueCardIds
                    .map(id => ({ id, data: db[id] }))
                    .filter(card => card.data && card.data.subtype === 'stadium');

                const currentStadiumId = draft_stadium.value ? draft_stadium.value.cardId : "";
                stadiumList.innerHTML = '';

                // Add "None" button
                const noneBtn = document.createElement('button');
                noneBtn.className = 'stadium-btn none-stadium';
                noneBtn.textContent = 'None';
                noneBtn.dataset.stadiumId = '';
                if (!currentStadiumId) {
                    noneBtn.classList.add('selected');
                }
                noneBtn.addEventListener('click', () => {
                    queueOrUpdateOperation('SET_STADIUM', { cardId: null });
                    queueOrUpdateOperation('SET_STADIUM_USED', { used: false });
                });
                stadiumList.appendChild(noneBtn);

                stadiumCards.forEach(card => {
                    const btn = document.createElement('button');
                    btn.className = 'stadium-btn';
                    if (card.id === currentStadiumId) {
                        btn.classList.add('selected');
                    }
                    btn.dataset.stadiumId = card.id;
                    btn.title = card.data.name;

                    const icon = document.createElement('div');
                    icon.className = 'stadium-icon';
                    icon.style.backgroundImage = getCardImageUrl(card.id, true);

                    btn.appendChild(icon);

                    btn.addEventListener('click', () => {
                        queueOrUpdateOperation('SET_STADIUM', {
                            cardId: card.id,
                            cardName: card.data.name // Enrich
                        });
                        queueOrUpdateOperation('SET_STADIUM_USED', { used: false });
                    });
                    stadiumList.appendChild(btn);
                });
            }

            stadiumUsedCheckbox.addEventListener('change', (e) => {
                const isUsed = e.target.checked;
                queueOrUpdateOperation('SET_STADIUM_USED', { used: isUsed });
            });




            // --- Main Action Buttons & Global Handlers ---
            function handleDiscard() {
                nodecg.sendMessage('discardQueue').catch(e => console.error("Failed to discard queue", e));
            }

            function handleApply() {
                nodecg.sendMessage('triggerApplyButton').catch(e => console.error("Failed to trigger apply button", e));
            }

            // --- Unified Hotkey Handling ---
            const hotkeyManager = new HotkeyManager(nodecg, settingsRep);

            hotkeyManager.on('discard', handleDiscard);
            hotkeyManager.on('apply', handleApply);
            hotkeyManager.on('clearSelection', () => btnSelectClear.click());
            hotkeyManager.on('peekOpponent', (isActive) => {
                isTabPressed = isActive;
                updateDevelopModuleState();
            });

            // --- Event Listeners for UI Updates ---

            // Core state changes that trigger wide UI updates
            draft_currentTurn.on('change', (newValue) => {
                renderCurrentPlayerField();
                updateEnergyAndToolButtons();
                updatePokemonSourceGrid();
                renderTargetingField();
                updateAttackerDropdown();

                if (newValue === 'L') {
                    turnLRadio.checked = true;
                } else if (newValue === 'R') {
                    turnRRadio.checked = true;
                }
            });

            cardDatabase.on('change', () => {
                console.log('Listener Fired: cardDatabase');
                // Re-render everything that uses card data
                renderCurrentPlayerField();
                updateBattleEnergyCounts();
                updateAttackerDropdown();
                renderTargetingField();
                updateWeaknessAndResistanceChecks();

                updateStadiumButtons();
                updateEnergyAndToolButtons();
                updatePokemonSourceGrid();
            });

            selections.on('change', () => {
                console.log('Listener Fired: selections');
                // When selections change, only the targeting view and weakness check needs to be updated
                renderTargetingField();
                updateWeaknessAndResistanceChecks();
            });

            // A single, consolidated listener for all slot changes
            slots.forEach(slot => {
                slot.on('change', () => {
                    // Using a timeout to batch updates that might come in rapid succession
                    clearTimeout(slot._updateTimeout);
                    slot._updateTimeout = setTimeout(() => {
                        console.log(`Listener Fired: ${slot.name}`);
                        updateTotalPokemons();
                        updateBattleEnergyCounts();
                        renderCurrentPlayerField();
                        renderTargetingField();
                        updateAttackerDropdown();
                        updateWeaknessAndResistanceChecks();
                    }, 50); // 50ms delay to batch updates
                });
            });

            // Listeners for deck changes (affects energy/tool/stadium visibility)
            const updateDeckDependentUI = () => {
                console.log('Listener Fired: deckL or deckR');
                updateEnergyAndToolButtons();
                updatePokemonSourceGrid();
                updateStadiumButtons();
            };
            deckL.on('change', updateDeckDependentUI);
            deckR.on('change', updateDeckDependentUI);

            draft_stadium.on('change', (newValue) => {
                console.log('Listener Fired: draft_stadium');
                const newStadiumId = newValue ? newValue.cardId : "";
                const isUsed = newValue ? newValue.used : false;

                // Update selected button
                const buttons = stadiumList.querySelectorAll('.stadium-btn');
                buttons.forEach(btn => {
                    if (btn.dataset.stadiumId === newStadiumId || (newStadiumId === "" && btn.dataset.stadiumId === "")) {
                        btn.classList.add('selected');
                        // Scroll into view if needed
                        if (newStadiumId) {
                            btn.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                        }
                    } else {
                        btn.classList.remove('selected');
                    }
                });
                if (stadiumUsedCheckbox.checked !== isUsed) {
                    stadiumUsedCheckbox.checked = isUsed;
                }
                updateStadiumBackground(); // Add this call
            });

            // Function to update stadium background
            function updateStadiumBackground() {
                const stadium = draft_stadium.value;
                if (stadium && stadium.cardId) {
                    const imageUrl = getCardImageUrl(stadium.cardId);
                    battleField.style.setProperty('--stadium-background-image', `url('${imageUrl}')`);
                } else {
                    battleField.style.removeProperty('--stadium-background-image');
                }
            }

            // Consolidated settings listener
            settingsRep.on('change', (newValue) => {
                console.log('Listener Fired: ptcg-settings');

                // Other UI updates that depend on settings
                updateEnergyAndToolButtons();
                updateWeaknessAndResistanceChecks();
            });

            assetPaths.on('change', () => {
                renderCurrentPlayerField();
                updateEnergyAndToolButtons();
                updatePokemonSourceGrid();
            });

            i18nStrings.on('change', updateUIStrings);
            language.on('change', updateUIStrings);

            // Initial UI Update ---
            updateUIStrings();
            updateTotalPokemons(); // Keep this
            updateBattleEnergyCounts(); // New
            updateTurnCount();
            updateAttackerDropdown();
            renderTargetingField();
            updateEnergyAndToolButtons();
            updatePokemonSourceGrid();
            renderCurrentPlayerField();
            updateStadiumBackground();


        });
    </script>
</body>

</html>