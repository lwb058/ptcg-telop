<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Card Display</title>
    <link rel="stylesheet" href="css/fonts.css">
    <script>
        // Dynamically preload fonts based on fonts.css
        (function() {
            fetch('css/fonts.css')
                .then(response => response.text())
                .then(text => {
                    const fontUrlRegex = /url\((['"]?)(.+?\.(?:ttf|otf|woff|woff2))\1\)/g;
                    let match;
                    while ((match = fontUrlRegex.exec(text)) !== null) {
                        const fontUrl = match[2];
                        const link = document.createElement('link');
                        link.rel = 'preload';
                        link.href = fontUrl;
                        link.as = 'font';
                        link.type = `font/${fontUrl.split('.').pop()}`;
                        link.crossOrigin = 'anonymous';
                        document.head.appendChild(link);
                    }
                }).catch(err => console.error('Failed to preload fonts:', err));
        })();
    </script>
    <link rel="stylesheet" href="css/common.css">
    <link id="theme-css-link" rel="stylesheet" href="" disabled>
    <style>
        /* Styles specific to the card display graphic */
        /* Common styles like body, overlay-frame, and animations are now in common.css */

        .player-area { 
            height: 560px; 
            transform: translateY(475px);
            justify-content: center;
            align-items: center;
            background-image: var(--bg-card-area);
        }
        .card-container {
            width: 95%; 
        }
        .card-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 22px;
        }

        /* Prize Card Styles */
        .prize-cards-container {
            position: absolute;
            width: 406px;
            height: 950px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            background-image: url('/assets/ptcg-telop/element/side-bg.png');
            background-size: 100% 100%;
            background-position: center;
            background-repeat: no-repeat;
            padding: 35px;
            box-sizing: border-box;
        }

        .prize-card-slot {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .prize-card-image {
            max-width: 100%;
            max-height: 100%;
            border-radius: 10px;
        }

        .taken-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="overlay-frame">
        <div id="animation-wrapper-L" class="animation-wrapper">
            <div class="player-area" id="player-L-area">
                <div id="card-container-L" class="card-container">
                    <img id="card-image-L" class="card-image" src="/assets/ptcg-telop/element/default.jpg" alt="Left Card Image">
                </div>
            </div>
            <div id="prize-cards-container-L" class="prize-cards-container" style="display: none;">
                <!-- Prize card slots for Player L will be generated here -->
            </div>
        </div>
        <div id="animation-wrapper-R" class="animation-wrapper">
            <div class="player-area" id="player-R-area">
                <div id="card-container-R" class="card-container">
                    <img id="card-image-R" class="card-image" src="/assets/ptcg-telop/element/default.jpg" alt="Right Card Image">
                </div>
            </div>
            <div id="prize-cards-container-R" class="prize-cards-container" style="display: none;">
                <!-- Prize card slots for Player R will be generated here -->
            </div>
        </div>
    </div>
    <div id="video-preloader" style="position: absolute; width: 1px; height: 1px; overflow: hidden; left: -9999px; top: -9999px; visibility: hidden; pointer-events: none;"></div>
    <script>
        // --- DOM Elements ---
        const animationWrapperL = document.getElementById('animation-wrapper-L');
        const animationWrapperR = document.getElementById('animation-wrapper-R');
        const playerAreaL = document.getElementById('player-L-area');
        const playerAreaR = document.getElementById('player-R-area');
        const prizeContainerL = document.getElementById('prize-cards-container-L');
        const prizeContainerR = document.getElementById('prize-cards-container-R');
        const cardImageL = document.getElementById('card-image-L');
        const cardImageR = document.getElementById('card-image-R');
        const preloaderContainer = document.getElementById('video-preloader');
        const defaultImage = '/assets/ptcg-telop/element/default.jpg';

        // --- Replicants ---
        const cardToShowL = nodecg.Replicant('cardToShowL');
        const cardToShowR = nodecg.Replicant('cardToShowR');
        const settingsRep = nodecg.Replicant('ptcg-settings');
        const assetPaths = nodecg.Replicant('assetPaths');
        const cardDatabase = nodecg.Replicant('cardDatabase');
        const themeAssets = nodecg.Replicant('themeAssets');
        const language = nodecg.Replicant('language');
        const deckL = nodecg.Replicant('deckL');
        const deckR = nodecg.Replicant('deckR');

        // --- State ---
        const displayState = {
            L: { mode: 'hidden', isAnimating: false, data: null },
            R: { mode: 'hidden', isAnimating: false, data: null }
        };
        let isReversed = false;

        // --- Utility Functions ---
        function onAnimationEnd(element) {
            return new Promise(resolve => {
                // A fallback timeout in case the animationend event doesn't fire.
                const timeout = setTimeout(() => {
                    console.warn('AnimationEnd fallback timeout triggered for:', element);
                    resolve();
                }, 1000); // 1 second timeout
                element.addEventListener('animationend', () => {
                    clearTimeout(timeout);
                    resolve();
                }, { once: true });
            });
        }

        const getCardImageUrl = (cardId) => {
            if (!cardId || !assetPaths.value || !assetPaths.value.cardImgPath || !cardDatabase.value) {
                return defaultImage;
            }
            const db = cardDatabase.value;
            const cardData = db[cardId];
            const imageUrl = cardData ? cardData.image_url : null;
            const extension = imageUrl ? imageUrl.substring(imageUrl.lastIndexOf('.')) : '.jpg';
            return `/${assetPaths.value.cardImgPath}${cardId}${extension}`;
        };

        // --- Core Display Logic ---
        async function setDisplay(side, newMode, newData) {
            const state = displayState[side];
            if (state.isAnimating) {
                console.warn(`Animation for side ${side} is already in progress. Request ignored.`);
                return;
            }

            const dataChanged = JSON.stringify(state.data) !== JSON.stringify(newData);
            if (state.mode === newMode && !dataChanged) {
                // If we're asked to show the same thing again, just re-animate "in"
                if (newMode !== 'hidden') {
                    const wrapper = side === 'L' ? animationWrapperL : animationWrapperR;
                    wrapper.classList.remove(`anim-slide-in-${side}`);
                    void wrapper.offsetWidth; // Trigger reflow
                    wrapper.classList.add(`anim-slide-in-${side}`);
                }
                return;
            }

            state.isAnimating = true;

            const wrapper = side === 'L' ? animationWrapperL : animationWrapperR;
            const playerArea = side === 'L' ? playerAreaL : playerAreaR;
            const prizeContainer = side === 'L' ? prizeContainerL : prizeContainerR;
            const currentMode = state.mode;

            // 1. Animate Out
            if (currentMode !== 'hidden') {
                wrapper.classList.remove(`anim-slide-in-${side}`);
                wrapper.classList.add(`anim-slide-out-${side}`);
                await onAnimationEnd(wrapper);
            }

            // 2. Update Content & State (while wrapper is hidden)
            state.mode = newMode;
            state.data = newData;

            playerArea.style.display = 'none';
            prizeContainer.style.display = 'none';

            if (newMode === 'singleCard') {
                const image = side === 'L' ? cardImageL : cardImageR;
                image.src = newData; // newData is the URL
                playerArea.style.display = 'flex';
            } else if (newMode === 'prizeCard') {
                prizeContainer.innerHTML = '';
                newData.forEach(card => { // newData is the cards array
                    const slot = document.createElement('div');
                    slot.className = 'prize-card-slot';
                    if (card.cardId) {
                        const img = document.createElement('img');
                        img.className = 'prize-card-image';
                        img.src = getCardImageUrl(card.cardId);
                        slot.appendChild(img);
                        if (card.isTaken) {
                            const overlay = document.createElement('div');
                            overlay.className = 'taken-overlay';
                            slot.appendChild(overlay);
                        }
                    }
                    prizeContainer.appendChild(slot);
                });
                prizeContainer.style.display = 'grid';
            }

            // 3. Animate In
            if (newMode !== 'hidden') {
                wrapper.classList.remove(`anim-slide-out-${side}`);
                wrapper.classList.add(`anim-slide-in-${side}`);
            }
            
            state.isAnimating = false;
        }

        // --- Event Listeners ---
        cardToShowL.on('change', (newValue) => {
            const side = isReversed ? 'R' : 'L';
            const newMode = newValue ? 'singleCard' : 'hidden';
            const newSrc = newValue ? getCardImageUrl(newValue.match(/(\d{5,})/)[1]) : null;
            setDisplay(side, newMode, newSrc);
        });

        cardToShowR.on('change', (newValue) => {
            const side = isReversed ? 'L' : 'R';
            const newMode = newValue ? 'singleCard' : 'hidden';
            const newSrc = newValue ? getCardImageUrl(newValue.match(/(\d{5,})/)[1]) : null;
            setDisplay(side, newMode, newSrc);
        });

        nodecg.listenFor('showPrizeCards', ({ side, cards }) => {
            const targetSide = isReversed ? (side === 'L' ? 'R' : 'L') : side;
            setDisplay(targetSide, 'prizeCard', cards);
        });

        nodecg.listenFor('clearCard', () => {
            setDisplay('L', 'hidden', null);
            setDisplay('R', 'hidden', null);
        });

        // --- Theming and Asset Preloading (unchanged) ---
        function resolveAssetPath(assetName, isLangSpecific = false) {
            const settings = settingsRep.value || {};
            const activeTheme = settings.activeTheme || 'Default';
            const themeAssetMap = themeAssets.value || {};
            const lang = language.value || 'jp';
            const basePath = '/assets/ptcg-telop/';
            const potentialPath = assetName.replace(/url\((['\"]?)(.*?)\1\)/, '$2');
            const cleanAssetName = potentialPath.split('/').pop();
            if (activeTheme !== 'Default' && themeAssetMap[activeTheme] && themeAssetMap[activeTheme].includes(cleanAssetName)) {
                return `${basePath}${activeTheme}/${cleanAssetName}`;
            }
            if (isLangSpecific) {
                const baseName = assetName.replace(/_jp\.png$/, '');
                const langAssetName = `${baseName}_${lang}.png`;
                return `${basePath}element/${langAssetName}`;
            }
            return `${basePath}element/${assetName}`;
        }

        function updateCustomizableAssets() {
            const root = document.documentElement;
            root.style.setProperty('--bg-card-area', `url(${resolveAssetPath('card-bg.png')})`);
        }

        function preloadDeckImages(deck) {
            if (!deck || !deck.cards || !assetPaths.value || !assetPaths.value.cardImgPath || !preloaderContainer) return;
            deck.cards.forEach(cardId => {
                const fullPath = getCardImageUrl(cardId);
                if (fullPath !== defaultImage && !preloaderContainer.querySelector(`img[src="${fullPath}"]`)) {
                    const img = document.createElement('img');
                    img.src = fullPath;
                    preloaderContainer.appendChild(img);
                }
            });
        }

        const handleThemeChange = (settings) => {
            const activeTheme = (settings && settings.activeTheme) || 'Default';
            const themeCssLink = document.getElementById('theme-css-link');
            if (themeCssLink) {
                if (activeTheme === 'Default') {
                    themeCssLink.disabled = true;
                    themeCssLink.href = '';
                } else {
                    themeCssLink.href = `css/${activeTheme}.css`;
                    themeCssLink.disabled = false;
                }
            }
            updateCustomizableAssets();
        };

        // --- Init ---
        NodeCG.waitForReplicants(assetPaths, deckL, deckR, cardDatabase, themeAssets, language, settingsRep).then(() => {
            const settings = settingsRep.value || {};
            isReversed = !!settings.reverseCardDisplay;
            handleThemeChange(settings);
            preloadDeckImages(deckL.value);
            preloadDeckImages(deckR.value);
            deckL.on('change', (newVal) => preloadDeckImages(newVal));
            deckR.on('change', (newVal) => preloadDeckImages(newVal));
        });

        settingsRep.on('change', (newValue, oldValue) => {
            const newSettings = newValue || {};
            const oldSettings = oldValue || {};
            if (newSettings.reverseCardDisplay !== oldSettings.reverseCardDisplay) {
                isReversed = !!newSettings.reverseCardDisplay;
            }
            if (newSettings.activeTheme !== oldSettings.activeTheme) {
                handleThemeChange(newSettings);
            }
            if (newSettings.language !== oldSettings.language) {
                updateCustomizableAssets();
            }
        });
    </script>
</body>
</html>
