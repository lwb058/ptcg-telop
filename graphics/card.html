<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Card Display</title>
    <link rel="stylesheet" href="css/fonts.css">
    <script>
        // Dynamically preload fonts based on fonts.css
        (function() {
            fetch('css/fonts.css')
                .then(response => response.text())
                .then(text => {
                    const fontUrlRegex = /url\((['"]?)(.+?\.(?:ttf|otf|woff|woff2))\1\)/g;
                    let match;
                    while ((match = fontUrlRegex.exec(text)) !== null) {
                        const fontUrl = match[2];
                        const link = document.createElement('link');
                        link.rel = 'preload';
                        link.href = fontUrl;
                        link.as = 'font';
                        link.type = `font/${fontUrl.split('.').pop()}`;
                        link.crossOrigin = 'anonymous';
                        document.head.appendChild(link);
                    }
                }).catch(err => console.error('Failed to preload fonts:', err));
        })();
    </script>
    <link rel="stylesheet" href="css/common.css">
    <style>
        /* Styles specific to the card display graphic */
        /* Common styles like body, overlay-frame, and animations are now in common.css */

        .player-area { 
            height: 560px; 
            transform: translateY(475px);
            justify-content: center;
            align-items: center;
            background-image: url('/assets/ptcg-telop/element/card-bg.png');
        }
        .card-container {
            width: 95%; 
                    }
        .card-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 22px;
        }
    </style>
</head>
<body>
    <div class="overlay-frame">
        <div id="animation-wrapper-L" class="animation-wrapper">
            <div class="player-area" id="player-L-area">
                <div id="card-container-L" class="card-container">
                    <img id="card-image-L" class="card-image" src="/assets/ptcg-telop/element/default.jpg" alt="Left Card Image">
                </div>
            </div>
        </div>
        <div id="animation-wrapper-R" class="animation-wrapper">
            <div class="player-area" id="player-R-area">
                <div id="card-container-R" class="card-container">
                    <img id="card-image-R" class="card-image" src="/assets/ptcg-telop/element/default.jpg" alt="Right Card Image">
                </div>
            </div>
        </div>
    </div>
    <div id="video-preloader" style="position: absolute; width: 1px; height: 1px; overflow: hidden; left: -9999px; top: -9999px; visibility: hidden; pointer-events: none;"></div>
    <script>
         const animationWrapperL = document.getElementById('animation-wrapper-L');
         const animationWrapperR = document.getElementById('animation-wrapper-R');
         const cardImageL = document.getElementById('card-image-L');
         const cardImageR = document.getElementById('card-image-R');
         const defaultImage = '/assets/ptcg-telop/element/default.jpg';
 
         // State object to track visibility and animation status for each side
         const cardState = {
             L: { isVisible: false, isAnimating: false },
             R: { isVisible: false, isAnimating: false }
         };
 
         // Helper function to promisify animationend event
         function onAnimationEnd(element) {
             return new Promise(resolve => {
                 element.addEventListener('animationend', resolve, { once: true });
             });
         }
 
        const cardToShowL = nodecg.Replicant('cardToShowL');
                 const cardToShowR = nodecg.Replicant('cardToShowR');
                const settingsRep = nodecg.Replicant('ptcg-settings');
                const assetPaths = nodecg.Replicant('assetPaths');
                const deckL = nodecg.Replicant('deckL');
                const deckR = nodecg.Replicant('deckR');
                const cardDatabase = nodecg.Replicant('cardDatabase');
        
                const getCardImageUrl = (cardId) => {
                    if (!cardId || !assetPaths.value || !assetPaths.value.cardImgPath || !cardDatabase.value) {
                        return defaultImage;
                    }
                    const db = cardDatabase.value;
                    const cardData = db[cardId];
                    const imageUrl = cardData ? cardData.image_url : null;
                    const extension = imageUrl ? imageUrl.substring(imageUrl.lastIndexOf('.')) : '.jpg';
                    return `/${assetPaths.value.cardImgPath}${cardId}${extension}`;
                };
        let isReversed = false;

        // --- Deck Card Preloading Logic ---
        const preloaderContainer = document.getElementById('video-preloader');
        function preloadDeckImages(deck) {
            if (!deck || !deck.cards || !assetPaths.value || !assetPaths.value.cardImgPath || !preloaderContainer) return;

            deck.cards.forEach(cardId => {
                const fullPath = getCardImageUrl(cardId);
                if (fullPath !== defaultImage && !preloaderContainer.querySelector(`img[src="${fullPath}"]`)) {
                    const img = document.createElement('img');
                    img.src = fullPath;
                    preloaderContainer.appendChild(img);
                }
            });
        }

        // Wait for replicants to be ready before preloading
        NodeCG.waitForReplicants(assetPaths, deckL, deckR).then(() => {
            // Initial preload for both decks
            preloadDeckImages(deckL.value);
            preloadDeckImages(deckR.value);

            // Listen for changes in both decks
            deckL.on('change', (newVal) => preloadDeckImages(newVal));
            deckR.on('change', (newVal) => preloadDeckImages(newVal));
        });
        // --- End Preloading Logic ---

        settingsRep.on('change', (newValue) => {
            if (newValue) {
                isReversed = !!newValue.reverseCardDisplay;
            }
        });

         async function handleCardUpdate(animatedContainer, image, newValue, side) {
            const state = cardState[side];
            if (state.isAnimating) {
                console.warn(`Animation for ${side} side is already in progress. Request ignored.`);
                return;
            }
            state.isAnimating = true;

            const wantsToShow = !!newValue;
            let newSrc = newValue || defaultImage;

            // Logic to construct the correct image path
            if (wantsToShow && assetPaths.value && assetPaths.value.cardImgPath) {
                // The newValue is a path string like '.../12345.jpg'. We need to extract the ID.
                const cardIdMatch = newValue.match(/(\d{5,})/);
                if (cardIdMatch) {
                    const cardId = cardIdMatch[1];
                    newSrc = getCardImageUrl(cardId); // Use the new helper function
                } else {
                    // Fallback to original value if parsing fails
                    newSrc = newValue;
                }
            }

            try {
                // Case 1: Hide the card
                if (!wantsToShow && state.isVisible) {
                    animatedContainer.classList.remove(`anim-slide-in-${side}`); // Clean up previous state
                    animatedContainer.classList.add(`anim-slide-out-${side}`);
                    await onAnimationEnd(animatedContainer);
                    // DO NOT remove the slide-out class. It keeps the element off-screen.
                    image.src = defaultImage;
                    state.isVisible = false;
                } 
                // Case 2: Show or Update the card
                else if (wantsToShow) {
                    // If it's an update (already visible), slide it out first.
                    if (state.isVisible) {
                        animatedContainer.classList.remove(`anim-slide-in-${side}`);
                        animatedContainer.classList.add(`anim-slide-out-${side}`);
                        await onAnimationEnd(animatedContainer);
                    }

                    // Now it's off-screen. Change image, then clean up and slide in.
                    image.src = newSrc;
                    animatedContainer.classList.remove(`anim-slide-out-${side}`); // "Self-cleanup" before sliding in
                    
                    animatedContainer.classList.add(`anim-slide-in-${side}`);
                    await onAnimationEnd(animatedContainer);
                    
                    // Leave the slide-in class on to keep it visible. It will be cleaned up by the next operation.
                    state.isVisible = true;
                }
            } finally {
                state.isAnimating = false;
            }
         }

        cardToShowL.on('change', (newValue) => {
            if (isReversed) {
                handleCardUpdate(animationWrapperR, cardImageR, newValue, 'R');
            } else {
                handleCardUpdate(animationWrapperL, cardImageL, newValue, 'L');
            }
        });
 
        cardToShowR.on('change', (newValue) => {
            if (isReversed) {
                handleCardUpdate(animationWrapperL, cardImageL, newValue, 'L');
            } else {
                handleCardUpdate(animationWrapperR, cardImageR, newValue, 'R');
            }
        });
    </script>
</body>
</html>
