<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Card Display</title>
    <link rel="stylesheet" href="css/fonts.css">
    <script>
        // Dynamically preload fonts based on fonts.css
        (function() {
            fetch('css/fonts.css')
                .then(response => response.text())
                .then(text => {
                    const fontUrlRegex = /url\((['"]?)(.+?\.(?:ttf|otf|woff|woff2))\1\)/g;
                    let match;
                    while ((match = fontUrlRegex.exec(text)) !== null) {
                        const fontUrl = match[2];
                        const link = document.createElement('link');
                        link.rel = 'preload';
                        link.href = fontUrl;
                        link.as = 'font';
                        link.type = `font/${fontUrl.split('.').pop()}`;
                        link.crossOrigin = 'anonymous';
                        document.head.appendChild(link);
                    }
                }).catch(err => console.error('Failed to preload fonts:', err));
        })();
    </script>
    <link rel="stylesheet" href="css/common.css">
    <link id="theme-css-link" rel="stylesheet" href="" disabled>
    <style>
        /* Styles specific to the card display graphic */
        /* Common styles like body, overlay-frame, and animations are now in common.css */

        .player-area { 
            height: 560px; 
            transform: translateY(475px);
            justify-content: center;
            align-items: center;
            background-image: var(--bg-card-area);
        }
        .card-container {
            width: 95%; 
                    }
        .card-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 22px;
        }
    </style>
</head>
<body>
    <div class="overlay-frame">
        <div id="animation-wrapper-L" class="animation-wrapper">
            <div class="player-area" id="player-L-area">
                <div id="card-container-L" class="card-container">
                    <img id="card-image-L" class="card-image" src="/assets/ptcg-telop/element/default.jpg" alt="Left Card Image">
                </div>
            </div>
        </div>
        <div id="animation-wrapper-R" class="animation-wrapper">
            <div class="player-area" id="player-R-area">
                <div id="card-container-R" class="card-container">
                    <img id="card-image-R" class="card-image" src="/assets/ptcg-telop/element/default.jpg" alt="Right Card Image">
                </div>
            </div>
        </div>
    </div>
    <div id="video-preloader" style="position: absolute; width: 1px; height: 1px; overflow: hidden; left: -9999px; top: -9999px; visibility: hidden; pointer-events: none;"></div>
    <script>
         const animationWrapperL = document.getElementById('animation-wrapper-L');
         const animationWrapperR = document.getElementById('animation-wrapper-R');
         const cardImageL = document.getElementById('card-image-L');
         const cardImageR = document.getElementById('card-image-R');
         const defaultImage = '/assets/ptcg-telop/element/default.jpg';
 
         const cardState = {
             L: { isVisible: false, isAnimating: false },
             R: { isVisible: false, isAnimating: false }
         };
 
         function onAnimationEnd(element) {
             return new Promise(resolve => {
                 element.addEventListener('animationend', resolve, { once: true });
             });
         }
 
        const cardToShowL = nodecg.Replicant('cardToShowL');
        const cardToShowR = nodecg.Replicant('cardToShowR');
        const settingsRep = nodecg.Replicant('ptcg-settings');
        const assetPaths = nodecg.Replicant('assetPaths');
        const deckL = nodecg.Replicant('deckL');
        const deckR = nodecg.Replicant('deckR');
        const cardDatabase = nodecg.Replicant('cardDatabase');
        const themeAssets = nodecg.Replicant('themeAssets');
        const language = nodecg.Replicant('language');

        function resolveAssetPath(assetName, isLangSpecific = false) {
            const settings = settingsRep.value || {};
            const activeTheme = settings.activeTheme || 'Default';
            const themeAssetMap = themeAssets.value || {};
            const lang = language.value || 'jp';
            const basePath = '/assets/ptcg-telop/';

            const potentialPath = assetName.replace(/url\((['\"]?)(.*?)\1\)/, '$2');
            const cleanAssetName = potentialPath.split('/').pop();

            if (activeTheme !== 'Default' && themeAssetMap[activeTheme] && themeAssetMap[activeTheme].includes(cleanAssetName)) {
                return `${basePath}${activeTheme}/${cleanAssetName}`;
            }

            if (isLangSpecific) {
                const baseName = assetName.replace(/_jp\.png$/, '');
                const langAssetName = `${baseName}_${lang}.png`;
                return `${basePath}element/${langAssetName}`;
            }

            return `${basePath}element/${assetName}`;
        }

        function updateCustomizableAssets() {
            const root = document.documentElement;
            root.style.setProperty('--bg-card-area', `url(${resolveAssetPath('card-bg.png')})`);
        }

        const getCardImageUrl = (cardId) => {
            if (!cardId || !assetPaths.value || !assetPaths.value.cardImgPath || !cardDatabase.value) {
                return defaultImage;
            }
            const db = cardDatabase.value;
            const cardData = db[cardId];
            const imageUrl = cardData ? cardData.image_url : null;
            const extension = imageUrl ? imageUrl.substring(imageUrl.lastIndexOf('.')) : '.jpg';
            return `/${assetPaths.value.cardImgPath}${cardId}${extension}`;
        };
        let isReversed = false;

        const preloaderContainer = document.getElementById('video-preloader');
        function preloadDeckImages(deck) {
            if (!deck || !deck.cards || !assetPaths.value || !assetPaths.value.cardImgPath || !preloaderContainer) return;

            deck.cards.forEach(cardId => {
                const fullPath = getCardImageUrl(cardId);
                if (fullPath !== defaultImage && !preloaderContainer.querySelector(`img[src="${fullPath}"]`)) {
                    const img = document.createElement('img');
                    img.src = fullPath;
                    preloaderContainer.appendChild(img);
                }
            });
        }

        const handleThemeChange = (settings) => {
            const activeTheme = (settings && settings.activeTheme) || 'Default';
            const themeCssLink = document.getElementById('theme-css-link');

            if (themeCssLink) {
                if (activeTheme === 'Default') {
                    themeCssLink.disabled = true;
                    themeCssLink.href = '';
                } else {
                    themeCssLink.href = `css/${activeTheme}.css`;
                    themeCssLink.disabled = false;
                }
            }
            updateCustomizableAssets();
        };

        NodeCG.waitForReplicants(assetPaths, deckL, deckR, cardDatabase, themeAssets, language, settingsRep).then(() => {
            // Initial setup
            const settings = settingsRep.value || {};
            isReversed = !!settings.reverseCardDisplay;
            handleThemeChange(settings);
            
            preloadDeckImages(deckL.value);
            preloadDeckImages(deckR.value);

            deckL.on('change', (newVal) => preloadDeckImages(newVal));
            deckR.on('change', (newVal) => preloadDeckImages(newVal));
        });

        settingsRep.on('change', (newValue, oldValue) => {
            const newSettings = newValue || {};
            const oldSettings = oldValue || {};

            if (newSettings.reverseCardDisplay !== oldSettings.reverseCardDisplay) {
                isReversed = !!newSettings.reverseCardDisplay;
            }

            if (newSettings.activeTheme !== oldSettings.activeTheme) {
                handleThemeChange(newSettings);
            }

            if (newSettings.language !== oldSettings.language) {
                updateCustomizableAssets();
            }
        });

         async function handleCardUpdate(animatedContainer, image, newValue, side) {
            const state = cardState[side];
            if (state.isAnimating) {
                console.warn(`Animation for ${side} side is already in progress. Request ignored.`);
                return;
            }
            state.isAnimating = true;

            const wantsToShow = !!newValue;
            let newSrc = newValue || defaultImage;

            if (wantsToShow && assetPaths.value && assetPaths.value.cardImgPath) {
                const cardIdMatch = newValue.match(/(\d{5,})/);
                if (cardIdMatch) {
                    const cardId = cardIdMatch[1];
                    newSrc = getCardImageUrl(cardId);
                } else {
                    newSrc = newValue;
                }
            }

            try {
                if (!wantsToShow && state.isVisible) {
                    animatedContainer.classList.remove(`anim-slide-in-${side}`);
                    animatedContainer.classList.add(`anim-slide-out-${side}`);
                    await onAnimationEnd(animatedContainer);
                    image.src = defaultImage;
                    state.isVisible = false;
                } 
                else if (wantsToShow) {
                    if (state.isVisible) {
                        animatedContainer.classList.remove(`anim-slide-in-${side}`);
                        animatedContainer.classList.add(`anim-slide-out-${side}`);
                        await onAnimationEnd(animatedContainer);
                    }

                    image.src = newSrc;
                    animatedContainer.classList.remove(`anim-slide-out-${side}`);
                    
                    animatedContainer.classList.add(`anim-slide-in-${side}`);
                    await onAnimationEnd(animatedContainer);
                    
                    state.isVisible = true;
                }
            } finally {
                state.isAnimating = false;
            }
         }

        cardToShowL.on('change', (newValue) => {
            if (isReversed) {
                handleCardUpdate(animationWrapperR, cardImageR, newValue, 'R');
            } else {
                handleCardUpdate(animationWrapperL, cardImageL, newValue, 'L');
            }
        });
 
        cardToShowR.on('change', (newValue) => {
            if (isReversed) {
                handleCardUpdate(animationWrapperL, cardImageL, newValue, 'L');
            } else {
                handleCardUpdate(animationWrapperR, cardImageR, newValue, 'R');
            }
        });
    </script>
</body>
</html>
