<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Extra Bench Graphic</title>
    <link rel="stylesheet" href="css/fonts.css">
    <script>
        // Dynamically preload fonts based on fonts.css
        (function() {
            fetch('css/fonts.css')
                .then(response => response.text())
                .then(text => {
                    const fontUrlRegex = /url\((['"]?)(.+?\.(?:ttf|otf|woff|woff2))\1\)/g;
                    let match;
                    while ((match = fontUrlRegex.exec(text)) !== null) {
                        const fontUrl = match[2];
                        const link = document.createElement('link');
                        link.rel = 'preload';
                        link.href = fontUrl;
                        link.as = 'font';
                        link.type = `font/${fontUrl.split('.').pop()}`;
                        link.crossOrigin = 'anonymous';
                        document.head.appendChild(link);
                    }
                }).catch(err => console.error('Failed to preload fonts:', err));
        })();
    </script>
    <link rel="stylesheet" href="css/common.css">
    <link id="theme-css-link" rel="stylesheet" href="" disabled>
    <style>
        .player-area { 
            height: 560px; 
            transform: translateY(475px);
            flex-direction: column; 
            background-color: var(--color-bg-panel); 
            background-image: var(--asset-extra-bg);
        }
        .bench-slots { gap: 24px; } /* Override default gap */
        .extra-bench-title {
            height: 64px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Dela Gothic One', sans-serif;
            font-size: 32px;
            font-style: italic;
            letter-spacing: 3px;
            color: var(--module-border);
            background-color: var(--third-color);
            border-radius: 20px;
            margin: 8px;
            margin-top: 36px;
            margin-bottom: 36px;
            box-sizing: border-box;
            visibility: hidden;
        }

    </style>
</head>
<body>
    <!-- SVG Filter Definitions for Text Effects -->
    <svg width="0" height="0" style="position:absolute;z-index:-1;">
        <defs>
        <filter id="text-stroke-shadow-bench" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="4" dy="4" stdDeviation="2" flood-color="#00000099" result="shadow"/>
            <feMorphology in="SourceAlpha" result="stroke" operator="dilate" radius="3"></feMorphology>
            <feFlood flood-color="#000b1a" result="stroke-color"/>
            <feComposite in="stroke-color" in2="stroke" operator="in" result="stroke-shape"/>
            <feMerge>
                <feMergeNode in="shadow"/>
                <feMergeNode in="stroke-shape"/>
                <feMergeNode in="SourceGraphic"/>
            </feMerge>
        </filter>
        </defs>
    </svg>
    <div class="overlay-frame">
        <div id="animation-wrapper-L" class="animation-wrapper">
            <div class="player-area" id="player-L-area">
                <div class="extra-bench-title">EXTRA BENCH</div>
                <div class="bench-slots">
                    <div class="bench-slot" id="slot-L6"></div>
                    <div class="bench-slot" id="slot-L7"></div>
                    <div class="bench-slot" id="slot-L8"></div>
                </div>
            </div>
        </div>
        <div id="animation-wrapper-R" class="animation-wrapper">
            <div class="player-area" id="player-R-area">
                <div class="extra-bench-title">EXTRA BENCH</div>
                <div class="bench-slots">
                    <div class="bench-slot" id="slot-R6"></div>
                    <div class="bench-slot" id="slot-R7"></div>
                    <div class="bench-slot" id="slot-R8"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Preloader Container for FX Videos (Hidden) -->
    <div id="video-preloader"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const getCardImageUrl = (cardId, isBgImage = false) => {
                if (!cardId || !assetPaths.value.cardImgPath) {
                    return isBgImage ? 'none' : '';
                }
                const db = cardDatabase.value;
                const cardData = db ? db[cardId] : null;
                const imageUrl = cardData ? cardData.image_url : null;
                const extension = imageUrl ? imageUrl.substring(imageUrl.lastIndexOf('.')) : '.jpg'; // Fallback to .jpg
                const path = `/${assetPaths.value.cardImgPath}${cardId}${extension}`;
                return isBgImage ? `url(${path})` : path;
            };
            const ENERGY_MAP = { "草": "草", "炎": "炎", "水": "水", "雷": "雷", "超": "超", "闘": "闘", "悪": "悪", "鋼": "鋼", "無": "無", "全": "全", "竜": "竜", "妖": "妖" };
            // Animation Timings
            const REPLACE_ANIMATION_HIDE_MS = 550;
            const REPLACE_ANIMATION_SHOW_MS = 700;
            const g_attackAnimationTargets = new Set();
            const activeAnimations = new Map();

            // --- Animation Control ---
            const animationWrapperL = document.getElementById('animation-wrapper-L');
            const animationWrapperR = document.getElementById('animation-wrapper-R');
            const extraBenchVisible = nodecg.Replicant('extraBenchVisible', { defaultValue: { left: false, right: false } });

            const visibilityState = {
                left: { isVisible: false, isAnimating: false },
                right: { isVisible: false, isAnimating: false }
            };

            function onAnimationEnd(element) {
                return new Promise(resolve => {
                    element.addEventListener('animationend', resolve, { once: true });
                });
            }

            async function handleVisibility(side, wantsToShow) {
                const state = side === 'L' ? visibilityState.left : visibilityState.right;
                const wrapper = side === 'L' ? animationWrapperL : animationWrapperR;
                const animInClass = `anim-slide-in-${side}`;
                const animOutClass = `anim-slide-out-${side}`;

                if (state.isAnimating || state.isVisible === wantsToShow) {
                    return;
                }
                state.isAnimating = true;

                try {
                    if (wantsToShow) {
                        wrapper.classList.remove(animOutClass);
                        wrapper.classList.add(animInClass);
                        await onAnimationEnd(wrapper);
                        state.isVisible = true;
                    } else {
                        wrapper.classList.remove(animInClass);
                        wrapper.classList.add(animOutClass);
                        await onAnimationEnd(wrapper);
                        state.isVisible = false;
                    }
                } finally {
                    state.isAnimating = false;
                }
            }

            extraBenchVisible.on('change', (newValue) => {
                if (!newValue) return;
                handleVisibility('L', newValue.left);
                handleVisibility('R', newValue.right);
            });

            function playToolAnimation(targetEl, isBattleSlot, isAttach) {

                const videoSrc = isAttach ? '/assets/ptcg-telop/fx/tool-attach.webm' : '/assets/ptcg-telop/fx/tool-remove.webm';
                const targetRect = targetEl.getBoundingClientRect();
                if (targetRect.width === 0 && targetRect.height === 0) return;

                const video = document.createElement('video');
                video.src = videoSrc;
                video.muted = true;
                video.autoplay = true;
                video.style.position = 'absolute';
                video.style.zIndex = '400';
                video.style.pointerEvents = 'none';

                const videoWidth = 70;
                const videoHeight = 56;
                video.style.width = `${videoWidth}px`;
                video.style.height = `${videoHeight}px`;

                const targetCenterX = targetRect.left + targetRect.width / 2;
                const targetCenterY = targetRect.top + targetRect.height / 2;
                video.style.left = `${targetCenterX - videoWidth / 2}px`;
                video.style.top = `${targetCenterY - videoHeight / 2}px`;

                document.body.appendChild(video);
                video.addEventListener('ended', () => video.remove());
            }
            function updateAttachedTools(slotEl, newToolIds, oldToolIds, isBattleSlot, forceRedraw = false) {
                const db = cardDatabase.value;
                const wrapperSelector = '.bench-attached-tools-wrapper';
                const itemClass = 'bench-attached-tool-item';
                const wrapperEl = slotEl.querySelector('.bench-attached-tools-wrapper');
                if (!wrapperEl) return;

                // If a forceRedraw is needed (because the parent DOM was wiped), skip diffing and just render the new state.
                if (forceRedraw) {
                    wrapperEl.innerHTML = ''; // Clear any previous content
                    newToolIds.forEach(id => {
                        if (db[id]) {
                            const toolItem = document.createElement('div');
                            // Use a simple scale-in animation for this redraw case to avoid complexity.
                            toolItem.className = `${itemClass} anim-scale-in-tool`;
                            toolItem.dataset.toolId = id;
                            const toolImg = document.createElement('img');
                            toolImg.src = getCardImageUrl(id);
                            toolItem.appendChild(toolImg);
                            wrapperEl.appendChild(toolItem);
                            toolItem.addEventListener('animationend', () => toolItem.classList.remove('anim-scale-in-tool'), { once: true });
                        }
                    });
                    return; // End execution here
                }
 
                const toolsToRemove = [];
                const toolsToAdd = [];
 
                // New diffing logic to prioritize removing newest items (at the end of the array)
                const oldWithKept = oldToolIds.map(id => ({ id, kept: false }));
                const tempNewIdsForConsumption = [...newToolIds];
 
                // First pass: find all items that are kept by consuming from tempNewIds
                oldWithKept.forEach(item => {
                    const idxInNew = tempNewIdsForConsumption.indexOf(item.id);
                    if (idxInNew > -1) {
                        item.kept = true;
                        tempNewIdsForConsumption.splice(idxInNew, 1); // Consume it
                    }
                });
 
                // The remaining items in tempNewIds are the ones to add.
                toolsToAdd.push(...tempNewIdsForConsumption);
 
                // Find the indices of the items to remove, prioritizing the newest ones (end of the array).
                for (let i = oldWithKept.length - 1; i >= 0; i--) {
                    if (!oldWithKept[i].kept) {
                        toolsToRemove.push({ id: oldWithKept[i].id, index: i });
                    }
                }

                const hasRemovals = toolsToRemove.length > 0;
                const hasAdditions = toolsToAdd.length > 0;

                // A reorder is needed if the new list is not a perfect prefix of the old list.
                let reorderNeeded = false;
                if (hasRemovals) {
                    let isPrefix = newToolIds.length <= oldToolIds.length;
                    if (isPrefix) {
                        for (let i = 0; i < newToolIds.length; i++) {
                            if (newToolIds[i] !== oldToolIds[i]) {
                                isPrefix = false;
                                break;
                            }
                        }
                    }
                    if (!isPrefix) {
                        reorderNeeded = true;
                    }
                }

                if (hasRemovals) {
                    if (reorderNeeded) {
                        // --- Reorder logic: Animate specific items out, then fade-in the new container state ---
                        const allElements = [...wrapperEl.querySelectorAll(`.${itemClass}`)];
                        toolsToRemove.forEach(item => {
                            const el = allElements[item.index];
                            if (el && !el.classList.contains('anim-tool-disappear')) {
                                el.classList.add('anim-tool-disappear');
                                playToolAnimation(el, isBattleSlot, false);
                            }
                        });

                        setTimeout(() => {
                            wrapperEl.innerHTML = ''; // Clear old layout
                            newToolIds.forEach(toolId => {
                                if (db[toolId]) {
                                    const toolItem = document.createElement('div');
                                    toolItem.className = itemClass;
                                    toolItem.dataset.toolId = toolId;
                                    const toolImg = document.createElement('img');
                                    toolImg.src = getCardImageUrl(toolId);
                                    toolItem.appendChild(toolImg);
                                    wrapperEl.appendChild(toolItem);
                                }
                            });
                            wrapperEl.classList.add('tools-fade-in');
                            wrapperEl.addEventListener('animationend', () => wrapperEl.classList.remove('tools-fade-in'), { once: true });
                        }, 300);
                    } else {
                        // --- No reorder: Just animate the last items out ---
                        const allElements = [...wrapperEl.querySelectorAll(`.${itemClass}`)];
                        toolsToRemove.forEach(item => {
                            const el = allElements[item.index];
                            if (el) {
                                el.classList.add('anim-tool-disappear');
                                playToolAnimation(el, isBattleSlot, false);
                                el.addEventListener('animationend', () => el.remove(), { once: true });
                            }
                        });
                    }
                } else if (hasAdditions) {
                    // --- Additions only ---
                    toolsToAdd.forEach(id => {
                        if (db[id]) {
                            const toolItem = document.createElement('div');
                            toolItem.className = `${itemClass} anim-tool-appear`;
                            toolItem.dataset.toolId = id;
                            const toolImg = document.createElement('img');
                            toolImg.src = getCardImageUrl(id);
                            toolItem.appendChild(toolImg);
                            wrapperEl.appendChild(toolItem);
                            toolItem.addEventListener('animationstart', () => playToolAnimation(toolItem, isBattleSlot, true), { once: true });
                            toolItem.addEventListener('animationend', () => toolItem.classList.remove('anim-tool-appear'), { once: true });
                        }
                    });
                }
            }

            function animateHp(element, startHp, endHp, startMaxHp, endMaxHp, duration) {
                if (!element) return;
                if (startHp === endHp && startMaxHp === endMaxHp) {
                    element.textContent = `${endHp}/${endMaxHp}`;
                    return;
                }
                let startTimestamp = null;
                const step = (timestamp) => {
                    if (!startTimestamp) startTimestamp = timestamp;
                    const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                    const rawCurrentHp = progress * (endHp - startHp) + startHp;
                    const rawCurrentMaxHp = progress * (endMaxHp - startMaxHp) + startMaxHp;
                    let displayHp, displayMaxHp;
                    if (progress < 1) {
                        displayHp = Math.round(rawCurrentHp / 10) * 10;
                        displayMaxHp = Math.round(rawCurrentMaxHp / 10) * 10;
                    } else {
                        displayHp = endHp;
                        displayMaxHp = endMaxHp;
                    }
                    element.textContent = `${displayHp}/${displayMaxHp}`;
                    if (progress < 1) {
                        window.requestAnimationFrame(step);
                    }
                };
                window.requestAnimationFrame(step);
            }

            function displayHpChangeNumber(targetSlotEl, hpChange) {
                if (hpChange === 0) return;
                const isHeal = hpChange > 0;
                const number = Math.abs(hpChange);
                const text = isHeal ? `+${number}` : `${-number}`;
                const isBattleSlot = targetSlotEl.classList.contains('active-slot');
                const numberTypeClass = isHeal ? 'heal-number' : 'damage-number';
                const numberSizeClass = (isHeal ? 'heal-number-bench' : 'damage-number-bench');
                const cardImageSelector = isBattleSlot ? '.battle-card-image-area' : '.bench-card-image-area';
                const cardImageEl = targetSlotEl.querySelector(cardImageSelector);
                if (!cardImageEl) return;
                requestAnimationFrame(() => {
                    const imageRect = cardImageEl.getBoundingClientRect();
                    if (imageRect.width === 0) return;
                    const numberEl = document.createElement('div');
                    numberEl.className = `${numberTypeClass} ${numberSizeClass}`;
                    numberEl.textContent = text;
                    numberEl.style.left = `${imageRect.left + imageRect.width / 2}px`;
                    numberEl.style.top = `${imageRect.top + imageRect.height / 2}px`;
                    document.body.appendChild(numberEl);

                    setTimeout(() => numberEl.remove(), 1500);
                });
            }

            // --- I18n ---
            function updateBodyLanguageClass() {
                const body = document.body;
                // Remove all existing lang- classes
                body.className = body.className.split(' ').filter(c => !c.startsWith('lang-')).join(' ');
                if (language.value) {
                    body.classList.add(`lang-${language.value}`);
                }
            }

            function renderAttachedEnergies(container, energies, getIconHtml) {
                if (!container || !energies) return;

                const getSpecialIconHtml = (cardId) => {
                    const cardData = cardDatabase.value[cardId];
                    const title = cardData ? cardData.name : 'Special Energy';
                    const bgImage = getCardImageUrl(cardId, true);
                    // Note: The class controls the size (battle vs bench)
                    return `<div class="attached-special-energy-icon" style="background-image: ${bgImage}" title="${title}"></div>`;
                };

                const energyCounts = energies.reduce((acc, energy) => {
                    acc[energy] = (acc[energy] || 0) + 1;
                    return acc;
                }, {});

                const totalEnergyCount = energies.length;
                const maxSingleEnergyCount = Object.values(energyCounts).reduce((max, count) => Math.max(max, count), 0);
                const useTypeB = (maxSingleEnergyCount > 1 && totalEnergyCount >= 7) || maxSingleEnergyCount >= 5;
                
                let html = '';
                if (useTypeB) {
                    for (const energy in energyCounts) {
                        const count = energyCounts[energy];
                        let iconHtml;
                        if (energy.startsWith('special:')) {
                            const cardId = energy.substring(8);
                            iconHtml = getSpecialIconHtml(cardId);
                        } else {
                            iconHtml = getIconHtml(energy);
                        }
                        html += `
                            <div class="energy-count-group">
                                ${iconHtml}
                                <span class="energy-count-number">${count}</span>
                            </div>
                        `;
                    }
                } else {
                    html = energies.map(energy => {
                        if (energy.startsWith('special:')) {
                            const cardId = energy.substring(8);
                            return getSpecialIconHtml(cardId);
                        } else {
                            return getIconHtml(energy);
                        }
                    }).join('');
                }
                container.innerHTML = html;
            }



            function renderSlot(side, index, slotData, oldSlotData) {
                const slotEl = document.getElementById(`slot-${side}${index}`);
                const db = cardDatabase.value;
                const settings = settingsRep.value || {};

                const hasCard = slotData && slotData.cardId;
                const forceSlideIn = slotData && slotData.forceSlideIn;
                const skipSlideIn = slotData && slotData.evolutionSelect;
                const isNewCard = hasCard && (!oldSlotData || slotData.cardId !== oldSlotData.cardId);

                const oldToolIds = oldSlotData ? (oldSlotData.attachedToolIds || []) : [];
                const newToolIds = slotData ? slotData.attachedToolIds || [] : [];
                
                const sanitizeDamage = (damage) => {
                    if (typeof damage !== 'string') return damage || '';
                    return damage.replace(/＋/g, '+').replace(/－/g, '-').replace(/×/g, '×');
                };

                if (!slotEl || !slotData || !slotData.cardId || !db || !db[slotData.cardId]) {
                    const isSlidingOut = slotEl.classList.contains('anim-slide-out-L') || slotEl.classList.contains('anim-slide-out-R');

                    const clearSlot = () => {
                        slotEl.innerHTML = '';
                        slotEl.dataset.cardId = '';
                        slotEl.classList.add('is-empty');
                        slotEl.classList.remove('anim-slide-out-L', 'anim-slide-out-R', 'anim-slide-in-L', 'anim-slide-in-R');
                    };

                    if (isSlidingOut) {
                        setTimeout(clearSlot, 500); 
                    } else {
                        clearSlot();
                    }
                    return;
                }
                slotEl.classList.remove('is-empty');

                const cardData = db[slotData.cardId];
                if (!cardData || !cardData.pokemon) return;

                const baseHp = parseInt(cardData.pokemon.hp || 0, 10);
                const extraHp = parseInt(slotData.extraHp || 0, 10);
                const damage = parseInt(slotData.damage || 0, 10);
                const maxHp = baseHp + extraHp;
                const currentHp = Math.max(0, maxHp - damage);
                const hpPercent = maxHp > 0 ? (currentHp / maxHp) * 100 : 0;

                let startHp = currentHp, startMaxHp = maxHp;
                if (oldSlotData) {
                    const oldBaseHp = oldSlotData.cardId && db[oldSlotData.cardId] ? parseInt(db[oldSlotData.cardId].pokemon.hp || 0, 10) : 0;
                    const oldExtraHp = parseInt(oldSlotData.extraHp || 0, 10);
                    startMaxHp = oldBaseHp + oldExtraHp;
                    startHp = Math.max(0, startMaxHp - (parseInt(oldSlotData.damage || 0, 10)));
                }
                const hpChangeToShow = currentHp - startHp;
                const isUnderAttack = g_attackAnimationTargets.has(slotEl.id);
                const isEvolution = slotData && slotData.evolutionSelect;

                let hpColor = 'var(--hp-high)';
                if (hpPercent <= 25) hpColor = 'var(--hp-low)';
                else if (hpPercent <= 50) hpColor = 'var(--hp-medium)';

                const getEnergyIcon = (type) => `<img class="energy-icon" src="/assets/ptcg-telop/icons/${ENERGY_MAP[type] || 'エネなし'}.png">`;
                
                let wrapper = slotEl.querySelector('.bench-pokemon-wrapper');

                const playAnimationIfNeeded = () => {
                    if ((isNewCard || forceSlideIn) && !skipSlideIn) {
                        const needsToWaitForSlideOut = slotEl.classList.contains('anim-slide-out-L') || slotEl.classList.contains('anim-slide-out-R');
                        const delay = needsToWaitForSlideOut ? 500 : 0;
                        setTimeout(() => {
                            const side = slotEl.id.includes('-L') ? 'L' : 'R';
                            slotEl.classList.add(`anim-slide-in-${side}`);
                            setTimeout(() => slotEl.classList.remove(`anim-slide-out-${side}`, `anim-slide-in-${side}`), 500);
                        }, delay);
                    }
                };

                const forceRedraw = !oldSlotData || !wrapper || slotEl.dataset.cardId !== slotData.cardId;
                if (forceRedraw) {
                    slotEl.innerHTML = `
                        <div class="bench-pokemon-wrapper">
                            <div class="bench-card-image-area">
                                <img class="bench-pokemon-image">
                                <div class="bench-attached-energies"></div>
                                <div class="bench-attached-tools-wrapper"></div>
                            </div>
                            <div class="bench-info-area">
                                <div class="bench-pokemon-name">${cardData.name}</div>
                                <div class="bench-hp-gauge">
                                    <div class="bench-hp-bar-container">
                                        <div class="bench-hp-text"></div>
                                        <div class="bench-hp-bar"></div>
                                    </div>
                                </div>
                                <div class="bench-skills-container"></div>
                            </div>
                        </div>`;
                    wrapper = slotEl.querySelector('.bench-pokemon-wrapper');
                    slotEl.dataset.cardId = slotData.cardId;

                    const mainImg = wrapper.querySelector('.bench-pokemon-image');
                    mainImg.style.visibility = 'hidden';
                    mainImg.onload = () => {
                        mainImg.style.visibility = 'visible';
                        playAnimationIfNeeded();
                        mainImg.onload = null; // Clean up handler
                    };
                    mainImg.src = getCardImageUrl(slotData.cardId);
                    mainImg.classList.toggle('is-v', cardData.pokemon && cardData.subtype === 'V');
                } else if (forceSlideIn) {
                    playAnimationIfNeeded();
                }

                const hpUpdate = () => {
                    const hpTextEl = wrapper.querySelector('.bench-hp-text');
                    animateHp(hpTextEl, startHp, currentHp, startMaxHp, maxHp, 500);
                    const hpBarEl = wrapper.querySelector('.bench-hp-bar');
                    hpBarEl.style.width = `${hpPercent}%`;
                    hpBarEl.style.backgroundColor = hpColor;
                    if (hpChangeToShow !== 0 && !isEvolution) {
                        displayHpChangeNumber(slotEl, hpChangeToShow);
                    }
                };

                if (isUnderAttack) { setTimeout(hpUpdate, 1100); } else { hpUpdate(); }

                const skillsContainer = wrapper.querySelector('.bench-skills-container');
                const allSkills = [...(cardData.pokemon.abilities || []), ...(cardData.pokemon.attacks || [])];
                let skillsHtml = '';
                allSkills.slice(0, 2).forEach(skill => {
                    const isAbility = !!skill.text && !skill.cost;
                    const abilityUsedClass = (isAbility && slotData.abilityUsed) ? 'used' : '';
                    let tagHtml = '';
                    if (isAbility) {
                        const abilityIconSrc = resolveAssetPath('ability_jp.png', true);
                        tagHtml = `<img src="${abilityIconSrc}" class="bench-skill-ability-tag ${abilityUsedClass}" alt="Ability">`;
                    } else {
                        const cost = skill.cost || [];
                        const iconsToRender = cost.length > 0 ? cost : [null];
                        const iconsHtml = iconsToRender.map(getEnergyIcon).join('');
                        tagHtml = `<div class="bench-energy-cost-container">${iconsHtml}</div>`;
                    }
                    skillsHtml += `
                        <div class="bench-skill-row-wrapper">
                            ${tagHtml}
                            <div class="bench-skill">
                                <div class="bench-skill-name-wrapper"><span class="bench-skill-name ${isAbility ? 'is-ability' : ''} ${abilityUsedClass}">${skill.name}</span></div>
                                <div class="bench-skill-damage">${sanitizeDamage(skill.damage) || ''}</div>
                            </div>
                        </div>`;
                });
                skillsContainer.innerHTML = skillsHtml;

                const energyContainer = wrapper.querySelector('.bench-attached-energies');
                renderAttachedEnergies(energyContainer, slotData.attachedEnergy, getEnergyIcon);

                updateAttachedTools(slotEl, newToolIds, oldToolIds, false, forceRedraw); // isBattleSlot is always false here

                if (slotData && slotData.evolutionSelect) {
                    delete slotData.evolutionSelect;
                } // Clear the evolutionSelect flag after rendering
                if (slotData && slotData.forceSlideIn) {
                    delete slotData.forceSlideIn;
                }
            }
            
            // Preload all FX videos and images on page load
            const videosToPreload = [
                '/assets/ptcg-telop/fx/bench_ko.webm',
                '/assets/ptcg-telop/fx/bench-replace.webm',
                '/assets/ptcg-telop/fx/bench-devolve.webm',
                '/assets/ptcg-telop/fx/bench-evolve.webm',
                '/assets/ptcg-telop/fx/bench-mega-evolve.webm',
                '/assets/ptcg-telop/fx/bench-tera-evolve.webm',
                '/assets/ptcg-telop/fx/tool-attach.webm',
                '/assets/ptcg-telop/fx/tool-remove.webm'
            ];
            const imagesToPreload = [
                '/assets/ptcg-telop/element/extra-bg.png',
                '/assets/ptcg-telop/element/bench-bg.png'
            ];

            const preloaderContainer = document.getElementById('video-preloader');
            if (preloaderContainer) {
                videosToPreload.forEach(src => {
                    const video = document.createElement('video');
                    video.src = src;
                    video.preload = 'auto';
                    video.muted = true;
                    video.load();
                    preloaderContainer.appendChild(video);
                });

                imagesToPreload.forEach(src => {
                    const img = document.createElement('img');
                    img.src = src;
                    preloaderContainer.appendChild(img);
                });
            }

            function playVideoOnSlot(targetEl, videoSrc) {
                const imageSelector = '.bench-pokemon-image';
                const cardImage = targetEl.querySelector(imageSelector);
                const targetRect = targetEl.getBoundingClientRect();
                const videoContainer = document.createElement('div');
                videoContainer.style.position = 'absolute';
                videoContainer.style.left = `${targetRect.left}px`;
                videoContainer.style.top = `${targetRect.top}px`;
                videoContainer.style.width = `${targetRect.width}px`;
                videoContainer.style.height = `${targetRect.height}px`;
                videoContainer.style.zIndex = '300';
                videoContainer.style.overflow = 'hidden';
                const video = document.createElement('video');
                video.src = videoSrc;
                video.muted = true;
                video.style.width = '100%';
                video.style.height = '100%';
                videoContainer.appendChild(video);
                document.body.appendChild(videoContainer);
                video.play();
                setTimeout(() => { if (cardImage) cardImage.style.visibility = 'hidden'; }, REPLACE_ANIMATION_HIDE_MS);
                setTimeout(() => { if (cardImage) cardImage.style.visibility = 'visible'; }, REPLACE_ANIMATION_SHOW_MS);
                video.addEventListener('ended', () => videoContainer.remove());
            }

            const cardDatabase = nodecg.Replicant('cardDatabase');
            const settingsRep = nodecg.Replicant('ptcg-settings');
            const assetPaths = nodecg.Replicant('assetPaths');
            const deckL = nodecg.Replicant('deckL');
            const deckR = nodecg.Replicant('deckR');
            const language = nodecg.Replicant('language');
            const themeAssets = nodecg.Replicant('themeAssets');
            const i18nStrings = nodecg.Replicant('i18nStrings');

            function resolveAssetPath(assetName, isLangSpecific = false) {
                const settings = settingsRep.value || {};
                const assets = themeAssets.value || {};
                const lang = language.value || 'jp';
                const basePath = '/assets/ptcg-telop/';
                const activeTheme = settings.activeTheme || 'Default';

                const potentialPath = assetName.replace(/url\((['\"]?)(.*?)\1\)/, '$2');
                const cleanAssetName = potentialPath.split('/').pop();

                if (activeTheme !== 'Default' && assets[activeTheme] && assets[activeTheme].includes(cleanAssetName)) {
                    return `${basePath}${activeTheme}/${cleanAssetName}`;
                }

                if (isLangSpecific) {
                    const baseName = assetName.replace(/_jp\.png$/, '');
                    const langAssetName = `${baseName}_${lang}.png`;
                    return `${basePath}element/${langAssetName}`;
                }
                
                return `${basePath}element/${assetName}`;
            }

            function updateCustomizableAssets() {
                const root = document.documentElement;
                root.style.setProperty('--asset-extra-bg', `url(${resolveAssetPath('extra-bg.png')})`);
                root.style.setProperty('--asset-bench-bg', `url(${resolveAssetPath('bench-bg.png')})`);
                
                const abilityIconSrc = resolveAssetPath('ability_jp.png', true);
                document.querySelectorAll('.bench-skill-ability-tag').forEach(img => {
                    if(img.src !== abilityIconSrc) img.src = abilityIconSrc;
                });
            }

            const activeThemeCss = nodecg.Replicant('activeThemeCss');
            activeThemeCss.on('change', (newUrl) => {
                const themeCssLink = document.getElementById('theme-css-link');
                if (themeCssLink) {
                    if (newUrl) {
                        themeCssLink.href = newUrl;
                        themeCssLink.disabled = false;
                    } else {
                        themeCssLink.disabled = true;
                        themeCssLink.href = '';
                    }
                }
                updateCustomizableAssets();
            });

            const replicantList = [cardDatabase, settingsRep, assetPaths, deckL, deckR, language, activeThemeCss];
            const sides = ['L', 'R'];

            for (let i = 6; i <= 8; i++) {
                sides.forEach(side => {
                    replicantList.push(nodecg.Replicant(`live_slot${side}${i}`));
                });
            }
            
            function getHitVideoSrc(attackerType) {
                const basePath = '/assets/ptcg-telop/fx/';
                const typeMap = {
                    "草": "grass",
                    "炎": "fire",
                    "水": "water",
                    "雷": "lightning",
                    "超": "psychic",
                    "闘": "fighting",
                    "悪": "darkness",
                    "鋼": "metal",
                    "竜": "dragon",
                    "妖": "fairy",
                    "無": "colorless"
                };
                const typeString = typeMap[attackerType] || 'colorless';
                return `${basePath}hit-${typeString}.webm`;
            }

            NodeCG.waitForReplicants(...replicantList, themeAssets, i18nStrings).then(() => {
                // handleThemeChange is replaced by the activeThemeCss listener
                updateBodyLanguageClass();

                settingsRep.on('change', (newValue, oldValue) => {
                    const newSettings = newValue || {};
                    const oldSettings = oldValue || {};

                    // activeTheme change is handled by the activeThemeCss listener

                    if (newSettings.language !== oldSettings.language) {
                        updateCustomizableAssets();
                        updateBodyLanguageClass();
                    }
                });

                const preloaderContainer = document.getElementById('video-preloader');
                function preloadDeckImages(deck) {
                    if (!deck || !deck.cards || !assetPaths.value.cardImgPath || !preloaderContainer) return;

                    deck.cards.forEach(cardId => {
                        const fullPath = getCardImageUrl(cardId);
                        if (fullPath && !preloaderContainer.querySelector(`img[src="${fullPath}"]`)) {
                            const img = document.createElement('img');
                            img.src = fullPath;
                            preloaderContainer.appendChild(img);
                        }
                    });
                }

                // Initial preload for both decks
                preloadDeckImages(deckL.value);
                preloadDeckImages(deckR.value);

                // Listen for changes in both decks
                deckL.on('change', (newVal) => preloadDeckImages(newVal));
                deckR.on('change', (newVal) => preloadDeckImages(newVal));

                for (let i = 6; i <= 8; i++) {
                    sides.forEach(side => {
                        const replicant = nodecg.Replicant(`live_slot${side}${i}`);
                        replicant.on('change', (newVal, oldVal) => {
                            if (!oldVal) {
                                return;
                            }
                            renderSlot(side, i, newVal, oldVal);
                        });
                        renderSlot(side, i, replicant.value, null);
                    });
                }

                assetPaths.on('change', () => {
                    for (let i = 6; i <= 8; i++) {
                        sides.forEach(side => {
                            const replicant = nodecg.Replicant(`live_slot${side}${i}`);
                            renderSlot(side, i, replicant.value, null);
                        });
                    }
                });

                nodecg.listenFor('attack-fx', (data) => {
                    if (!data || !data.targets) return;

                    const targetsInThisGraphic = data.targets.filter(t => {
                        return !!document.getElementById(t.targetId.replace('slot', 'slot-'));
                    });

                    if (targetsInThisGraphic.length === 0) return;

                    targetsInThisGraphic.forEach(targetInfo => {
                        const targetEl = document.getElementById(targetInfo.targetId.replace('slot', 'slot-'));
                        if (targetEl) {
                            g_attackAnimationTargets.add(targetEl.id);
                        }
                    });

                    setTimeout(() => {
                        let animationsToEnd = targetsInThisGraphic.length;
                        const onHitAnimationEnd = () => {
                            animationsToEnd--;
                            if (animationsToEnd === 0) {
                                g_attackAnimationTargets.clear();
                            }
                        };

                        targetsInThisGraphic.forEach(targetInfo => {
                            const targetEl = document.getElementById(targetInfo.targetId.replace('slot', 'slot-'));
                            if (!targetEl) {
                                onHitAnimationEnd();
                                return;
                            }

                            const cardImageSelector = '.bench-card-image-area';
                            const cardImageEl = targetEl.querySelector(cardImageSelector);
                            if (cardImageEl) {
                                cardImageEl.classList.add('anim-shake', 'anim-flash-white');
                                setTimeout(() => cardImageEl.classList.remove('anim-shake', 'anim-flash-white'), 400);
                                
                                const imageRect = cardImageEl.getBoundingClientRect();
                                const videoSize = 200;
                                const hitVideo = document.createElement('video');
                                hitVideo.className = 'hit-effect'; // Use class from main.html
                                hitVideo.src = getHitVideoSrc(data.attackerType);
                                hitVideo.muted = true;
                                hitVideo.autoplay = true; // Revert to autoplay like main.html
                                hitVideo.style.width = `${videoSize}px`;
                                hitVideo.style.height = `${videoSize}px`;
                                hitVideo.style.left = `${imageRect.left + (imageRect.width / 2) - (videoSize / 2)}px`;
                                hitVideo.style.top = `${imageRect.top + (imageRect.height / 2) - (videoSize / 2)}px`;
                                document.body.appendChild(hitVideo);
                                
                                hitVideo.addEventListener('ended', () => {
                                    hitVideo.remove();
                                    onHitAnimationEnd();
                                });
                            } else {
                                onHitAnimationEnd();
                            }
                        });
                    }, 1000);
                });

                nodecg.listenFor('playAnimation', (animation) => {
                    if (!animation || !animation.type) {
                        console.error('Invalid animation data received:', animation);
                        return;
                    }

                    if (animation.type === 'SWITCH_POKEMON') {
                        if (!animation.source || !animation.target) {
                            console.error('Invalid PROMOTE animation data:', animation);
                            return;
                        }
                        const sourceEl = document.getElementById(animation.source);
                        const targetEl = document.getElementById(animation.target);

                        if (sourceEl && !sourceEl.classList.contains('is-empty')) {
                            const side = animation.source.includes('-L') ? 'L' : 'R';
                            sourceEl.classList.add(`anim-slide-out-${side}`);
                        }
                        if (targetEl && !targetEl.classList.contains('is-empty')) {
                            const side = animation.target.includes('-L') ? 'L' : 'R';
                            targetEl.classList.add(`anim-slide-out-${side}`);
                        }
                        return; // End PROMOTE logic here.
                    }

                    // For all other animations, target is required and must be in this document.
                    if (!animation.target) {
                        console.error('Animation requires a target:', animation);
                        return;
                    }
                    const targetEl = document.getElementById(animation.target);
                    if (!targetEl) {
                        // This is expected if the target is in the other graphic, so don't log an error.
                        return;
                    }
                    const side = animation.target.includes('-L') ? 'L' : 'R';
                    targetEl.classList.remove(`anim-slide-in-${side}`, `anim-slide-out-${side}`);

                    if (animation.type === 'EVOLVE_POKEMON') {
                        const db = cardDatabase.value;
                        // All slots in extra.html are bench slots.
                        let videoSrc = '/assets/ptcg-telop/fx/bench-evolve.webm';

                        // Check for Mega Evolution or Terastal
                        if (animation.cardId && db && db[animation.cardId]) {
                            const cardData = db[animation.cardId];
                            if (cardData.pokemon && cardData.pokemon.option) {
                                const option = cardData.pokemon.option.toLowerCase();
                                if (option === 'mega') {
                                    videoSrc = '/assets/ptcg-telop/fx/bench-mega-evolve.webm';
                                } else if (option === 'terastal') {
                                    videoSrc = '/assets/ptcg-telop/fx/bench-tera-evolve.webm';
                                }
                            }
                        }
                        playVideoOnSlot(targetEl, videoSrc);
                    } else if (animation.type === 'DEVOLVE_POKEMON') {
                        const videoSrc = '/assets/ptcg-telop/fx/bench-devolve.webm';
                        playVideoOnSlot(targetEl, videoSrc);
                    } else if (animation.type === 'REPLACE_POKEMON') {
                        const videoSrc = '/assets/ptcg-telop/fx/bench-replace.webm';
                        playVideoOnSlot(targetEl, videoSrc);
                    } else if (animation.type === 'KO_POKEMON') {
                        const videoSrc = '/assets/ptcg-telop/fx/bench_ko.webm';
                        const imageSelector = '.bench-pokemon-image';
                        const koVideo = document.createElement('video');
                        koVideo.src = videoSrc;
                        koVideo.muted = true;
                        koVideo.style.position = 'absolute';
                        koVideo.style.width = '100%';
                        koVideo.style.height = '100%';
                        koVideo.style.left ='-4px';
                        koVideo.style.top = '0';
                        koVideo.style.zIndex = '200';
                        targetEl.appendChild(koVideo);
                        koVideo.play();
                        setTimeout(() => {
                            const cardImage = targetEl.querySelector(imageSelector);
                            if (cardImage) cardImage.style.visibility = 'hidden';
                        }, 85);
                        koVideo.addEventListener('ended', () => {
                            koVideo.remove();
                            targetEl.classList.add(`anim-slide-out-${side}`);
                        });
                    } else if (animation.type === 'ATTACH_TOOL' || animation.type === 'REMOVE_TOOL') {
                        const isAttach = animation.type === 'ATTACH_TOOL';
                        // The new logic handles this inside updateAttachedTools, so we can simplify here.
                        const toolSelector = '.bench-attached-tool';
                        const toolEl = targetEl.querySelector(toolSelector);
                        if (!toolEl) {
                            console.error('Could not find tool element for animation:', animation.target);
                            return;
                        }
                        requestAnimationFrame(() => {
                            // The animation is now triggered by the replicant change in renderSlot.
                            // The 'playAnimation' message is now just a trigger for the data change.
                        });
                    } else if (animation.type === 'EXIT_POKEMON') {
                        targetEl.classList.add(`anim-slide-out-${side}`);
                    } else if (animation.type === 'ENTER_POKEMON') {
                        targetEl.classList.remove('anim-slide-out-L', 'anim-slide-out-R');
                        const animationClass = `anim-slide-in-${side}`;
                        targetEl.classList.add(animationClass);
                        targetEl.addEventListener('animationend', () => {
                            targetEl.classList.remove(animationClass);
                        }, { once: true });
                    }
                });

                // Fallback cleanup for animation state
                nodecg.listenFor('attack-fx-complete', () => {
                    activeAnimations.clear();
                    g_attackAnimationTargets.clear();
                });
                });
            });
    </script>
</body>
</html>