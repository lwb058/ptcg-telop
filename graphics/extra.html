<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Extra Bench Graphic</title>
    <link rel="stylesheet" href="css/fonts.css">
    <link rel="stylesheet" href="css/shared_graphics.css">
    <style>
        .player-area { 
            width: 406px; 
            height: 560px; 
            transform: translateY(475px);
            display: flex; 
            flex-direction: column; 
            padding: 5px; 
            box-sizing: border-box; 
            background-color: var(--color-bg-panel); 
            background-image: url('/assets/ptcg-telop/element/extra-bg.png');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
        }
        .bench-slots { gap: 24px; } /* Override default gap */
        .extra-bench-title {
            height: 64px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Dela Gothic One', sans-serif;
            font-size: 32px;
            font-style: italic;
            letter-spacing: 3px;
            color: var(--module-border);
            background-color: var(--third-color);
            border-radius: 20px;
            margin: 8px;
            margin-top: 36px;
            margin-bottom: 36px;
            box-sizing: border-box;
            visibility: hidden;
        }

        /* --- Animation Styles --- */
        #animation-wrapper-L,
        #animation-wrapper-R {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="overlay-frame">
        <div id="animation-wrapper-L">
            <div class="player-area" id="player-L-area">
                <div class="extra-bench-title">EXTRA BENCH</div>
                <div class="bench-slots">
                    <div class="bench-slot" id="slot-L6"></div>
                    <div class="bench-slot" id="slot-L7"></div>
                    <div class="bench-slot" id="slot-L8"></div>
                </div>
            </div>
        </div>
        <div id="animation-wrapper-R">
            <div class="player-area" id="player-R-area">
                <div class="extra-bench-title">EXTRA BENCH</div>
                <div class="bench-slots">
                    <div class="bench-slot" id="slot-R6"></div>
                    <div class="bench-slot" id="slot-R7"></div>
                    <div class="bench-slot" id="slot-R8"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Preloader Container for FX Videos (Hidden) -->
    <div id="video-preloader"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const getCardImageUrl = (cardId, isBgImage = false) => {
                if (!cardId || !assetPaths.value.cardImgPath) {
                    return isBgImage ? 'none' : '';
                }
                const db = cardDatabase.value;
                const cardData = db ? db[cardId] : null;
                const imageUrl = cardData ? cardData.image_url : null;
                const extension = imageUrl ? imageUrl.substring(imageUrl.lastIndexOf('.')) : '.jpg'; // Fallback to .jpg
                const path = `/${assetPaths.value.cardImgPath}${cardId}${extension}`;
                return isBgImage ? `url(${path})` : path;
            };
            const ENERGY_MAP = { "草": "草", "炎": "炎", "水": "水", "雷": "雷", "超": "超", "闘": "闘", "悪": "悪", "鋼": "鋼", "無": "無", "全": "全", "超悪": "超悪", "竜": "竜", "妖": "妖" };
            // Animation Timings
            const REPLACE_ANIMATION_HIDE_MS = 550;
            const REPLACE_ANIMATION_SHOW_MS = 700;
            const g_attackAnimationTargets = new Set();
            const activeAnimations = new Map();

            // --- Animation Control ---
            const animationWrapperL = document.getElementById('animation-wrapper-L');
            const animationWrapperR = document.getElementById('animation-wrapper-R');
            const extraBenchVisible = nodecg.Replicant('extraBenchVisible', { defaultValue: { left: false, right: false } });

            const visibilityState = {
                left: { isVisible: false, isAnimating: false },
                right: { isVisible: false, isAnimating: false }
            };

            function onAnimationEnd(element) {
                return new Promise(resolve => {
                    element.addEventListener('animationend', resolve, { once: true });
                });
            }

            async function handleVisibility(side, wantsToShow) {
                const state = side === 'L' ? visibilityState.left : visibilityState.right;
                const wrapper = side === 'L' ? animationWrapperL : animationWrapperR;
                const animInClass = `anim-slide-in-${side}`;
                const animOutClass = `anim-slide-out-${side}`;

                if (state.isAnimating || state.isVisible === wantsToShow) {
                    return;
                }
                state.isAnimating = true;

                try {
                    if (wantsToShow) {
                        wrapper.classList.remove(animOutClass);
                        wrapper.classList.add(animInClass);
                        await onAnimationEnd(wrapper);
                        state.isVisible = true;
                    } else {
                        wrapper.classList.remove(animInClass);
                        wrapper.classList.add(animOutClass);
                        await onAnimationEnd(wrapper);
                        state.isVisible = false;
                    }
                } finally {
                    state.isAnimating = false;
                }
            }

            extraBenchVisible.on('change', (newValue) => {
                if (!newValue) return;
                handleVisibility('L', newValue.left);
                handleVisibility('R', newValue.right);
            });

            function playToolAnimation(targetEl, isBattleSlot, isAttach) {

                const videoSrc = isAttach ? '/assets/ptcg-telop/fx/tool-attach.webm' : '/assets/ptcg-telop/fx/tool-remove.webm';
                const targetRect = targetEl.getBoundingClientRect();
                if (targetRect.width === 0 && targetRect.height === 0) return;

                const video = document.createElement('video');
                video.src = videoSrc;
                video.muted = true;
                video.autoplay = true;
                video.style.position = 'absolute';
                video.style.zIndex = '400';
                video.style.pointerEvents = 'none';

                const videoWidth = 70;
                const videoHeight = 56;
                video.style.width = `${videoWidth}px`;
                video.style.height = `${videoHeight}px`;

                const targetCenterX = targetRect.left + targetRect.width / 2;
                const targetCenterY = targetRect.top + targetRect.height / 2;
                video.style.left = `${targetCenterX - videoWidth / 2}px`;
                video.style.top = `${targetCenterY - videoHeight / 2}px`;

                document.body.appendChild(video);
                video.addEventListener('ended', () => video.remove());
            }
            function updateAttachedTools(slotEl, newToolIds, oldToolIds, isBattleSlot, forceRedraw = false) {
                const db = cardDatabase.value;
                const wrapperSelector = '.bench-attached-tools-wrapper';
                const itemClass = 'bench-attached-tool-item';
                const wrapperEl = slotEl.querySelector('.bench-attached-tools-wrapper');
                if (!wrapperEl) return;

                // If a forceRedraw is needed (because the parent DOM was wiped), skip diffing and just render the new state.
                if (forceRedraw) {
                    wrapperEl.innerHTML = ''; // Clear any previous content
                    newToolIds.forEach(id => {
                        if (db[id]) {
                            const toolItem = document.createElement('div');
                            // Use a simple scale-in animation for this redraw case to avoid complexity.
                            toolItem.className = `${itemClass} anim-scale-in-tool`;
                            toolItem.dataset.toolId = id;
                            const toolImg = document.createElement('img');
                            toolImg.src = getCardImageUrl(id);
                            toolItem.appendChild(toolImg);
                            wrapperEl.appendChild(toolItem);
                            toolItem.addEventListener('animationend', () => toolItem.classList.remove('anim-scale-in-tool'), { once: true });
                        }
                    });
                    return; // End execution here
                }
 
                const toolsToRemove = [];
                const toolsToAdd = [];
 
                // New diffing logic to prioritize removing newest items (at the end of the array)
                const oldWithKept = oldToolIds.map(id => ({ id, kept: false }));
                const tempNewIdsForConsumption = [...newToolIds];
 
                // First pass: find all items that are kept by consuming from tempNewIds
                oldWithKept.forEach(item => {
                    const idxInNew = tempNewIdsForConsumption.indexOf(item.id);
                    if (idxInNew > -1) {
                        item.kept = true;
                        tempNewIdsForConsumption.splice(idxInNew, 1); // Consume it
                    }
                });
 
                // The remaining items in tempNewIds are the ones to add.
                toolsToAdd.push(...tempNewIdsForConsumption);
 
                // Find the indices of the items to remove, prioritizing the newest ones (end of the array).
                for (let i = oldWithKept.length - 1; i >= 0; i--) {
                    if (!oldWithKept[i].kept) {
                        toolsToRemove.push({ id: oldWithKept[i].id, index: i });
                    }
                }

                const hasRemovals = toolsToRemove.length > 0;
                const hasAdditions = toolsToAdd.length > 0;

                // A reorder is needed if the new list is not a perfect prefix of the old list.
                let reorderNeeded = false;
                if (hasRemovals) {
                    let isPrefix = newToolIds.length <= oldToolIds.length;
                    if (isPrefix) {
                        for (let i = 0; i < newToolIds.length; i++) {
                            if (newToolIds[i] !== oldToolIds[i]) {
                                isPrefix = false;
                                break;
                            }
                        }
                    }
                    if (!isPrefix) {
                        reorderNeeded = true;
                    }
                }

                if (hasRemovals) {
                    if (reorderNeeded) {
                        // --- Reorder logic: Animate specific items out, then fade-in the new container state ---
                        const allElements = [...wrapperEl.querySelectorAll(`.${itemClass}`)];
                        toolsToRemove.forEach(item => {
                            const el = allElements[item.index];
                            if (el && !el.classList.contains('anim-tool-disappear')) {
                                el.classList.add('anim-tool-disappear');
                                playToolAnimation(el, isBattleSlot, false);
                            }
                        });

                        setTimeout(() => {
                            wrapperEl.innerHTML = ''; // Clear old layout
                            newToolIds.forEach(toolId => {
                                if (db[toolId]) {
                                    const toolItem = document.createElement('div');
                                    toolItem.className = itemClass;
                                    toolItem.dataset.toolId = toolId;
                                    const toolImg = document.createElement('img');
                                    toolImg.src = getCardImageUrl(toolId);
                                    toolItem.appendChild(toolImg);
                                    wrapperEl.appendChild(toolItem);
                                }
                            });
                            wrapperEl.classList.add('tools-fade-in');
                            wrapperEl.addEventListener('animationend', () => wrapperEl.classList.remove('tools-fade-in'), { once: true });
                        }, 300);
                    } else {
                        // --- No reorder: Just animate the last items out ---
                        const allElements = [...wrapperEl.querySelectorAll(`.${itemClass}`)];
                        toolsToRemove.forEach(item => {
                            const el = allElements[item.index];
                            if (el) {
                                el.classList.add('anim-tool-disappear');
                                playToolAnimation(el, isBattleSlot, false);
                                el.addEventListener('animationend', () => el.remove(), { once: true });
                            }
                        });
                    }
                } else if (hasAdditions) {
                    // --- Additions only ---
                    toolsToAdd.forEach(id => {
                        if (db[id]) {
                            const toolItem = document.createElement('div');
                            toolItem.className = `${itemClass} anim-tool-appear`;
                            toolItem.dataset.toolId = id;
                            const toolImg = document.createElement('img');
                            toolImg.src = getCardImageUrl(id);
                            toolItem.appendChild(toolImg);
                            wrapperEl.appendChild(toolItem);
                            toolItem.addEventListener('animationstart', () => playToolAnimation(toolItem, isBattleSlot, true), { once: true });
                            toolItem.addEventListener('animationend', () => toolItem.classList.remove('anim-tool-appear'), { once: true });
                        }
                    });
                }
            }

            function animateHp(element, from, to, fromMax, toMax, duration) {
                if (!element) return;
                let start = null;
                const animate = (timestamp) => {
                    if (!start) start = timestamp;
                    const progress = Math.min((timestamp - start) / duration, 1);
                    const currentVal = Math.round(from + (to - from) * progress);
                    const currentMaxVal = Math.round(fromMax + (toMax - fromMax) * progress);
                   
                    element.textContent = `${currentVal}/${currentMaxVal}`;
                };
                requestAnimationFrame(animate);
            }

            function displayHpChangeNumber(targetSlotEl, hpChange) {
                if (hpChange === 0) return;
                const isHeal = hpChange > 0;
                const number = Math.abs(hpChange);
                const text = isHeal ? `+${number}` : `${-number}`;
                const isBattleSlot = targetSlotEl.classList.contains('active-slot');
                const numberTypeClass = isHeal ? 'heal-number' : 'damage-number';
                const numberSizeClass = (isHeal ? 'heal-number-bench' : 'damage-number-bench');
                const cardImageSelector = isBattleSlot ? '.battle-card-image-area' : '.bench-card-image-area';
                const cardImageEl = targetSlotEl.querySelector(cardImageSelector);
                if (!cardImageEl) return;
                requestAnimationFrame(() => {
                    const imageRect = cardImageEl.getBoundingClientRect();
                    if (imageRect.width === 0) return;
                    const numberEl = document.createElement('div');
                    numberEl.className = `${numberTypeClass} ${numberSizeClass}`;
                    numberEl.textContent = text;
                    numberEl.style.left = `${imageRect.left + imageRect.width / 2}px`;
                    numberEl.style.top = `${imageRect.top + imageRect.height / 2}px`;
                    document.body.appendChild(numberEl);

                    setTimeout(() => numberEl.remove(), 1500);
                });
            }

            function renderAttachedEnergies(container, energies, getIconHtml) {
                if (!container || !energies) return;
                const energyCounts = energies.reduce((acc, energy) => { acc[energy] = (acc[energy] || 0) + 1; return acc; }, {});
                const totalEnergyCount = energies.length;
                const maxSingleEnergyCount = Object.values(energyCounts).reduce((max, count) => Math.max(max, count), 0);
                const useTypeB = (maxSingleEnergyCount > 1 && totalEnergyCount >= 7) || maxSingleEnergyCount >= 5;
                let html = '';
                if (useTypeB) {
                    for (const type in energyCounts) {
                        html += `<div class="energy-count-group">${getIconHtml(type)}<span class="energy-count-number">${energyCounts[type]}</span></div>`;
                    }
                } else {
                    html = energies.map(getIconHtml).join('');
                }
                container.innerHTML = html;
            }

            function renderSlot(side, index, slotData, oldSlotData) {
                const slotEl = document.getElementById(`slot-${side}${index}`);
                const db = cardDatabase.value;
                const settings = settingsRep.value || {};

                const hasCard = slotData && slotData.cardId;
                const forceSlideIn = slotData && slotData.forceSlideIn;
                const skipSlideIn = slotData && slotData.evolutionSelect;
                const isNewCard = hasCard && (!oldSlotData || slotData.cardId !== oldSlotData.cardId);

                const oldToolIds = oldSlotData ? (oldSlotData.attachedToolIds || []) : [];
                const newToolIds = slotData ? slotData.attachedToolIds || [] : [];
                
                const sanitizeDamage = (damage) => {
                    if (typeof damage !== 'string') return damage || '';
                    return damage.replace(/＋/g, '+').replace(/－/g, '-').replace(/×/g, '×');
                };

                if (!slotEl || !slotData || !slotData.cardId || !db || !db[slotData.cardId]) {
                    const isSlidingOut = slotEl.classList.contains('anim-slide-out-L') || slotEl.classList.contains('anim-slide-out-R');

                    const clearSlot = () => {
                        slotEl.innerHTML = '';
                        slotEl.dataset.cardId = '';
                        slotEl.classList.add('is-empty');
                        slotEl.classList.remove('anim-slide-out-L', 'anim-slide-out-R', 'anim-slide-in-L', 'anim-slide-in-R');
                    };

                    if (isSlidingOut) {
                        setTimeout(clearSlot, 500); 
                    } else {
                        clearSlot();
                    }
                    return;
                }
                slotEl.classList.remove('is-empty');

                const cardData = db[slotData.cardId];
                if (!cardData || !cardData.pokemon) return;

                const baseHp = parseInt(cardData.pokemon.hp || 0, 10);
                const extraHp = parseInt(slotData.extraHp || 0, 10);
                const damage = parseInt(slotData.damage || 0, 10);
                const maxHp = baseHp + extraHp;
                const currentHp = Math.max(0, maxHp - damage);
                const hpPercent = maxHp > 0 ? (currentHp / maxHp) * 100 : 0;

                let startHp = currentHp, startMaxHp = maxHp;
                if (oldSlotData) {
                    const oldBaseHp = oldSlotData.cardId && db[oldSlotData.cardId] ? parseInt(db[oldSlotData.cardId].pokemon.hp || 0, 10) : 0;
                    const oldExtraHp = parseInt(oldSlotData.extraHp || 0, 10);
                    startMaxHp = oldBaseHp + oldExtraHp;
                    startHp = Math.max(0, startMaxHp - (parseInt(oldSlotData.damage || 0, 10)));
                }
                const hpChangeToShow = currentHp - startHp;
                const isUnderAttack = g_attackAnimationTargets.has(slotEl.id);
                const isEvolution = slotData && slotData.evolutionSelect;

                let hpColor = 'var(--hp-high)';
                if (hpPercent <= 25) hpColor = 'var(--hp-low)';
                else if (hpPercent <= 50) hpColor = 'var(--hp-medium)';

                const getEnergyIcon = (type) => `<img class="energy-icon" src="/assets/ptcg-telop/energy/${ENERGY_MAP[type] || 'エネなし'}.png">`;
                
                let wrapper = slotEl.querySelector('.bench-pokemon-wrapper');

                const playAnimationIfNeeded = () => {
                    if ((isNewCard || forceSlideIn) && !skipSlideIn) {
                        const needsToWaitForSlideOut = slotEl.classList.contains('anim-slide-out-L') || slotEl.classList.contains('anim-slide-out-R');
                        const delay = needsToWaitForSlideOut ? 500 : 0;
                        setTimeout(() => {
                            const side = slotEl.id.includes('-L') ? 'L' : 'R';
                            slotEl.classList.add(`anim-slide-in-${side}`);
                            setTimeout(() => slotEl.classList.remove(`anim-slide-out-${side}`, `anim-slide-in-${side}`), 500);
                        }, delay);
                    }
                };

                const forceRedraw = !oldSlotData || !wrapper || slotEl.dataset.cardId !== slotData.cardId;
                if (forceRedraw) {
                    slotEl.innerHTML = `
                        <div class="bench-pokemon-wrapper">
                            <div class="bench-card-image-area">
                                <img class="bench-pokemon-image">
                                <div class="bench-attached-energies"></div>
                                <div class="bench-attached-tools-wrapper"></div>
                            </div>
                            <div class="bench-info-area">
                                <div class="bench-pokemon-name">${cardData.name}</div>
                                <div class="bench-hp-gauge">
                                    <div class="bench-hp-bar-container">
                                        <div class="bench-hp-text"></div>
                                        <div class="bench-hp-bar"></div>
                                    </div>
                                </div>
                                <div class="bench-skills-container"></div>
                            </div>
                        </div>`;
                    wrapper = slotEl.querySelector('.bench-pokemon-wrapper');
                    slotEl.dataset.cardId = slotData.cardId;

                    const mainImg = wrapper.querySelector('.bench-pokemon-image');
                    mainImg.style.visibility = 'hidden';
                    mainImg.onload = () => {
                        mainImg.style.visibility = 'visible';
                        playAnimationIfNeeded();
                        mainImg.onload = null; // Clean up handler
                    };
                    mainImg.src = getCardImageUrl(slotData.cardId);
                    mainImg.classList.toggle('is-v', cardData.pokemon && cardData.subtype === 'V');
                } else if (forceSlideIn) {
                    playAnimationIfNeeded();
                }

                const hpUpdate = () => {
                    const hpTextEl = wrapper.querySelector('.bench-hp-text');
                    animateHp(hpTextEl, startHp, currentHp, startMaxHp, maxHp, 500);
                    const hpBarEl = wrapper.querySelector('.bench-hp-bar');
                    hpBarEl.style.width = `${hpPercent}%`;
                    hpBarEl.style.backgroundColor = hpColor;
                    if (hpChangeToShow !== 0 && !isEvolution) {
                        displayHpChangeNumber(slotEl, hpChangeToShow);
                    }
                };

                if (isUnderAttack) { setTimeout(hpUpdate, 1100); } else { hpUpdate(); }

                const skillsContainer = wrapper.querySelector('.bench-skills-container');
                const allSkills = [...(cardData.pokemon.abilities || []), ...(cardData.pokemon.attacks || [])];
                let skillsHtml = '';
                allSkills.slice(0, 2).forEach(skill => {
                    const isAbility = !!skill.text && !skill.cost;
                    const abilityUsedClass = (isAbility && slotData.abilityUsed) ? 'used' : '';
                    let tagHtml = '';
                    if (isAbility) {
                        tagHtml = `<span class="bench-skill-ability-tag ${abilityUsedClass}">特 性</span>`;
                    } else {
                        const cost = skill.cost || [];
                        const iconsToRender = cost.length > 0 ? cost : [null];
                        const iconsHtml = iconsToRender.map(getEnergyIcon).join('');
                        tagHtml = `<div class="bench-energy-cost-container">${iconsHtml}</div>`;
                    }
                    skillsHtml += `
                        <div class="bench-skill-row-wrapper">
                            ${tagHtml}
                            <div class="bench-skill">
                                <div class="bench-skill-name-wrapper"><span class="bench-skill-name ${isAbility ? 'is-ability' : ''} ${abilityUsedClass}">${skill.name}</span></div>
                                <div class="bench-skill-damage">${sanitizeDamage(skill.damage) || ''}</div>
                            </div>
                        </div>`;
                });
                skillsContainer.innerHTML = skillsHtml;

                const energyContainer = wrapper.querySelector('.bench-attached-energies');
                renderAttachedEnergies(energyContainer, slotData.attachedEnergy, getEnergyIcon);

                updateAttachedTools(slotEl, newToolIds, oldToolIds, false, forceRedraw); // isBattleSlot is always false here

                if (slotData && slotData.evolutionSelect) {
                    delete slotData.evolutionSelect;
                } // Clear the evolutionSelect flag after rendering
                if (slotData && slotData.forceSlideIn) {
                    delete slotData.forceSlideIn;
                }
            }
            
            // Preload all FX videos and images on page load
            const videosToPreload = [
                '/assets/ptcg-telop/fx/bench_ko.webm',
                '/assets/ptcg-telop/fx/bench-replace.webm',
                '/assets/ptcg-telop/fx/bench-devolve.webm',
                '/assets/ptcg-telop/fx/bench-evolve.webm',
                '/assets/ptcg-telop/fx/bench-mega-evolve.webm',
                '/assets/ptcg-telop/fx/tool-attach.webm',
                '/assets/ptcg-telop/fx/tool-remove.webm'
            ];
            const imagesToPreload = [
                '/assets/ptcg-telop/element/extra-bg.png',
                '/assets/ptcg-telop/element/bench-bg.png'
            ];

            const preloaderContainer = document.getElementById('video-preloader');
            if (preloaderContainer) {
                videosToPreload.forEach(src => {
                    const video = document.createElement('video');
                    video.src = src;
                    video.preload = 'auto';
                    video.muted = true;
                    video.load();
                    preloaderContainer.appendChild(video);
                });

                imagesToPreload.forEach(src => {
                    const img = document.createElement('img');
                    img.src = src;
                    preloaderContainer.appendChild(img);
                });
            }

            function playVideoOnSlot(targetEl, videoSrc) {
                const imageSelector = '.bench-pokemon-image';
                const cardImage = targetEl.querySelector(imageSelector);
                const targetRect = targetEl.getBoundingClientRect();
                const videoContainer = document.createElement('div');
                videoContainer.style.position = 'absolute';
                videoContainer.style.left = `${targetRect.left}px`;
                videoContainer.style.top = `${targetRect.top}px`;
                videoContainer.style.width = `${targetRect.width}px`;
                videoContainer.style.height = `${targetRect.height}px`;
                videoContainer.style.zIndex = '300';
                videoContainer.style.overflow = 'hidden';
                const video = document.createElement('video');
                video.src = videoSrc;
                video.muted = true;
                video.style.width = '100%';
                video.style.height = '100%';
                videoContainer.appendChild(video);
                document.body.appendChild(videoContainer);
                video.play();
                setTimeout(() => { if (cardImage) cardImage.style.visibility = 'hidden'; }, REPLACE_ANIMATION_HIDE_MS);
                setTimeout(() => { if (cardImage) cardImage.style.visibility = 'visible'; }, REPLACE_ANIMATION_SHOW_MS);
                video.addEventListener('ended', () => videoContainer.remove());
            }

            const cardDatabase = nodecg.Replicant('cardDatabase');
            const settingsRep = nodecg.Replicant('ptcg-settings');
            const assetPaths = nodecg.Replicant('assetPaths');
            const deckL = nodecg.Replicant('deckL');
            const deckR = nodecg.Replicant('deckR');
            const replicantList = [cardDatabase, settingsRep, assetPaths, deckL, deckR];
            const sides = ['L', 'R'];

            for (let i = 6; i <= 8; i++) {
                sides.forEach(side => {
                    replicantList.push(nodecg.Replicant(`live_slot${side}${i}`));
                });
            }
            
            function getHitVideoSrc(attackerType) {
                const basePath = '/assets/ptcg-telop/fx/';
                const typeMap = {
                    "草": "grass",
                    "炎": "fire",
                    "水": "water",
                    "雷": "lightning",
                    "超": "psychic",
                    "闘": "fighting",
                    "悪": "darkness",
                    "鋼": "metal",
                    "竜": "dragon",
                    "妖": "fairy",
                    "無": "colorless"
                };
                const typeString = typeMap[attackerType] || 'colorless';
                return `${basePath}hit-${typeString}.webm`;
            }

            NodeCG.waitForReplicants(...replicantList).then(() => {
                const preloaderContainer = document.getElementById('video-preloader');
                function preloadDeckImages(deck) {
                    if (!deck || !deck.cards || !assetPaths.value.cardImgPath || !preloaderContainer) return;

                    deck.cards.forEach(cardId => {
                        const fullPath = getCardImageUrl(cardId);
                        if (fullPath && !preloaderContainer.querySelector(`img[src="${fullPath}"]`)) {
                            const img = document.createElement('img');
                            img.src = fullPath;
                            preloaderContainer.appendChild(img);
                        }
                    });
                }

                // Initial preload for both decks
                preloadDeckImages(deckL.value);
                preloadDeckImages(deckR.value);

                // Listen for changes in both decks
                deckL.on('change', (newVal) => preloadDeckImages(newVal));
                deckR.on('change', (newVal) => preloadDeckImages(newVal));

                for (let i = 6; i <= 8; i++) {
                    sides.forEach(side => {
                        const replicant = nodecg.Replicant(`live_slot${side}${i}`);
                        replicant.on('change', (newVal, oldVal) => {
                            if (!oldVal) {
                                return;
                            }
                            renderSlot(side, i, newVal, oldVal);
                        });
                        renderSlot(side, i, replicant.value, null);
                    });
                }

                assetPaths.on('change', () => {
                    for (let i = 6; i <= 8; i++) {
                        sides.forEach(side => {
                            const replicant = nodecg.Replicant(`live_slot${side}${i}`);
                            renderSlot(side, i, replicant.value, null);
                        });
                    }
                });

                nodecg.listenFor('attack-fx', (data) => {
                    if (!data || !data.targets) return;

                    const targetsInThisGraphic = data.targets.filter(t => {
                        return !!document.getElementById(t.targetId.replace('slot', 'slot-'));
                    });

                    if (targetsInThisGraphic.length === 0) return;

                    targetsInThisGraphic.forEach(targetInfo => {
                        const targetEl = document.getElementById(targetInfo.targetId.replace('slot', 'slot-'));
                        if (targetEl) {
                            g_attackAnimationTargets.add(targetEl.id);
                        }
                    });

                    setTimeout(() => {
                        let animationsToEnd = targetsInThisGraphic.length;
                        const onHitAnimationEnd = () => {
                            animationsToEnd--;
                            if (animationsToEnd === 0) {
                                g_attackAnimationTargets.clear();
                            }
                        };

                        targetsInThisGraphic.forEach(targetInfo => {
                            const targetEl = document.getElementById(targetInfo.targetId.replace('slot', 'slot-'));
                            if (!targetEl) {
                                onHitAnimationEnd();
                                return;
                            }

                            const cardImageSelector = '.bench-card-image-area';
                            const cardImageEl = targetEl.querySelector(cardImageSelector);
                            if (cardImageEl) {
                                cardImageEl.classList.add('anim-shake', 'anim-flash-white');
                                setTimeout(() => cardImageEl.classList.remove('anim-shake', 'anim-flash-white'), 400);
                                
                                const imageRect = cardImageEl.getBoundingClientRect();
                                const videoSize = 200;
                                const hitVideo = document.createElement('video');
                                hitVideo.className = 'hit-effect'; // Use class from main.html
                                hitVideo.src = getHitVideoSrc(data.attackerType);
                                hitVideo.muted = true;
                                hitVideo.autoplay = true; // Revert to autoplay like main.html
                                hitVideo.style.width = `${videoSize}px`;
                                hitVideo.style.height = `${videoSize}px`;
                                hitVideo.style.left = `${imageRect.left + (imageRect.width / 2) - (videoSize / 2)}px`;
                                hitVideo.style.top = `${imageRect.top + (imageRect.height / 2) - (videoSize / 2)}px`;
                                document.body.appendChild(hitVideo);
                                
                                hitVideo.addEventListener('ended', () => {
                                    hitVideo.remove();
                                    onHitAnimationEnd();
                                });
                            } else {
                                onHitAnimationEnd();
                            }
                        });
                    }, 1000);
                });

                nodecg.listenFor('playAnimation', (animation) => {
                    if (!animation || !animation.type) {
                        console.error('Invalid animation data received:', animation);
                        return;
                    }

                    if (animation.type === 'SWITCH_POKEMON') {
                        if (!animation.source || !animation.target) {
                            console.error('Invalid PROMOTE animation data:', animation);
                            return;
                        }
                        const sourceEl = document.getElementById(animation.source);
                        const targetEl = document.getElementById(animation.target);

                        if (sourceEl && !sourceEl.classList.contains('is-empty')) {
                            const side = animation.source.includes('-L') ? 'L' : 'R';
                            sourceEl.classList.add(`anim-slide-out-${side}`);
                        }
                        if (targetEl && !targetEl.classList.contains('is-empty')) {
                            const side = animation.target.includes('-L') ? 'L' : 'R';
                            targetEl.classList.add(`anim-slide-out-${side}`);
                        }
                        return; // End PROMOTE logic here.
                    }

                    // For all other animations, target is required and must be in this document.
                    if (!animation.target) {
                        console.error('Animation requires a target:', animation);
                        return;
                    }
                    const targetEl = document.getElementById(animation.target);
                    if (!targetEl) {
                        // This is expected if the target is in the other graphic, so don't log an error.
                        return;
                    }
                    const side = animation.target.includes('-L') ? 'L' : 'R';
                    targetEl.classList.remove(`anim-slide-in-${side}`, `anim-slide-out-${side}`);

                    if (animation.type === 'EVOLVE_POKEMON') {
                        const db = cardDatabase.value;
                        // All slots in extra.html are bench slots.
                        let videoSrc = '/assets/ptcg-telop/fx/bench-evolve.webm';

                        // Check for Mega Evolution
                        if (animation.cardId && db && db[animation.cardId]) {
                            const cardData = db[animation.cardId];
                            if (cardData.pokemon && cardData.pokemon.option && cardData.pokemon.option.toLowerCase() === 'mega') {
                                videoSrc = '/assets/ptcg-telop/fx/bench-mega-evolve.webm';
                            }
                        }
                        playVideoOnSlot(targetEl, videoSrc);
                    } else if (animation.type === 'DEVOLVE_POKEMON') {
                        const videoSrc = '/assets/ptcg-telop/fx/bench-devolve.webm';
                        playVideoOnSlot(targetEl, videoSrc);
                    } else if (animation.type === 'REPLACE_POKEMON') {
                        const videoSrc = '/assets/ptcg-telop/fx/bench-replace.webm';
                        playVideoOnSlot(targetEl, videoSrc);
                    } else if (animation.type === 'KO_POKEMON') {
                        const videoSrc = '/assets/ptcg-telop/fx/bench_ko.webm';
                        const imageSelector = '.bench-pokemon-image';
                        const koVideo = document.createElement('video');
                        koVideo.src = videoSrc;
                        koVideo.muted = true;
                        koVideo.style.position = 'absolute';
                        koVideo.style.width = '100%';
                        koVideo.style.height = '100%';
                        koVideo.style.left ='-4px';
                        koVideo.style.top = '0';
                        koVideo.style.zIndex = '200';
                        targetEl.appendChild(koVideo);
                        koVideo.play();
                        setTimeout(() => {
                            const cardImage = targetEl.querySelector(imageSelector);
                            if (cardImage) cardImage.style.visibility = 'hidden';
                        }, 85);
                        koVideo.addEventListener('ended', () => {
                            koVideo.remove();
                            targetEl.classList.add(`anim-slide-out-${side}`);
                        });
                    } else if (animation.type === 'ATTACH_TOOL' || animation.type === 'REMOVE_TOOL') {
                        const isAttach = animation.type === 'ATTACH_TOOL';
                        // The new logic handles this inside updateAttachedTools, so we can simplify here.
                        const toolSelector = '.bench-attached-tool';
                        const toolEl = targetEl.querySelector(toolSelector);
                        if (!toolEl) {
                            console.error('Could not find tool element for animation:', animation.target);
                            return;
                        }
                        requestAnimationFrame(() => {
                            // The animation is now triggered by the replicant change in renderSlot.
                            // The 'playAnimation' message is now just a trigger for the data change.
                        });
                    } else if (animation.type === 'EXIT_POKEMON') {
                        targetEl.classList.add(`anim-slide-out-${side}`);
                    } else if (animation.type === 'ENTER_POKEMON') {
                        targetEl.classList.remove('anim-slide-out-L', 'anim-slide-out-R');
                        const animationClass = `anim-slide-in-${side}`;
                        targetEl.classList.add(animationClass);
                        targetEl.addEventListener('animationend', () => {
                            targetEl.classList.remove(animationClass);
                        }, { once: true });
                    }
                });

                // Fallback cleanup for animation state
                nodecg.listenFor('attack-fx-complete', () => {
                    activeAnimations.clear();
                    g_attackAnimationTargets.clear();
                });
                });
            });
    </script>
</body>
</html>