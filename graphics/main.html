<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Main Graphic</title>
    <!-- All common styles are now in common.css -->
    <link rel="stylesheet" href="css/fonts.css">
    <script>
        // Dynamically preload fonts based on fonts.css
        (function() {
            fetch('css/fonts.css')
                .then(response => response.text())
                .then(text => {
                    const fontUrlRegex = /url\((['"]?)(.+?\.(?:ttf|otf|woff|woff2))\1\)/g;
                    let match;
                    while ((match = fontUrlRegex.exec(text)) !== null) {
                        const fontUrl = match[2];
                        const link = document.createElement('link');
                        link.rel = 'preload';
                        link.href = fontUrl;
                        link.as = 'font';
                        link.type = `font/${fontUrl.split('.').pop()}`;
                        link.crossOrigin = 'anonymous';
                        document.head.appendChild(link);
                    }
                }).catch(err => console.error('Failed to preload fonts:', err));
        })();
    </script>
    <link rel="stylesheet" href="css/common.css">
    <style>
        /* All styles have been moved to graphics/css/common.css */
    </style>
</head>
<body>
    <div class="overlay-frame">
        <!-- Current Turn Borders (positioned at the bottom layer) -->
        <div id="current-L-border" class="current-turn-border"></div>
        <div id="current-R-border" class="current-turn-border"></div>

        <!-- Player L Area -->
        <div class="player-area" id="player-L-area">
            <div class="player-info" id="player-L-info">
                <img class="first-move-icon hidden" id="first-move-L" src="/assets/ptcg-telop/element/first_move.png">
                <span class="player-name" id="player-L-name"></span>
                <img src="/assets/ptcg-telop/element/VSTAR.webp" class="vstar-icon" id="vstar-L-icon">
            </div>
            <div class="active-slot" id="slot-L0">
                <div class="active-pokemon-wrapper hidden">
                    <div class="battle-pokemon-name"></div>
                    <div class="battle-card-image-area">
                        <img class="battle-pokemon-image">
                        <div class="battle-status-ailment"></div>
                        <div class="battle-attached-energies"></div>
                        <div class="battle-attached-tools-wrapper"></div>
                    </div>
                    <div class="battle-hp-gauge">
                        <div class="battle-hp-bar-container">
                            <div class="battle-hp-text"></div>
                            <div class="battle-hp-bar"></div>
                        </div>
                    </div>
                    <div class="battle-skills-container"></div>
                </div>
                    </div>
            <div class="bench-slots">
                <div class="bench-slot" id="slot-L1"></div>
                <div class="bench-slot" id="slot-L2"></div>
                <div class="bench-slot" id="slot-L3"></div>
                <div class="bench-slot" id="slot-L4"></div>
                <div class="bench-slot" id="slot-L5"></div>
            </div>
            <div class="player-action">
                <img class="action-icon" id="action-L-energy" src="/assets/ptcg-telop/element/action-energy.png" title="Energy Action">
                <img class="action-icon" id="action-L-supporter" src="/assets/ptcg-telop/element/action-supporter.png" title="Supporter Action">
                <img class="action-icon" id="action-L-retreat" src="/assets/ptcg-telop/element/action-retreat.png" title="Retreat Action">
            </div>
        </div>
        <!-- Player R Area -->
        <div class="player-area" id="player-R-area">
            <div class="player-info" id="player-R-info">
                <img class="first-move-icon hidden" id="first-move-R" src="/assets/ptcg-telop/element/first_move.png">
                <span class="player-name" id="player-R-name"></span>
                <img src="/assets/ptcg-telop/element/VSTAR.webp" class="vstar-icon" id="vstar-R-icon">
            </div>
            <div class="active-slot" id="slot-R0">
                <div class="active-pokemon-wrapper hidden">
                    <div class="battle-pokemon-name"></div>
                    <div class="battle-card-image-area">
                        <img class="battle-pokemon-image">
                        <div class="battle-status-ailment"></div>
                        <div class="battle-attached-energies"></div>
                        <div class="battle-attached-tools-wrapper"></div>
                    </div>
                    <div class="battle-hp-gauge">
                        <div class="battle-hp-bar-container">
                            <div class="battle-hp-text"></div>
                            <div class="battle-hp-bar"></div>
                        </div>
                    </div>
                    <div class="battle-skills-container"></div>
                </div>
            </div>
            <div class="bench-slots">
                <div class="bench-slot" id="slot-R1"></div>
                <div class="bench-slot" id="slot-R2"></div>
                <div class="bench-slot" id="slot-R3"></div>
                <div class="bench-slot" id="slot-R4"></div>
                <div class="bench-slot" id="slot-R5"></div>
            </div>
            <div class="player-action">
                <img class="action-icon" id="action-R-energy" src="/assets/ptcg-telop/element/action-energy.png" title="Energy Action">
                <img class="action-icon" id="action-R-supporter" src="/assets/ptcg-telop/element/action-supporter.png" title="Supporter Action">
                <img class="action-icon" id="action-R-retreat" src="/assets/ptcg-telop/element/action-retreat.png" title="Retreat Action">
            </div>
        </div>

        <!-- Stadium Area -->
        <div id="stadium-area">
            <div id="stadium-card" class="hidden">
                <span id="stadium-name"></span>
            </div>
        </div>

        <!-- Side Areas -->
        <div class="side-area" id="side-L-area">
            <img class="side-icon"><img class="side-icon"><img class="side-icon">
            <img class="side-icon"><img class="side-icon"><img class="side-icon">
        </div>
        <div id="lost-zone-L-area" class="lost-zone-counter">
            <img src="/assets/ptcg-telop/element/lost-zone.png">
            <span class="count">0</span>
        </div>
        <div class="side-area" id="side-R-area">
            <img class="side-icon"><img class="side-icon"><img class="side-icon">
            <img class="side-icon"><img class="side-icon"><img class="side-icon">
        </div>
        <div id="lost-zone-R-area" class="lost-zone-counter">
            <img src="/assets/ptcg-telop/element/lost-zone.png">
            <span class="count">0</span>
        </div>
    </div>

    <!-- Attack FX -->
    <div id="attack-fx-container">
        <video class="attack-fx-video" src="/assets/ptcg-telop/fx/Speedline.webm" muted></video>
        <div class="attack-fx-bar">
            <div class="attack-fx-upper">
                <span class="attack-fx-move-name"></span>
            </div>
            <div class="attack-fx-lower">
                <span class="attack-fx-attacker-name"></span>
            </div>
        </div>
    </div>

    <!-- Preloader Container for FX Videos (Hidden) -->
    <div id="video-preloader"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const getCardImageUrl = (cardId, isBgImage = false) => {
            if (!cardId || !assetPaths.value.cardImgPath) {
                return isBgImage ? 'none' : '';
            }
            const db = cardDatabase.value;
            const cardData = db ? db[cardId] : null;
            const imageUrl = cardData ? cardData.image_url : null;
            const extension = imageUrl ? imageUrl.substring(imageUrl.lastIndexOf('.')) : '.jpg';
            const path = `/${assetPaths.value.cardImgPath}${cardId}${extension}`;
            return isBgImage ? `url(${path})` : path;
        };

        const ENERGY_MAP = {
            "草": "草", "炎": "炎", "水": "水", "雷": "雷", "超": "超", "闘": "闘", "悪": "悪", "鋼": "鋼",
            "無": "無", "全": "全", "超悪": "超悪", "竜": "竜", "妖": "妖"
        };

        // Animation Timings
        const REPLACE_ANIMATION_HIDE_MS = 550;
        const REPLACE_ANIMATION_SHOW_MS = 700;

        // Used to pass animation state between attack-fx and displayHpChangeNumber
        const activeAnimations = new Map();
        const g_attackAnimationTargets = new Set();

        function hexToRgba(hex, alpha = 1.0) {
            if (!/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
                return ''; // Return empty string for invalid hex
            }
            let c = hex.substring(1).split('');
            if (c.length === 3) {
                c = [c[0], c[0], c[1], c[1], c[2], c[2]];
            }
            c = '0x' + c.join('');
            const r = (c >> 16) & 255;
            const g = (c >> 8) & 255;
            const b = c & 255;
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function animateHp(element, startHp, endHp, startMaxHp, endMaxHp, duration) {
            if (!element) return;
            if (startHp === endHp && startMaxHp === endMaxHp) {
                element.textContent = `${endHp}/${endMaxHp}`;
                return;
            }
            let startTimestamp = null;
            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                const rawCurrentHp = progress * (endHp - startHp) + startHp;
                const rawCurrentMaxHp = progress * (endMaxHp - startMaxHp) + startMaxHp;
                let displayHp, displayMaxHp;
                if (progress < 1) {
                    displayHp = Math.round(rawCurrentHp / 10) * 10;
                    displayMaxHp = Math.round(rawCurrentMaxHp / 10) * 10;
                } else {
                    displayHp = endHp;
                    displayMaxHp = endMaxHp;
                }
                element.textContent = `${displayHp}/${displayMaxHp}`;
                if (progress < 1) {
                    window.requestAnimationFrame(step);
                }
            };
            window.requestAnimationFrame(step);
        }

        function displayHpChangeNumber(targetSlotEl, hpChange) {
            if (hpChange === 0) return;
            const isHeal = hpChange > 0;
            const number = Math.abs(hpChange);
            const text = isHeal ? `+${number}` : `${-number}`;
            const isBattleSlot = targetSlotEl.classList.contains('active-slot');
            const numberTypeClass = isHeal ? 'heal-number' : 'damage-number';
            const numberSizeClass = isBattleSlot 
                ? (isHeal ? 'heal-number-battle' : 'damage-number-battle')
                : (isHeal ? 'heal-number-bench' : 'damage-number-bench');
            const cardImageSelector = isBattleSlot ? '.battle-card-image-area' : '.bench-card-image-area';
            const cardImageEl = targetSlotEl.querySelector(cardImageSelector);
            if (!cardImageEl) return;
            requestAnimationFrame(() => {
                const imageRect = cardImageEl.getBoundingClientRect();
                if (imageRect.width === 0) return;
                const numberEl = document.createElement('div');
                numberEl.className = `${numberTypeClass} ${numberSizeClass}`;
                numberEl.textContent = text;
                numberEl.style.left = `${imageRect.left + imageRect.width / 2}px`;
                numberEl.style.top = `${imageRect.top + imageRect.height / 2}px`;
                document.body.appendChild(numberEl);

                // Check if a weakness icon needs to be displayed
                if (isBattleSlot && activeAnimations.has(targetSlotEl.id)) {
                    const animationData = activeAnimations.get(targetSlotEl.id);
                    if (animationData.isWeakness) {
                        const weaknessIcon = new Image();
                        weaknessIcon.src = '/assets/ptcg-telop/element/weakness.png';
                        weaknessIcon.className = 'weakness-icon-fx';

                        const appendAndAnimate = () => {
                            weaknessIcon.style.left = `${imageRect.left + imageRect.width / 2}px`;
                            weaknessIcon.style.top = `${imageRect.top + imageRect.height / 2}px`;
                            document.body.appendChild(weaknessIcon);
                            setTimeout(() => weaknessIcon.remove(), 1500);
                        };

                        if (weaknessIcon.complete) {
                            appendAndAnimate();
                        } else {
                            weaknessIcon.onload = appendAndAnimate;
                        }
                    }
                    // The animation state has been consumed, so clean it up.
                    // This is the correct place to ensure the flag is cleared after being used.
                    activeAnimations.delete(targetSlotEl.id);
                }

                setTimeout(() => numberEl.remove(), 1500);
            });
        }

        function getHitVideoSrc(attackerType) {
            const basePath = '/assets/ptcg-telop/fx/';
            const typeMap = {
                "草": "grass",
                "炎": "fire",
                "水": "water",
                "雷": "lightning",
                "超": "psychic",
                "闘": "fighting",
                "悪": "darkness",
                "鋼": "metal",
                "竜": "dragon",
                "妖": "fairy",
                "無": "colorless"
            };
            const typeString = typeMap[attackerType] || 'colorless';
            return `${basePath}hit-${typeString}.webm`;
        }

        function renderStadium(newData, oldData) {
            const db = cardDatabase.value;
            const stadiumCardEl = document.getElementById('stadium-card');
            const stadiumNameEl = document.getElementById('stadium-name');
            
            const newCardId = newData ? newData.cardId : null;
            const oldCardId = oldData ? oldData.cardId : null;
            const newUsed = newData ? newData.used : false;
            const oldUsed = oldData ? oldData.used : false;

            // If nothing has changed (card ID and used status), do nothing.
            if (newCardId === oldCardId && newUsed === oldUsed) return;

            const newCard = newCardId ? db[newCardId] : null;

            const updateContent = (card, isUsed) => {
                if (card) {
                    stadiumNameEl.textContent = isUsed ? getI18nText('used') : card.name;
                    stadiumCardEl.style.backgroundImage = getCardImageUrl(newCardId, true);
                    stadiumCardEl.style.filter = isUsed ? 'grayscale(1)' : 'none';
                } else {
                    stadiumNameEl.textContent = '';
                    stadiumCardEl.style.backgroundImage = 'none';
                    stadiumCardEl.style.filter = 'none';
                }
            };

            // Handle animations and content updates
            if (newCardId !== oldCardId) {
                // Card is changing
                if (oldCardId && newCardId) { // Swapping from one card to another
                    stadiumCardEl.classList.add('anim-slide-out-top');
                    setTimeout(() => {
                        updateContent(newCard, newUsed);
                        stadiumCardEl.classList.remove('anim-slide-out-top');
                        stadiumCardEl.classList.add('anim-slide-in-top');
                        setTimeout(() => stadiumCardEl.classList.remove('anim-slide-in-top'), 500);
                    }, 500);
                } else if (!oldCardId && newCardId) { // Adding a new card
                    updateContent(newCard, newUsed);
                    stadiumCardEl.classList.remove('hidden');
                    stadiumCardEl.classList.add('anim-slide-in-top');
                    setTimeout(() => stadiumCardEl.classList.remove('anim-slide-in-top'), 500);
                } else if (oldCardId && !newCardId) { // Removing a card
                    stadiumCardEl.classList.add('anim-slide-out-top');
                    setTimeout(() => {
                        stadiumCardEl.classList.add('hidden');
                        stadiumCardEl.classList.remove('anim-slide-out-top');
                        updateContent(null, false);
                    }, 500);
                }
            } else {
                // Only the 'used' status is changing
                updateContent(newCard, newUsed);
            }
        }

        function updatePlayerInfo(side, name) {
            const el = document.getElementById(`player-${side}-name`);
            if (el) el.textContent = name || `Player ${side}`;
        }

        function updateVstarIcon(side, isUsed) {
            const el = document.getElementById(`vstar-${side}-icon`);
            if (el) {
                el.classList.toggle('used', isUsed);
                el.classList.toggle('available', !isUsed);
            }
        }

        function updateSideArea(side, remaining) {
            const area = document.getElementById(`side-${side}-area`);
            if (!area) return;
            const icons = area.querySelectorAll('.side-icon');
            const taken = 6 - remaining;
            const takenIcon = '/assets/ptcg-telop/element/side_taken.png';
            const remainingIcon = '/assets/ptcg-telop/element/side_remain.png';
            icons.forEach((icon, index) => {
                icon.src = index < taken ? takenIcon : remainingIcon;
            });
        }

        function updateActionIcon(side, action, isUsed) {
            const el = document.getElementById(`action-${side}-${action}`);
            if (el) {
                el.classList.toggle('used', isUsed);
            }
        }

        function updateFirstMoveIcon(firstMoveValue) {
            const iconL = document.getElementById('first-move-L');
            const iconR = document.getElementById('first-move-R');
            const firstMoveIconSrc = '/assets/ptcg-telop/element/first_move.png';
            const secondMoveIconSrc = '/assets/ptcg-telop/element/second_move.png';

            if (firstMoveValue === 'L') {
                iconL.src = firstMoveIconSrc;
                iconR.src = secondMoveIconSrc;
                iconL.classList.remove('hidden');
                iconR.classList.remove('hidden');
            } else if (firstMoveValue === 'R') {
                iconL.src = secondMoveIconSrc;
                iconR.src = firstMoveIconSrc;
                iconL.classList.remove('hidden');
                iconR.classList.remove('hidden');
            } else {
                iconL.classList.add('hidden');
                iconR.classList.add('hidden');
            }
        }

        function updateLostZoneCounter(side, count) {
            const el = document.getElementById(`lost-zone-${side}-area`);
            if (!el) return;
            if (count > 0) {
                el.querySelector('.count').textContent = count;
                el.classList.add('visible');
            } else {
                el.classList.remove('visible');
            }
        }

        function renderAttachedEnergies(container, energies, getIconHtml) {
            if (!container || !energies) return;
            const energyCounts = energies.reduce((acc, energy) => {
                acc[energy] = (acc[energy] || 0) + 1;
                return acc;
            }, {});
            const totalEnergyCount = energies.length;
            const maxSingleEnergyCount = Object.values(energyCounts).reduce((max, count) => Math.max(max, count), 0);
            const useTypeB = (maxSingleEnergyCount > 1 && totalEnergyCount >= 7) || maxSingleEnergyCount >= 5;
            let html = '';
            if (useTypeB) {
                for (const type in energyCounts) {
                    html += `
                        <div class="energy-count-group">
                            ${getIconHtml(type)}
                            <span class="energy-count-number">${energyCounts[type]}</span>
                        </div>
                    `;
                }
            } else {
                html = energies.map(getIconHtml).join('');
            }
            container.innerHTML = html;
        }

        function updateCurrentTurnBorder(currentTurn) {
            const lBorder = document.getElementById('current-L-border');
            const rBorder = document.getElementById('current-R-border');
            if (currentTurn === 'L') {
                lBorder.classList.add('active');
                rBorder.classList.remove('active');
            } else if (currentTurn === 'R') {
                rBorder.classList.add('active');
                lBorder.classList.remove('active');
            } else {
                lBorder.classList.remove('active');
                rBorder.classList.remove('active');
            }
        }

        function playToolAnimation(targetEl, isBattleSlot, isAttach) {
            if (!targetEl) return;
 
            const videoSrc = isAttach ? '/assets/ptcg-telop/fx/tool-attach.webm' : '/assets/ptcg-telop/fx/tool-remove.webm';
            
            const targetRect = targetEl.getBoundingClientRect();
            if (targetRect.width === 0 && targetRect.height === 0) return;

            const video = document.createElement('video');
            video.src = videoSrc;
            video.muted = true;
            video.autoplay = true;
            video.style.position = 'absolute';
            video.style.zIndex = '400';
            video.style.pointerEvents = 'none';

            const videoWidth = isBattleSlot ? 150 : 70;
            const videoHeight = isBattleSlot ? 120 : 56;
            video.style.width = `${videoWidth}px`;
            video.style.height = `${videoHeight}px`;

            const targetCenterX = targetRect.left + targetRect.width / 2;
            const targetCenterY = targetRect.top + targetRect.height / 2;
            video.style.left = `${targetCenterX - videoWidth / 2}px`;
            video.style.top = `${targetCenterY - videoHeight / 2}px`;

            document.body.appendChild(video);
            video.addEventListener('ended', () => video.remove());
        }

        function updateAttachedTools(slotEl, newToolIds, oldToolIds, isBattleSlot, forceRedraw = false) {
            const db = cardDatabase.value;
            const wrapperSelector = isBattleSlot ? '.battle-attached-tools-wrapper' : '.bench-attached-tools-wrapper';
            const itemClass = isBattleSlot ? 'battle-attached-tool-item' : 'bench-attached-tool-item';
            const wrapperEl = slotEl.querySelector(wrapperSelector);
            if (!wrapperEl) return;

            // If a forceRedraw is needed (because the parent DOM was wiped), skip diffing and just render the new state.
            if (forceRedraw) {
                wrapperEl.innerHTML = ''; // Clear any previous content
                newToolIds.forEach(id => {
                    if (db[id]) {
                        const toolItem = document.createElement('div');
                        // Use a simple scale-in animation for this redraw case to avoid complexity.
                        toolItem.className = `${itemClass} anim-scale-in-tool`;
                        toolItem.dataset.toolId = id;
                        const toolImg = document.createElement('img');
                        toolImg.src = getCardImageUrl(id);
                        toolItem.appendChild(toolImg);
                        wrapperEl.appendChild(toolItem);
                        toolItem.addEventListener('animationend', () => toolItem.classList.remove('anim-scale-in-tool'), { once: true });
                    }
                });
                return; // End execution here
            }
 
            const toolsToRemove = [];
            const toolsToAdd = [];
 
            // New diffing logic to prioritize removing newest items (at the end of the array)
            const oldWithKept = oldToolIds.map(id => ({ id, kept: false }));
            const tempNewIdsForConsumption = [...newToolIds];
 
            // First pass: find all items that are kept by consuming from tempNewIds
            oldWithKept.forEach(item => {
                const idxInNew = tempNewIdsForConsumption.indexOf(item.id);
                if (idxInNew > -1) {
                    item.kept = true;
                    tempNewIdsForConsumption.splice(idxInNew, 1); // Consume it
                }
            });
 
            // The remaining items in tempNewIds are the ones to add.
            toolsToAdd.push(...tempNewIdsForConsumption);
 
            // Find the indices of the items to remove, prioritizing the newest ones (end of the array).
            for (let i = oldWithKept.length - 1; i >= 0; i--) {
                if (!oldWithKept[i].kept) {
                    toolsToRemove.push({ id: oldWithKept[i].id, index: i });
                }
            }

            const hasRemovals = toolsToRemove.length > 0;
            const hasAdditions = toolsToAdd.length > 0;

            // A reorder is needed if the new list is not a perfect prefix of the old list.
            let reorderNeeded = false;
            if (hasRemovals) {
                let isPrefix = newToolIds.length <= oldToolIds.length;
                if (isPrefix) {
                    for (let i = 0; i < newToolIds.length; i++) {
                        if (newToolIds[i] !== oldToolIds[i]) {
                            isPrefix = false;
                            break;
                        }
                    }
                }
                if (!isPrefix) {
                    reorderNeeded = true;
                }
            }

            // --- Main Logic ---
            if (hasRemovals) {
                if (reorderNeeded) {
                    // --- Reorder logic: Animate specific items out, then fade-in the new container state ---
                    const allElements = [...wrapperEl.querySelectorAll(`.${itemClass}`)];
                    toolsToRemove.forEach(item => {
                        const el = allElements[item.index];
                        if (el && !el.classList.contains('anim-tool-disappear')) {
                            el.classList.add('anim-tool-disappear');
                            playToolAnimation(el, isBattleSlot, false);
                        }
                    });

                    setTimeout(() => {
                        wrapperEl.innerHTML = ''; // Clear old layout
                        newToolIds.forEach(toolId => {
                            if (db[toolId]) {
                                const toolItem = document.createElement('div');
                                toolItem.className = itemClass;
                                toolItem.dataset.toolId = toolId;
                                const toolImg = document.createElement('img');
                                toolImg.src = getCardImageUrl(toolId);
                                toolItem.appendChild(toolImg);
                                wrapperEl.appendChild(toolItem);
                            }
                        });
                        wrapperEl.classList.add('tools-fade-in');
                        wrapperEl.addEventListener('animationend', () => wrapperEl.classList.remove('tools-fade-in'), { once: true });
                    }, 300);
                } else {
                    // --- No reorder: Just animate the last items out ---
                    const allElements = [...wrapperEl.querySelectorAll(`.${itemClass}`)];
                    toolsToRemove.forEach(item => {
                        const el = allElements[item.index];
                        if (el) {
                            el.classList.add('anim-tool-disappear');
                            playToolAnimation(el, isBattleSlot, false);
                            el.addEventListener('animationend', () => el.remove(), { once: true });
                        }
                    });
                }
            } else if (hasAdditions) {
                // --- Additions only ---
                toolsToAdd.forEach(id => {
                    if (db[id]) {
                        const toolItem = document.createElement('div');
                        toolItem.className = `${itemClass} anim-tool-appear`;
                        toolItem.dataset.toolId = id;
                        const toolImg = document.createElement('img');
                                                        toolImg.src = getCardImageUrl(id);                        toolItem.appendChild(toolImg);
                        wrapperEl.appendChild(toolItem);
                        toolItem.addEventListener('animationstart', () => playToolAnimation(toolItem, isBattleSlot, true), { once: true });
                        toolItem.addEventListener('animationend', () => toolItem.classList.remove('anim-tool-appear'), { once: true });
                    }
                });
            }
        }

        function updateStatusAilments(containerEl, newAilments, oldAilments) {
            if (!containerEl) return;

            const currentIcons = new Set(Array.from(containerEl.children).map(el => el.dataset.ailment));
            const newIcons = new Set(newAilments);
            const oldIcons = new Set(oldAilments);

            // Icons to remove
            oldIcons.forEach(ailment => {
                if (!newIcons.has(ailment)) {
                    const iconEl = containerEl.querySelector(`[data-ailment="${ailment}"]`);
                    if (iconEl) {
                        iconEl.classList.add('anim-status-disappear');
                        iconEl.addEventListener('animationend', () => iconEl.remove(), { once: true });
                    }
                }
            });

            // Icons to add
            newIcons.forEach(ailment => {
                if (!currentIcons.has(ailment)) {
                    const iconWrapper = document.createElement('div');
                    iconWrapper.className = 'status-icon-wrapper anim-status-appear';
                    iconWrapper.dataset.ailment = ailment;
                    const iconImg = document.createElement('img');
                    iconImg.src = `/assets/ptcg-telop/status/${ailment}.png`;
                    iconImg.className = 'status-icon';
                    iconWrapper.appendChild(iconImg);
                    containerEl.appendChild(iconWrapper);
                    iconWrapper.addEventListener('animationend', () => iconWrapper.classList.remove('anim-status-appear'), { once: true });
                }
            });
        }

        function renderSlot(side, index, slotData, oldSlotData) {
            const slotEl = document.getElementById(`slot-${side}${index}`);
            const db = cardDatabase.value;
            const settings = settingsRep.value || {};

            if (slotData && slotData.cardId) {
                slotEl.classList.remove('anim-slide-out-L', 'anim-slide-out-R');
            }

            const hasCard = slotData && slotData.cardId;
            const forceSlideIn = slotData && slotData.forceSlideIn;
            const skipSlideIn = slotData && slotData.evolutionSelect;
            const isNewCard = hasCard && (!oldSlotData || slotData.cardId !== oldSlotData.cardId);
            const isCardChanged = !oldSlotData || (slotData && oldSlotData.cardId !== slotData.cardId);

            const sanitizeDamage = (damage) => {
                if (typeof damage !== 'string') return damage || '';
                return damage.replace(/＋/g, '+').replace(/－/g, '-').replace(/×/g, '×');
            };

            if (!slotEl || !slotData || !slotData.cardId || !db || !db[slotData.cardId]) {
                const isSlidingOut = slotEl.classList.contains('anim-slide-out-L') || slotEl.classList.contains('anim-slide-out-R');

                        const clearSlot = () => {
                            const activeWrapper = slotEl.querySelector('.active-pokemon-wrapper');
                            const benchWrapper = slotEl.querySelector('.bench-pokemon-wrapper');
                
                            if (activeWrapper) { // It's the active slot
                                // First, hide the wrapper. The transition will make it fade out.
                                activeWrapper.classList.add('hidden');
                
                                // Then, clean up the dynamic content. This happens while it's fading.
                                const toolsWrapper = activeWrapper.querySelector('.battle-attached-tools-wrapper');
                                if (toolsWrapper) toolsWrapper.innerHTML = '';
                
                                const energyWrapper = activeWrapper.querySelector('.battle-attached-energies');
                                if (energyWrapper) energyWrapper.innerHTML = '';
                
                                const ailmentsWrapper = activeWrapper.querySelector('.battle-status-ailment');
                                if (ailmentsWrapper) ailmentsWrapper.innerHTML = '';
                            }
                            if (benchWrapper) { // It's a bench slot, destroy the content
                                slotEl.innerHTML = '';
                            }
                
                            slotEl.dataset.cardId = '';
                            slotEl.classList.add('is-empty');
                        };
                if (isSlidingOut) {
                    setTimeout(clearSlot, 500); 
                } else {
                    clearSlot();
                }
                return;
            }
            slotEl.classList.remove('is-empty');

            const isUnderAttack = g_attackAnimationTargets.has(slotEl.id);

            const useTypeStroke = settings.useTypeStroke;
            const typeColorMap = settings.typeColorMap || {};
            const imageArea = slotEl.querySelector('.battle-card-image-area, .bench-card-image-area');
            const cardData = db[slotData.cardId];

            slotEl.style.borderColor = 'var(--module-color-border)';
            if (imageArea) imageArea.style.borderColor = 'var(--module-color-border)';

            if (useTypeStroke && cardData && cardData.pokemon && cardData.pokemon.color && cardData.pokemon.color.length > 0) {
                const primaryType = cardData.pokemon.color[0];
                const colorSetting = typeColorMap[primaryType];
                
                if (colorSetting && colorSetting.color) {
                    slotEl.style.backgroundColor = hexToRgba(colorSetting.color, colorSetting.opacity);
                } else {
                    slotEl.style.backgroundColor = 'var(--color-bg-module)';
                }
            } else {
                slotEl.style.backgroundColor = 'var(--color-bg-module)';
            }

            // The 'oldSlotData' check is now only for HP animation, not for tools.
            const oldToolIds = oldSlotData ? (oldSlotData.attachedToolIds || []) : [];
            const newToolIds = slotData ? (slotData.attachedToolIds || []) : [];
            const ailmentsBeforeChange = oldSlotData ? (oldSlotData.ailments || []) : [];
            const newAilments = slotData ? (slotData.ailments || []) : [];

            // If the card ID changes (evolution, devolution) or if the Pokémon is no longer active,
        // it loses all status ailments. We clear oldAilments to ensure the UI updates correctly.
        const isNoLongerActive = index !== 0 && oldSlotData && oldSlotData.active; // Moved from active to bench
            
            if (isCardChanged || isNoLongerActive) {
                // When a card changes, it loses all ailments. The new state has no ailments.
                // The old state is what we just captured in `ailmentsBeforeChange`.
                oldSlotData = null; // Also nullify oldSlotData to prevent incorrect HP animation
            }

            if (!cardData || !cardData.pokemon) return;
            const baseHp = parseInt(cardData.pokemon.hp || 0, 10);
            const extraHp = parseInt(slotData.extraHp || 0, 10);
            const damage = parseInt(slotData.damage || 0, 10);
            const maxHp = baseHp + extraHp;
            const currentHp = Math.max(0, maxHp - damage);

            let hpChangeToShow = 0;
            if (oldSlotData) {
                const oldDamage = parseInt(oldSlotData.damage || 0, 10);
                const oldExtraHp = parseInt(oldSlotData.extraHp || 0, 10);
                const oldMaxHp = baseHp + oldExtraHp;
                const oldHp = Math.max(0, oldMaxHp - oldDamage);
                const damageDiff = damage - oldDamage;
                if (damageDiff > 0) { hpChangeToShow = -damageDiff; }
                else if (damageDiff < 0) { hpChangeToShow = -damageDiff; }
                else if (extraHp !== oldExtraHp) { hpChangeToShow = currentHp - oldHp; }
            }
            
            let startHp = currentHp, startMaxHp = maxHp;
            if (oldSlotData) {
                const oldExtraHp = parseInt(oldSlotData.extraHp || 0, 10);
                const oldDamage = parseInt(oldSlotData.damage || 0, 10);
                startMaxHp = baseHp + oldExtraHp;
                startHp = Math.max(0, startMaxHp - oldDamage);
            }
            
            const hpPercent = maxHp > 0 ? (currentHp / maxHp) * 100 : 0;
            let hpColor = 'var(--hp-high)';
            if (hpPercent <= 25) hpColor = 'var(--hp-low)';
            else if (hpPercent <= 50) hpColor = 'var(--hp-medium)';
            const getEnergyIcon = (type) => `<img class="energy-icon" src="/assets/ptcg-telop/energy/${ENERGY_MAP[type] || 'エネなし'}.png">`;

            if (index === 0) {
                const wrapper = slotEl.querySelector('.active-pokemon-wrapper');
                wrapper.classList.remove('hidden');
                wrapper.querySelector('.battle-pokemon-name').textContent = cardData.name;
                const img = wrapper.querySelector('.battle-pokemon-image');
                
                const playAnimationIfNeeded = () => {
                    if ((isNewCard || forceSlideIn) && !skipSlideIn) {
                        const needsToWaitForSlideOut = slotEl.classList.contains('anim-slide-out-L') || slotEl.classList.contains('anim-slide-out-R');
                        const delay = needsToWaitForSlideOut ? 500 : 0;
                        setTimeout(() => {
                            const side = slotEl.id.includes('-L') ? 'L' : 'R';
                            slotEl.classList.add(`anim-slide-in-${side}`);
                            setTimeout(() => slotEl.classList.remove(`anim-slide-out-${side}`, `anim-slide-in-${side}`), 500);
                        }, delay);
                    }
                };

                if (isNewCard || forceSlideIn) {
                    img.style.visibility = 'hidden';
                    img.onload = () => {
                        img.style.visibility = 'visible';
                        playAnimationIfNeeded();
                        img.onload = null;
                    };
                }
                img.src = getCardImageUrl(slotData.cardId);
                img.classList.toggle('is-v', cardData.pokemon && cardData.subtype === 'V');

                const hpUpdate = () => {
                    const hpTextEl = wrapper.querySelector('.battle-hp-text');
                    animateHp(hpTextEl, startHp, currentHp, startMaxHp, maxHp, 500);
                    const hpBar = wrapper.querySelector('.battle-hp-bar');
                    hpBar.style.width = `${hpPercent}%`;
                    hpBar.style.backgroundColor = hpColor;
                    if (hpChangeToShow !== 0) {
                        displayHpChangeNumber(slotEl, hpChangeToShow);
                    }
                };
                if (isUnderAttack) { setTimeout(hpUpdate, 1100); } else { hpUpdate(); }

                updateAttachedTools(slotEl, newToolIds, oldToolIds, true, isCardChanged);

                const energyContainer = wrapper.querySelector('.battle-attached-energies');
                renderAttachedEnergies(energyContainer, slotData.attachedEnergy, getEnergyIcon);

                updateStatusAilments(wrapper.querySelector('.battle-status-ailment'), newAilments, ailmentsBeforeChange);
                const skillsContainer = wrapper.querySelector('.battle-skills-container');
                skillsContainer.innerHTML = '';
                const allSkills = [...(cardData.pokemon.abilities || []), ...(cardData.pokemon.attacks || [])];
                allSkills.slice(0, 2).forEach(skill => {
                    const isAbility = !!skill.text && !skill.cost;
                    const abilityUsedClass = (isAbility && slotData.abilityUsed) ? 'used' : '';
                    let tagHtml = '';
                    if (isAbility) {
                        tagHtml = `<span class="battle-skill-ability-tag ${abilityUsedClass}">特 性</span>`;
                    } else {
                        const cost = skill.cost || [];
                        const iconsToRender = cost.length > 0 ? cost : [null];
                        const iconsHtml = iconsToRender.map(getEnergyIcon).join('');
                        tagHtml = `<div class="energy-cost-container">${iconsHtml}</div>`;
                    }
                    skillsContainer.innerHTML += `
                        <div class="skill-row-wrapper">
                            ${tagHtml}
                            <div class="battle-skill">
                                <div class="battle-skill-name-wrapper">
                                    <span class="battle-skill-name ${isAbility ? 'is-ability' : ''} ${abilityUsedClass}">${skill.name}</span>
                                </div>
                                <div class="battle-skill-damage">${sanitizeDamage(skill.damage)}</div>
                            </div>
                        </div>
                    `;
                });
            } else {
                let wrapper = slotEl.querySelector('.bench-pokemon-wrapper');
                // Determine if a forceRedraw is needed BEFORE the DOM is potentially wiped.
                const forceRedraw = !oldSlotData || !wrapper || slotEl.dataset.cardId !== slotData.cardId;

                const playAnimationIfNeeded = () => {
                    if ((isNewCard || forceSlideIn) && !skipSlideIn) {
                        const needsToWaitForSlideOut = slotEl.classList.contains('anim-slide-out-L') || slotEl.classList.contains('anim-slide-out-R');
                        const delay = needsToWaitForSlideOut ? 500 : 0;
                        setTimeout(() => {
                            const side = slotEl.id.includes('-L') ? 'L' : 'R';
                            slotEl.classList.add(`anim-slide-in-${side}`);
                            setTimeout(() => slotEl.classList.remove(`anim-slide-out-${side}`, `anim-slide-in-${side}`), 500);
                        }, delay);
                    }
                };

                if (forceRedraw) {
                    slotEl.innerHTML = `
                        <div class="bench-pokemon-wrapper">
                            <div class="bench-card-image-area">
                                <img class="bench-pokemon-image">
                                <div class="bench-attached-energies"></div>
                                <div class="bench-attached-tools-wrapper"></div>
                            </div>
                            <div class="bench-info-area">
                                <div class="bench-pokemon-name">${cardData.name}</div>
                                <div class="bench-hp-gauge">
                                    <div class="bench-hp-bar-container">
                                        <div class="bench-hp-text"></div>
                                        <div class="bench-hp-bar"></div>
                                    </div>
                                </div>
                                <div class="bench-skills-container"></div>
                            </div>
                        </div>`;
                    wrapper = slotEl.querySelector('.bench-pokemon-wrapper');
                    slotEl.dataset.cardId = slotData.cardId;

                    const mainImg = wrapper.querySelector('.bench-pokemon-image');
                    mainImg.style.visibility = 'hidden';
                    mainImg.onload = () => {
                        mainImg.style.visibility = 'visible';
                        playAnimationIfNeeded();
                        mainImg.onload = null;
                    };
                    mainImg.src = getCardImageUrl(slotData.cardId);
                    mainImg.classList.toggle('is-v', cardData.pokemon && cardData.subtype === 'V');
                } else if (forceSlideIn) {
                    playAnimationIfNeeded();
                }
                wrapper.classList.remove('hidden');
                const skillsContainer = wrapper.querySelector('.bench-skills-container');
                const allSkills = [...(cardData.pokemon.abilities || []), ...(cardData.pokemon.attacks || [])];
                let skillsHtml = '';
                allSkills.slice(0, 2).forEach(skill => {
                    const isAbility = !!skill.text && !skill.cost;
                    const abilityUsedClass = (isAbility && slotData.abilityUsed) ? 'used' : '';
                    let tagHtml = '';
                    if (isAbility) {
                        tagHtml = `<span class="bench-skill-ability-tag ${abilityUsedClass}">特 性</span>`;
                    } else {
                        const cost = skill.cost || [];
                        const iconsToRender = cost.length > 0 ? cost : [null];
                        const iconsHtml = iconsToRender.map(getEnergyIcon).join('');
                        tagHtml = `<div class="bench-energy-cost-container">${iconsHtml}</div>`;
                    }
                    skillsHtml += `
                        <div class="bench-skill-row-wrapper">
                            ${tagHtml}
                            <div class="bench-skill">
                                <div class="bench-skill-name-wrapper"><span class="bench-skill-name ${isAbility ? 'is-ability' : ''} ${abilityUsedClass}">${skill.name}</span></div>
                                <div class="bench-skill-damage">${sanitizeDamage(skill.damage)}</div>
                            </div>
                        </div>`;
                });
                skillsContainer.innerHTML = skillsHtml;

                updateAttachedTools(slotEl, newToolIds, oldToolIds, false, forceRedraw);

                const hpUpdate = () => {
                    const hpTextEl = wrapper.querySelector('.bench-hp-text');
                    const hpBarEl = wrapper.querySelector('.bench-hp-bar');
                    animateHp(hpTextEl, startHp, currentHp, startMaxHp, maxHp, 500);
                    hpBarEl.style.width = `${hpPercent}%`;
                    hpBarEl.style.backgroundColor = hpColor;
                    if (hpChangeToShow !== 0) {
                        displayHpChangeNumber(slotEl, hpChangeToShow);
                    }
                };
                if (isUnderAttack) { setTimeout(hpUpdate, 1100); } else { hpUpdate(); }

                const energyContainer = wrapper.querySelector('.bench-attached-energies');
                const getBenchEnergyIcon = (type) => `<img class="energy-icon" src="/assets/ptcg-telop/energy/${ENERGY_MAP[type] || 'エネなし'}.png">`;
                renderAttachedEnergies(energyContainer, slotData.attachedEnergy, getBenchEnergyIcon);
            }
            if (slotData && slotData.evolutionSelect) {
                delete slotData.evolutionSelect;
            }
            if (slotData && slotData.forceSlideIn) {
                delete slotData.forceSlideIn;
            }
        }

        // After the page loads, start preloading all assets
        const videosToPreload = [
            // KO & Evolve FX
            '/assets/ptcg-telop/fx/active_ko.webm',
            '/assets/ptcg-telop/fx/active-evolve.webm',
            '/assets/ptcg-telop/fx/active-mega-evolve.webm',
            '/assets/ptcg-telop/fx/active-replace.webm',
            '/assets/ptcg-telop/fx/active-devolve.webm',
            '/assets/ptcg-telop/fx/bench_ko.webm',
            '/assets/ptcg-telop/fx/bench-replace.webm',
            '/assets/ptcg-telop/fx/bench-devolve.webm',
            '/assets/ptcg-telop/fx/bench-evolve.webm',
            '/assets/ptcg-telop/fx/bench-mega-evolve.webm',
            // Hit FX
            '/assets/ptcg-telop/fx/hit-colorless.webm',
            '/assets/ptcg-telop/fx/hit-darkness.webm',
            '/assets/ptcg-telop/fx/hit-dragon.webm',
            '/assets/ptcg-telop/fx/hit-fighting.webm',
            '/assets/ptcg-telop/fx/hit-fire.webm',
            '/assets/ptcg-telop/fx/hit-grass.webm',
            '/assets/ptcg-telop/fx/hit-lightning.webm',
            '/assets/ptcg-telop/fx/hit-metal.webm',
            '/assets/ptcg-telop/fx/hit-psychic.webm',
            '/assets/ptcg-telop/fx/hit-water.webm',
            '/assets/ptcg-telop/fx/hit-fairy.webm', 
            // Misc FX
            '/assets/ptcg-telop/fx/Speedline.webm',
            '/assets/ptcg-telop/fx/tool-attach.webm',
            '/assets/ptcg-telop/fx/tool-remove.webm'
        ];

        const imagesToPreload = [
            // Background and UI elements
            '/assets/ptcg-telop/element/panel-bg.png',
            '/assets/ptcg-telop/element/active-bg.png',
            '/assets/ptcg-telop/element/bench-bg.png',
            '/assets/ptcg-telop/element/current.png',
            '/assets/ptcg-telop/element/VSTAR.webp',
            '/assets/ptcg-telop/element/weakness.png',
            '/assets/ptcg-telop/element/Beginner.png',
            '/assets/ptcg-telop/element/Poké_Ball.png', 
            // Player action icons
            '/assets/ptcg-telop/element/action-energy.png',
            '/assets/ptcg-telop/element/action-supporter.png',
            '/assets/ptcg-telop/element/action-retreat.png', 
            // Status condition icons
            '/assets/ptcg-telop/status/Poisoned.png',
            '/assets/ptcg-telop/status/Burned.png',
            '/assets/ptcg-telop/status/Asleep.png',
            '/assets/ptcg-telop/status/Paralyzed.png',
            '/assets/ptcg-telop/status/Confused.png', 
            // Energy icons (dynamically generated)
            ...Object.values(ENERGY_MAP).map(type => `/assets/ptcg-telop/energy/${type}.png`)
        ].filter((v, i, a) => a.indexOf(v) === i); // Deduplicate, just in case

        const preloaderContainer = document.getElementById('video-preloader');
        if (preloaderContainer) {
            // Preload videos
            videosToPreload.forEach(src => {
                const video = document.createElement('video');
                video.src = src;
                video.preload = 'auto';
                video.muted = true;
                video.playsInline = true;
                video.load();
                preloaderContainer.appendChild(video);
            });

            // Preload images
            imagesToPreload.forEach(src => {
                const img = document.createElement('img');
                img.src = src;
                preloaderContainer.appendChild(img);
            });
        }
        

        const i18nStrings = nodecg.Replicant('i18nStrings');
        const language = nodecg.Replicant('language');

        // A more descriptive function name for getting translated text
        const getI18nText = (key) => {
            if (!i18nStrings.value || !i18nStrings.value[key] || !language.value) {
                return key; // Fallback to key name if not found
            }
            // Return the text for the current language, or fallback to Japanese, then the key itself.
            return i18nStrings.value[key][language.value] || i18nStrings.value[key]['jp'] || key;
        };

        // --- Language Font Switching ---
        function setLanguageClass(lang) {
            const supportedLangs = ['jp', 'chs', 'en'];
            
            // Remove any existing language classes
            supportedLangs.forEach(l => {
                document.body.classList.remove(`lang-${l}`);
            });

            // Add the new one if it's valid
            if (lang && supportedLangs.includes(lang)) {
                document.body.classList.add(`lang-${lang}`);
            }
        }

        language.on('change', (newLang) => {
            setLanguageClass(newLang);
        });
        // --- End Language Font Switching ---


        const cardDatabase = nodecg.Replicant('cardDatabase');
        const assetPaths = nodecg.Replicant('assetPaths');
        const playerL_name = nodecg.Replicant('playerL_name');
        const playerR_name = nodecg.Replicant('playerR_name');
        const vstarUsedL = nodecg.Replicant('live_vstar_L');
        const vstarUsedR = nodecg.Replicant('live_vstar_R');
        const live_sideL = nodecg.Replicant('live_sideL');
        const live_sideR = nodecg.Replicant('live_sideR');
        const live_stadium = nodecg.Replicant('live_stadium');
        const live_currentTurn = nodecg.Replicant('live_currentTurn');
        const settingsRep = nodecg.Replicant('ptcg-settings');
        const firstMove = nodecg.Replicant('firstMove');
        const live_lostZoneL = nodecg.Replicant('live_lostZoneL');
        const live_lostZoneR = nodecg.Replicant('live_lostZoneR');
        const deckL = nodecg.Replicant('deckL');
        const deckR = nodecg.Replicant('deckR');
        const actionTypes = ['energy', 'supporter', 'retreat'];
        const sides = ['L', 'R'];
        const live_slotReplicants = {};
        const replicantList = [
            cardDatabase, assetPaths, playerL_name, playerR_name,
            vstarUsedL, vstarUsedR,
            live_sideL, live_sideR, live_stadium, live_currentTurn, settingsRep, firstMove,
            live_lostZoneL, live_lostZoneR,
            deckL, deckR, language,
            i18nStrings
        ];
        sides.forEach(side => {
            actionTypes.forEach(action => {
                replicantList.push(nodecg.Replicant(`live_action_${action}_${side}`));
            });
            for (let i = 0; i < 6; i++) {
                const id = `live_slot${side}${i}`;
                const replicant = nodecg.Replicant(id);
                live_slotReplicants[id] = replicant;
                replicantList.push(replicant);
            }
        });

        function playVideoOnSlot(targetEl, videoSrc) {
            const isBattleSlot = targetEl.id.endsWith('0');
            const imageSelector = isBattleSlot ? '.battle-pokemon-image' : '.bench-pokemon-image';
            const cardImage = targetEl.querySelector(imageSelector);
            const targetRect = targetEl.getBoundingClientRect();
            const videoContainer = document.createElement('div');
            videoContainer.style.position = 'absolute';
            videoContainer.style.left = `${targetRect.left}px`;
            videoContainer.style.top = `${targetRect.top}px`;
            videoContainer.style.width = `${targetRect.width}px`;
            videoContainer.style.height = `${targetRect.height}px`;
            videoContainer.style.zIndex = '300';
            videoContainer.style.overflow = 'hidden';
            const video = document.createElement('video');
            video.src = videoSrc;
            video.muted = true;
            video.style.width = '100%';
            video.style.height = '100%';
            videoContainer.appendChild(video);
            document.body.appendChild(videoContainer);
            video.play();
            setTimeout(() => { if (cardImage) cardImage.style.visibility = 'hidden'; }, REPLACE_ANIMATION_HIDE_MS);
            setTimeout(() => { if (cardImage) cardImage.style.visibility = 'visible'; }, REPLACE_ANIMATION_SHOW_MS);
            video.addEventListener('ended', () => videoContainer.remove());
        }
        
        NodeCG.waitForReplicants(...replicantList).then(() => {
            // Set initial language class to ensure correct fonts are loaded.
            // Default to 'jp' if the replicant has no value yet.
            setLanguageClass(language.value || 'jp');

            updatePlayerInfo('L', playerL_name.value);
            updatePlayerInfo('R', playerR_name.value);
            updateVstarIcon('L', vstarUsedL.value);
            updateVstarIcon('R', vstarUsedR.value);
            updateSideArea('L', live_sideL.value);
            updateSideArea('R', live_sideR.value);
            renderStadium(live_stadium.value, { cardId: null });
            updateCurrentTurnBorder(live_currentTurn.value);
            sides.forEach(side => {
                actionTypes.forEach(action => {
                    const rep = nodecg.Replicant(`live_action_${action}_${side}`);
                    updateActionIcon(side, action, rep.value);
                    rep.on('change', (newVal) => updateActionIcon(side, action, newVal));
                });
                for (let i = 0; i < 6; i++) {
                    const replicant = live_slotReplicants[`live_slot${side}${i}`];
                    renderSlot(side, i, replicant.value, null);
                    replicant.on('change', (newVal, oldVal) => {
                        if (!oldVal) {
                            return;
                        }
                        renderSlot(side, i, newVal, oldVal);
                    });
                }
            });
            playerL_name.on('change', (val) => updatePlayerInfo('L', val));
            playerR_name.on('change', (val) => updatePlayerInfo('R', val));
            vstarUsedL.on('change', (val) => updateVstarIcon('L', val));
            vstarUsedR.on('change', (val) => updateVstarIcon('R', val));
            live_sideL.on('change', (val) => updateSideArea('L', val));
            live_sideR.on('change', (val) => updateSideArea('R', val));
            live_stadium.on('change', (newVal, oldVal) => renderStadium(newVal, oldVal || { cardId: null }));
            live_currentTurn.on('change', (val) => updateCurrentTurnBorder(val));
            updateFirstMoveIcon(firstMove.value);
            firstMove.on('change', (val) => updateFirstMoveIcon(val));
            updateLostZoneCounter('L', live_lostZoneL.value);
            updateLostZoneCounter('R', live_lostZoneR.value);
            live_lostZoneL.on('change', (val) => updateLostZoneCounter('L', val));
            live_lostZoneR.on('change', (val) => updateLostZoneCounter('R', val));

            const preloaderContainer = document.getElementById('video-preloader');
            function preloadDeckImages(deck) {
                if (!deck || !deck.cards || !assetPaths.value.cardImgPath || !preloaderContainer) return;
                
                const cardImgPath = `/${assetPaths.value.cardImgPath}`;

                deck.cards.forEach(cardId => {
                    // Check if image is already preloading/preloaded to avoid duplicates
                    if (!preloaderContainer.querySelector(`img[src="${cardImgPath}${cardId}.jpg"]`)) {
                        const img = document.createElement('img');
                        img.src = `${cardImgPath}${cardId}.jpg`;
                        preloaderContainer.appendChild(img);
                    }
                });
            }

            // Initial preload for both decks
            preloadDeckImages(deckL.value);
            preloadDeckImages(deckR.value);

            // Listen for changes in both decks
            deckL.on('change', (newVal) => preloadDeckImages(newVal));
            deckR.on('change', (newVal) => preloadDeckImages(newVal));

            // Listener for VSTAR enabled/disabled setting
            const handleVstarVisibility = (settings) => {
                const vstarL_icon = document.getElementById('vstar-L-icon');
                const vstarR_icon = document.getElementById('vstar-R-icon');
                const enabled = settings && settings.vstarEnabled;
                if (vstarL_icon) vstarL_icon.classList.toggle('hidden', !enabled);
                if (vstarR_icon) vstarR_icon.classList.toggle('hidden', !enabled);
            };

            settingsRep.on('change', (newValue) => {
                // Handle VSTAR visibility
                handleVstarVisibility(newValue);

                // Handle type stroke color changes
                const oldStroke = settingsRep.value ? settingsRep.value.useTypeStroke : false;
                const newStroke = newValue ? newValue.useTypeStroke : false;
                if (newStroke !== oldStroke) {
                    sides.forEach(side => {
                        for (let i = 0; i < 6; i++) {
                            const replicant = live_slotReplicants[`live_slot${side}${i}`];
                            renderSlot(side, i, replicant.value, null);
                        }
                    });
                }
            });
            
            // Initial visibility check on load
            handleVstarVisibility(settingsRep.value);

            nodecg.listenFor('playAnimation', (animation) => {
                if (!animation || !animation.type) {
                    console.error('Invalid animation data received:', animation);
                    return;
                }

                if (animation.type === 'SWITCH_POKEMON') {
                    if (!animation.source || !animation.target) {
                        console.error('Invalid PROMOTE animation data:', animation);
                        return;
                    }
                    const sourceEl = document.getElementById(animation.source);
                    const targetEl = document.getElementById(animation.target);

                    if (sourceEl && !sourceEl.classList.contains('is-empty')) {
                        const side = animation.source.includes('-L') ? 'L' : 'R';
                        sourceEl.classList.add(`anim-slide-out-${side}`);
                    }
                    if (targetEl && !targetEl.classList.contains('is-empty')) {
                        const side = animation.target.includes('-L') ? 'L' : 'R';
                        targetEl.classList.add(`anim-slide-out-${side}`);
                    }
                    return; // End PROMOTE logic here.
                }

                // For all other animations, target is required and must be in this document.
                if (!animation.target) {
                    console.error('Animation requires a target:', animation);
                    return;
                }
                const targetEl = document.getElementById(animation.target);
                if (!targetEl) {
                    // This is expected if the target is in the other graphic, so don't log an error.
                    return;
                }
                const side = animation.target.includes('-L') ? 'L' : 'R';
                
                if (animation.type === 'EVOLVE_POKEMON') {
                    const db = cardDatabase.value;
                    const isBattleSlot = animation.target.endsWith('0');
                    let videoSrc = isBattleSlot ? '/assets/ptcg-telop/fx/active-evolve.webm' : '/assets/ptcg-telop/fx/bench-evolve.webm';

                    // Check for Mega Evolution
                    if (animation.cardId && db && db[animation.cardId]) {
                        const cardData = db[animation.cardId];
                        if (cardData.pokemon && cardData.pokemon.option && cardData.pokemon.option.toLowerCase() === 'mega') {
                            videoSrc = isBattleSlot ? '/assets/ptcg-telop/fx/active-mega-evolve.webm' : '/assets/ptcg-telop/fx/bench-mega-evolve.webm';
                        }
                    }
                    playVideoOnSlot(targetEl, videoSrc);
                } else if (animation.type === 'DEVOLVE_POKEMON') {
                    const isBattleSlot = animation.target.endsWith('0');
                    const videoSrc = isBattleSlot ? '/assets/ptcg-telop/fx/active-devolve.webm' : '/assets/ptcg-telop/fx/bench-devolve.webm';
                    playVideoOnSlot(targetEl, videoSrc);
                } else if (animation.type === 'REPLACE_POKEMON') {
                    const isBattleSlot = animation.target.endsWith('0');
                    const videoSrc = isBattleSlot ? '/assets/ptcg-telop/fx/active-replace.webm' : '/assets/ptcg-telop/fx/bench-replace.webm';
                    playVideoOnSlot(targetEl, videoSrc);
                } else if (animation.type === 'KO_POKEMON') {
                    const isBattleSlot = animation.target.endsWith('0');
                    const videoSrc = isBattleSlot ? '/assets/ptcg-telop/fx/active_ko.webm' : '/assets/ptcg-telop/fx/bench_ko.webm';
                    const imageSelector = isBattleSlot ? '.battle-pokemon-image' : '.bench-pokemon-image';
                    const koVideo = document.createElement('video');
                    koVideo.src = videoSrc;
                    koVideo.muted = true;
                    koVideo.style.position = 'absolute';
                    koVideo.style.width = '100%';
                    koVideo.style.height = '100%';
                    koVideo.style.left = isBattleSlot ? '0' : '-4px';
                    koVideo.style.top = '0';
                    koVideo.style.zIndex = '200';
                    targetEl.appendChild(koVideo);
                    koVideo.play();
                    setTimeout(() => {
                        const cardImage = targetEl.querySelector(imageSelector);
                        if (cardImage) cardImage.style.visibility = 'hidden';
                    }, 85);
                    koVideo.addEventListener('ended', () => {
                        koVideo.remove();
                        targetEl.classList.add(`anim-slide-out-${side}`);
                    });

                } else if (animation.type === 'EXIT_POKEMON') {
                    targetEl.classList.add(`anim-slide-out-${side}`);
                } else if (animation.type === 'ENTER_POKEMON') {
                    targetEl.classList.remove('anim-slide-out-L', 'anim-slide-out-R');
                    const animationClass = `anim-slide-in-${side}`;
                    targetEl.classList.add(animationClass);
                    targetEl.addEventListener('animationend', () => {
                        targetEl.classList.remove(animationClass);
                    }, { once: true });
                }
            });

            nodecg.listenFor('attack-fx', (data) => {
                console.log('Received attack-fx:', data);

                data.targets.forEach(targetInfo => {
                    g_attackAnimationTargets.add(targetInfo.targetId.replace('slot', 'slot-'));
                });

                // --- New Attack FX Logic ---
                const fxContainer = document.getElementById('attack-fx-container');
                const videoEl = fxContainer.querySelector('.attack-fx-video');
                const moveNameEl = fxContainer.querySelector('.attack-fx-move-name');
                const attackerNameEl = fxContainer.querySelector('.attack-fx-attacker-name');
                
                // Set content
                moveNameEl.textContent = data.moveName;
                attackerNameEl.textContent = data.attackerName;

                // Set color based on type
                const typeClass = `type-${(data.attackerType || '無').toLowerCase()}`;
                // Reset classes before adding new ones
                fxContainer.className = ''; 
                // Force a reflow to restart the animation. Very important.
                void fxContainer.offsetWidth; 

                fxContainer.classList.add('active', typeClass);

                // Trigger animation
                const animationClass = `animate-${data.attackerSide}`;
                fxContainer.classList.add(animationClass);

                videoEl.currentTime = 0;
                videoEl.play();

                let hasAnimationEnded = false;
                const onAnimationEnd = () => {
                    if (hasAnimationEnded) return;
                    hasAnimationEnded = true;

                    // 1. Play hit effects and HP numbers after the main animation is done.
                    data.targets.forEach(targetInfo => {
                        const targetEl = document.getElementById(targetInfo.targetId.replace('slot', 'slot-'));
                        if (!targetEl) return;
                        const isBattleSlot = targetInfo.targetId.endsWith('0');
                        const cardImageSelector = isBattleSlot ? '.battle-card-image-area' : '.bench-card-image-area';
                        const cardImageEl = targetEl.querySelector(cardImageSelector);
                        if (!cardImageEl) return;
                        const imageRect = cardImageEl.getBoundingClientRect();
                        const causedDamage = targetInfo.damage > 0;
                        const isOpponent = data.attackerSide !== targetInfo.targetSide;
                        if (causedDamage) {
                            setTimeout(() => {
                                cardImageEl.classList.add('anim-shake', 'anim-flash-white');
                                setTimeout(() => cardImageEl.classList.remove('anim-shake', 'anim-flash-white'), 400);
                            }, 50);
                        }
                        if (isOpponent || causedDamage) {
                            const videoSize = isBattleSlot ? 350 : 200;
                            const hitVideo = document.createElement('video');
                            hitVideo.className = 'hit-effect';
                            hitVideo.src = getHitVideoSrc(data.attackerType);
                            hitVideo.muted = true;
                            hitVideo.autoplay = true;
                            hitVideo.style.width = `${videoSize}px`;
                            hitVideo.style.height = `${videoSize}px`;
                            hitVideo.style.left = `${imageRect.left + (imageRect.width / 2) - (videoSize / 2)}px`;
                            hitVideo.style.top = `${imageRect.top + (imageRect.height / 2) - (videoSize / 2)}px`;
                            document.body.appendChild(hitVideo);
                            hitVideo.addEventListener('ended', () => hitVideo.remove());
                        }
                    });

                    // 2. Then hide the attack bar
                    fxContainer.classList.remove('active', animationClass, typeClass);
                    
                    // 4. Clean up listeners to prevent multiple triggers
                    videoEl.removeEventListener('ended', onAnimationEnd);
                    fxContainer.removeEventListener('animationend', onAnimationEnd);

                    // 5. Clear the global set
                    g_attackAnimationTargets.clear();
                };
                
                videoEl.addEventListener('ended', onAnimationEnd);
                // As a fallback, also listen for the CSS animation to end
                fxContainer.addEventListener('animationend', (e) => {
                    // Ensure we're responding to the animation on the container itself
                    if (e.target === fxContainer) {
                        onAnimationEnd();
                    }
                });

                // Safety timeout to prevent it from staying visible forever
                setTimeout(onAnimationEnd, 2000);

                // --- End New Attack FX Logic ---

                // Immediately iterate over targets to set up weakness flags for the upcoming render.
                data.targets.forEach(targetInfo => {
                    const targetEl = document.getElementById(targetInfo.targetId.replace('slot', 'slot-'));
                    const causedDamage = targetInfo.damage > 0;
                    const isBattleSlot = targetInfo.targetId.endsWith('0');
                    if (causedDamage && targetInfo.isWeakness && isBattleSlot) {
                        activeAnimations.set(targetEl.id, { isWeakness: true });
                    }
                });
            });
        }).catch(err => console.error("Replicants failed to load:", err));
    });
    </script>
</body>
</html>