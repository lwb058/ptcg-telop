<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Main Graphic</title>
    <!-- All common styles are now in common.css -->
    <link rel="stylesheet" href="css/fonts.css">
    <script>
        // Dynamically preload fonts based on fonts.css
        (function () {
            fetch('css/fonts.css')
                .then(response => response.text())
                .then(text => {
                    const fontUrlRegex = /url\((['"]?)(.+?\.(?:ttf|otf|woff|woff2))\1\)/g;
                    let match;
                    while ((match = fontUrlRegex.exec(text)) !== null) {
                        const fontUrl = match[2];
                        const link = document.createElement('link');
                        link.rel = 'preload';
                        link.href = fontUrl;
                        link.as = 'font';
                        link.type = `font/${fontUrl.split('.').pop()}`;
                        link.crossOrigin = 'anonymous';
                        document.head.appendChild(link);
                    }
                }).catch(err => console.error('Failed to preload fonts:', err));
        })();
    </script>
    <link rel="stylesheet" href="css/common.css">
    <link id="theme-css-L" rel="stylesheet" href="" disabled>
    <link id="theme-css-R" rel="stylesheet" href="" disabled>
    <style>
        /* All styles have been moved to graphics/css/common.css */
    </style>
</head>

<body>
    <!-- SVG Filter Definitions for Text Effects -->
    <svg width="0" height="0" style="position:absolute;z-index:-1;">
        <defs>
            <!-- Battle Filter -->
            <filter id="text-stroke-shadow-battle" x="-50%" y="-50%" width="200%" height="200%">
                <feDropShadow dx="-4" dy="6" stdDeviation="2" flood-color="#00000099" result="shadow" />
                <feMorphology in="SourceAlpha" result="stroke" operator="dilate" radius="4"></feMorphology>
                <feFlood flood-color="#000b1a" result="stroke-color" />
                <feComposite in="stroke-color" in2="stroke" operator="in" result="stroke-shape" />
                <feMerge>
                    <feMergeNode in="shadow" />
                    <feMergeNode in="stroke-shape" />
                    <feMergeNode in="SourceGraphic" />
                </feMerge>
            </filter>
            <!-- Bench Filter -->
            <filter id="text-stroke-shadow-bench" x="-50%" y="-50%" width="200%" height="200%">
                <feDropShadow dx="4" dy="4" stdDeviation="2" flood-color="#00000099" result="shadow" />
                <feMorphology in="SourceAlpha" result="stroke" operator="dilate" radius="3"></feMorphology>
                <feFlood flood-color="#000b1a" result="stroke-color" />
                <feComposite in="stroke-color" in2="stroke" operator="in" result="stroke-shape" />
                <feMerge>
                    <feMergeNode in="shadow" />
                    <feMergeNode in="stroke-shape" />
                    <feMergeNode in="SourceGraphic" />
                </feMerge>
            </filter>
        </defs>
    </svg>
    <div class="overlay-frame">
        <!-- Current Turn Borders (positioned at the bottom layer) -->
        <div id="current-L-border" class="current-turn-border"></div>
        <div id="current-R-border" class="current-turn-border"></div>

        <!-- Player L Area -->
        <div class="player-area" id="player-L-area">
            <div class="player-info" id="player-L-info">
                <img class="first-move-icon hidden" id="first-move-L"
                    src="/assets/ptcg-telop/element/first_move_jp.png">
                <span class="player-name" id="player-L-name"></span>
                <img src="/assets/ptcg-telop/element/VSTAR.webp" class="vstar-icon" id="vstar-L-icon">
            </div>
            <div class="active-slot" id="slot-L0">
                <div class="active-pokemon-wrapper hidden">
                    <div class="pokemon-name"></div>
                    <div class="card-image-area">
                        <img class="pokemon-image">
                        <div class="status-ailment"></div>
                        <div class="attached-energies"></div>
                        <div class="attached-tools-wrapper"></div>
                    </div>
                    <div class="hp-gauge">
                        <div class="hp-bar-container">
                            <div class="hp-text"></div>
                            <div class="hp-bar"></div>
                        </div>
                    </div>
                    <div class="skills-container"></div>
                </div>
            </div>
            <div class="bench-slots">
                <div class="bench-slot" id="slot-L1"></div>
                <div class="bench-slot" id="slot-L2"></div>
                <div class="bench-slot" id="slot-L3"></div>
                <div class="bench-slot" id="slot-L4"></div>
                <div class="bench-slot" id="slot-L5"></div>
            </div>
            <div class="player-action">
                <img class="action-icon" id="action-L-energy" src="/assets/ptcg-telop/element/action-energy.png"
                    title="Energy Action">
                <img class="action-icon" id="action-L-supporter" src="/assets/ptcg-telop/element/action-supporter.png"
                    title="Supporter Action">
                <img class="action-icon" id="action-L-retreat" src="/assets/ptcg-telop/element/action-retreat.png"
                    title="Retreat Action">
            </div>
        </div>
        <!-- Player R Area -->
        <div class="player-area" id="player-R-area">
            <div class="player-info" id="player-R-info">
                <img class="first-move-icon hidden" id="first-move-R"
                    src="/assets/ptcg-telop/element/first_move_jp.png">
                <span class="player-name" id="player-R-name"></span>
                <img src="/assets/ptcg-telop/element/VSTAR.webp" class="vstar-icon" id="vstar-R-icon">
            </div>
            <div class="active-slot" id="slot-R0">
                <div class="active-pokemon-wrapper hidden">
                    <div class="pokemon-name"></div>
                    <div class="card-image-area">
                        <img class="pokemon-image">
                        <div class="status-ailment"></div>
                        <div class="attached-energies"></div>
                        <div class="attached-tools-wrapper"></div>
                    </div>
                    <div class="hp-gauge">
                        <div class="hp-bar-container">
                            <div class="hp-text"></div>
                            <div class="hp-bar"></div>
                        </div>
                    </div>
                    <div class="skills-container"></div>
                </div>
            </div>
            <div class="bench-slots">
                <div class="bench-slot" id="slot-R1"></div>
                <div class="bench-slot" id="slot-R2"></div>
                <div class="bench-slot" id="slot-R3"></div>
                <div class="bench-slot" id="slot-R4"></div>
                <div class="bench-slot" id="slot-R5"></div>
            </div>
            <div class="player-action">
                <img class="action-icon" id="action-R-energy" src="/assets/ptcg-telop/element/action-energy.png"
                    title="Energy Action">
                <img class="action-icon" id="action-R-supporter" src="/assets/ptcg-telop/element/action-supporter.png"
                    title="Supporter Action">
                <img class="action-icon" id="action-R-retreat" src="/assets/ptcg-telop/element/action-retreat.png"
                    title="Retreat Action">
            </div>
        </div>

        <!-- Stadium Area -->
        <div id="stadium-area">
            <div id="stadium-card" class="hidden">
                <span id="stadium-name"></span>
            </div>
        </div>

        <!-- Side Areas -->
        <div class="side-area" id="side-L-area">
            <img class="side-icon" alt=""><img class="side-icon" alt=""><img class="side-icon" alt="">
            <img class="side-icon" alt=""><img class="side-icon" alt=""><img class="side-icon" alt="">
        </div>
        <div id="lost-zone-L-area" class="lost-zone-counter">
            <img src="/assets/ptcg-telop/element/lost-zone_jp.png" alt="Lost Zone Icon">
            <span class="count">0</span>
        </div>
        <div class="side-area" id="side-R-area">
            <img class="side-icon" alt=""><img class="side-icon" alt=""><img class="side-icon" alt="">
            <img class="side-icon" alt=""><img class="side-icon" alt=""><img class="side-icon" alt="">
        </div>
        <div id="lost-zone-R-area" class="lost-zone-counter">
            <img src="/assets/ptcg-telop/element/lost-zone_jp.png" alt="Lost Zone Icon">
            <span class="count">0</span>
        </div>
    </div>

    <!-- Attack FX -->
    <div id="attack-fx-container">
        <video class="attack-fx-video" src="/assets/ptcg-telop/fx/Speedline.webm" muted></video>
        <div class="attack-fx-bar">
            <div class="attack-fx-upper">
                <span class="attack-fx-move-name"></span>
            </div>
            <div class="attack-fx-lower">
                <span class="attack-fx-attacker-name"></span>
            </div>
        </div>
    </div>

    <!-- Preloader Container for FX Videos (Hidden) -->
    <div id="video-preloader"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const getCardImageUrl = (cardId, isBgImage = false) => {
                if (!cardId || !assetPaths.value.cardImgPath) {
                    return isBgImage ? 'none' : '';
                }
                const db = cardDatabase.value;
                const cardData = db ? db[cardId] : null;
                const imageUrl = cardData ? cardData.image_url : null;
                const extension = imageUrl ? imageUrl.substring(imageUrl.lastIndexOf('.')) : '.jpg';
                const path = `/${assetPaths.value.cardImgPath}${cardId}${extension}`;
                return isBgImage ? `url(${path})` : path;
            };

            const ENERGY_MAP = {
                "草": "草", "炎": "炎", "水": "水", "雷": "雷", "超": "超", "闘": "闘", "悪": "悪", "鋼": "鋼",
                "無": "無", "全": "全", "竜": "竜", "妖": "妖"
            };

            const REPLACE_ANIMATION_HIDE_MS = 550;
            const REPLACE_ANIMATION_SHOW_MS = 700;

            const activeAnimations = new Map();
            const g_attackAnimationTargets = new Set();
            const evolvingSlots = new Set();
            const koSlots = new Set();
            const removingSlots = new Set();

            function hexToRgba(hex, alpha = 1.0) {
                if (!/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
                    return '';
                }
                let c = hex.substring(1).split('');
                if (c.length === 3) {
                    c = [c[0], c[0], c[1], c[1], c[2], c[2]];
                }
                c = '0x' + c.join('');
                const r = (c >> 16) & 255;
                const g = (c >> 8) & 255;
                const b = c & 255;
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            function animateHp(element, startHp, endHp, startMaxHp, endMaxHp, duration) {
                return new Promise(resolve => {
                    if (!element) return resolve();
                    if (startHp === endHp && startMaxHp === endMaxHp) {
                        element.textContent = `${endHp}/${endMaxHp}`;
                        return resolve();
                    }
                    let startTimestamp = null;
                    const step = (timestamp) => {
                        if (!startTimestamp) startTimestamp = timestamp;
                        const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                        const rawCurrentHp = progress * (endHp - startHp) + startHp;
                        const rawCurrentMaxHp = progress * (endMaxHp - startMaxHp) + startMaxHp;
                        let displayHp, displayMaxHp;
                        if (progress < 1) {
                            displayHp = Math.round(rawCurrentHp / 10) * 10;
                            displayMaxHp = Math.round(rawCurrentMaxHp / 10) * 10;
                        } else {
                            displayHp = endHp;
                            displayMaxHp = endMaxHp;
                        }
                        element.textContent = `${displayHp}/${displayMaxHp}`;
                        if (progress < 1) {
                            window.requestAnimationFrame(step);
                        } else {
                            resolve();
                        }
                    };
                    window.requestAnimationFrame(step);
                });
            }

            function displayHpChangeNumber(targetSlotEl, hpChange) {
                return new Promise(resolve => {
                    if (hpChange === 0) return resolve();
                    const isHeal = hpChange > 0;
                    const number = Math.abs(hpChange);
                    const text = isHeal ? `+${number}` : `${-number}`;
                    const isBattleSlot = targetSlotEl.classList.contains('active-slot');
                    const numberTypeClass = isHeal ? 'heal-number' : 'damage-number';
                    const cardImageSelector = '.card-image-area';
                    const cardImageEl = targetSlotEl.querySelector(cardImageSelector);
                    if (!cardImageEl) return resolve();

                    requestAnimationFrame(() => {
                        const imageRect = cardImageEl.getBoundingClientRect();
                        const slotRect = targetSlotEl.getBoundingClientRect();
                        if (imageRect.width === 0) return resolve();
                        const numberEl = document.createElement('div');
                        numberEl.className = numberTypeClass;
                        numberEl.textContent = text;
                        // Calculate position relative to parent slot
                        const relativeLeft = imageRect.left - slotRect.left + imageRect.width / 2;
                        const relativeTop = imageRect.top - slotRect.top + imageRect.height / 2;
                        numberEl.style.left = `${relativeLeft}px`;
                        numberEl.style.top = `${relativeTop}px`;
                        targetSlotEl.appendChild(numberEl);

                        if (isBattleSlot && activeAnimations.has(targetSlotEl.id)) {
                            const animationData = activeAnimations.get(targetSlotEl.id);
                            if (animationData.isWeakness) {
                                const style = getComputedStyle(document.documentElement);
                                const weaknessFile = style.getPropertyValue('--asset-weakness').trim().replace(/['\"]/g, '');
                                const weaknessIconSrc = resolveAssetPath(weaknessFile);

                                const weaknessIcon = new Image();
                                weaknessIcon.src = weaknessIconSrc;
                                weaknessIcon.className = 'weakness-icon-fx';

                                const appendAndAnimate = () => {
                                    weaknessIcon.style.left = `${imageRect.left + imageRect.width / 2}px`;
                                    weaknessIcon.style.top = `${imageRect.top + imageRect.height / 2}px`;
                                    document.body.appendChild(weaknessIcon);
                                    setTimeout(() => weaknessIcon.remove(), 1500);
                                };

                                if (weaknessIcon.complete) {
                                    appendAndAnimate();
                                } else {
                                    weaknessIcon.onload = appendAndAnimate;
                                }
                            }
                            activeAnimations.delete(targetSlotEl.id);
                        }

                        setTimeout(() => {
                            numberEl.remove();
                            resolve();
                        }, 1500);
                    });
                });
            }

            function getHitVideoSrc(attackerType) {
                const basePath = '/assets/ptcg-telop/fx/';
                const typeMap = {
                    "草": "grass", "炎": "fire", "水": "water", "雷": "lightning", "超": "psychic",
                    "闘": "fighting", "悪": "darkness", "鋼": "metal", "竜": "dragon", "妖": "fairy", "無": "colorless"
                };
                const typeString = typeMap[attackerType] || 'colorless';
                return `${basePath}hit-${typeString}.webm`;
            }

            function renderStadium(newData, oldData) {
                const db = cardDatabase.value;
                const stadiumCardEl = document.getElementById('stadium-card');
                const stadiumNameEl = document.getElementById('stadium-name');

                const newCardId = newData ? newData.cardId : null;
                const oldCardId = oldData ? oldData.cardId : null;
                const newUsed = newData ? newData.used : false;
                const oldUsed = oldData ? oldData.used : false;

                if (newCardId === oldCardId && newUsed === oldUsed) return;

                const newCard = newCardId ? db[newCardId] : null;

                const updateContent = (card, isUsed) => {
                    if (card) {
                        stadiumNameEl.textContent = isUsed ? getI18nText('used') : card.name;
                        stadiumCardEl.style.backgroundImage = getCardImageUrl(newCardId, true);
                        stadiumCardEl.style.filter = isUsed ? 'grayscale(1)' : 'none';
                    } else {
                        stadiumNameEl.textContent = '';
                        stadiumCardEl.style.backgroundImage = 'none';
                        stadiumCardEl.style.filter = 'none';
                    }
                };

                if (newCardId !== oldCardId) {
                    if (oldCardId && newCardId) {
                        stadiumCardEl.classList.add('anim-slide-out-top');
                        setTimeout(() => {
                            updateContent(newCard, newUsed);
                            stadiumCardEl.classList.remove('anim-slide-out-top');
                            stadiumCardEl.classList.add('anim-slide-in-top');
                            setTimeout(() => stadiumCardEl.classList.remove('anim-slide-in-top'), 500);
                        }, 500);
                    } else if (!oldCardId && newCardId) {
                        updateContent(newCard, newUsed);
                        stadiumCardEl.classList.remove('hidden');
                        stadiumCardEl.classList.add('anim-slide-in-top');
                        setTimeout(() => stadiumCardEl.classList.remove('anim-slide-in-top'), 500);
                    } else if (oldCardId && !newCardId) {
                        stadiumCardEl.classList.add('anim-slide-out-top');
                        setTimeout(() => {
                            stadiumCardEl.classList.add('hidden');
                            stadiumCardEl.classList.remove('anim-slide-out-top');
                            updateContent(null, false);
                        }, 500);
                    }
                } else {
                    updateContent(newCard, newUsed);
                }
            }

            function updatePlayerInfo(side, name) {
                const el = document.getElementById(`player-${side}-name`);
                if (el) el.textContent = name || `Player ${side}`;
            }

            function updateVstarIcon(side, isUsed) {
                const el = document.getElementById(`vstar-${side}-icon`);
                if (el) {
                    el.classList.toggle('used', isUsed);
                    el.classList.toggle('available', !isUsed);
                }
            }

            function updateSideArea(side, remaining) {
                const area = document.getElementById(`side-${side}-area`);
                if (!area) return;

                const style = getComputedStyle(document.documentElement);
                const takenFile = style.getPropertyValue('--asset-side-taken').trim().replace(/['\"]/g, '');
                const remainFile = style.getPropertyValue('--asset-side-remain').trim().replace(/['\"]/g, '');

                const takenIcon = resolveAssetPath(takenFile, false, side);
                const remainingIcon = resolveAssetPath(remainFile, false, side);

                const icons = area.querySelectorAll('.side-icon');
                const taken = 6 - remaining;
                icons.forEach((icon, index) => {
                    icon.src = index < taken ? takenIcon : remainingIcon;
                });
            }

            // ... (keeping existing updateActionIcon) ...

            function updateThemeClasses(settings) {
                const updateSideClass = (side, themeName) => {
                    const playerArea = document.getElementById(`player-${side}-area`);
                    const sideArea = document.getElementById(`side-${side}-area`);
                    const lostZoneArea = document.getElementById(`lost-zone-${side}-area`);

                    if (playerArea) {
                        playerArea.className = `player-area ${themeName}`;
                    }
                    if (sideArea) {
                        sideArea.className = `side-area ${themeName}`;
                    }
                    if (lostZoneArea) {
                        const isVisible = lostZoneArea.classList.contains('visible');
                        lostZoneArea.className = `lost-zone-counter ${themeName}${isVisible ? ' visible' : ''}`;
                    }
                };

                const themeL = settings.activeTheme || 'Default';
                const themeR = (settings.activeThemeR === 'Follow Left') ? themeL : (settings.activeThemeR || 'Default');

                updateSideClass('L', themeL);
                updateSideClass('R', themeR);
            }

            function updateActionIcon(side, action, isUsed) {
                const el = document.getElementById(`action-${side}-${action}`);
                if (el) {
                    el.classList.toggle('used', isUsed);
                }
            }

            function updateFirstMoveIcon(firstMoveValue) {
                const iconL = document.getElementById('first-move-L');
                const iconR = document.getElementById('first-move-R');

                const style = getComputedStyle(document.documentElement);
                const firstMoveFile = style.getPropertyValue('--asset-first-move').trim().replace(/['\"]/g, '');
                const secondMoveFile = style.getPropertyValue('--asset-second-move').trim().replace(/['\"]/g, '');

                // Resolve icons for each side independently
                const firstMoveIconSrc_L = resolveAssetPath(firstMoveFile, true, 'L');
                const secondMoveIconSrc_L = resolveAssetPath(secondMoveFile, true, 'L');
                const firstMoveIconSrc_R = resolveAssetPath(firstMoveFile, true, 'R');
                const secondMoveIconSrc_R = resolveAssetPath(secondMoveFile, true, 'R');

                if (firstMoveValue === 'L') {
                    iconL.src = firstMoveIconSrc_L;
                    iconR.src = secondMoveIconSrc_R;
                    iconL.classList.remove('hidden');
                    iconR.classList.remove('hidden');
                } else if (firstMoveValue === 'R') {
                    iconL.src = secondMoveIconSrc_L;
                    iconR.src = firstMoveIconSrc_R;
                    iconL.classList.remove('hidden');
                    iconR.classList.remove('hidden');
                } else {
                    iconL.classList.add('hidden');
                    iconR.classList.add('hidden');
                }
            }

            function updateLostZoneCounter(side, count) {
                const el = document.getElementById(`lost-zone-${side}-area`);
                if (!el) return;

                const style = getComputedStyle(document.documentElement);
                const lostZoneFile = style.getPropertyValue('--asset-lost-zone').trim().replace(/['\"]/g, '');
                const lostZoneIconSrc = resolveAssetPath(lostZoneFile, true);
                el.querySelector('img').src = lostZoneIconSrc;

                if (count > 0) {
                    el.querySelector('.count').textContent = count;
                    el.classList.add('visible');
                } else {
                    el.classList.remove('visible');
                }
            }

            function renderAttachedEnergies(container, energies, getIconHtml) {
                if (!container || !energies) return;

                const getSpecialIconHtml = (cardId) => {
                    const cardData = cardDatabase.value[cardId];
                    const title = cardData ? cardData.name : 'Special Energy';
                    const bgImage = getCardImageUrl(cardId, true);
                    return `<div class="attached-special-energy-icon" style="background-image: ${bgImage}" title="${title}"></div>`;
                };

                const energyCounts = energies.reduce((acc, energy) => {
                    acc[energy] = (acc[energy] || 0) + 1;
                    return acc;
                }, {});

                const totalEnergyCount = energies.length;
                const maxSingleEnergyCount = Object.values(energyCounts).reduce((max, count) => Math.max(max, count), 0);
                const useTypeB = (maxSingleEnergyCount > 1 && totalEnergyCount >= 7) || maxSingleEnergyCount >= 5;

                let html = '';
                if (useTypeB) {
                    for (const energy in energyCounts) {
                        const count = energyCounts[energy];
                        let iconHtml;
                        if (energy.startsWith('special:')) {
                            const cardId = energy.substring(8);
                            iconHtml = getSpecialIconHtml(cardId);
                        } else {
                            iconHtml = getIconHtml(energy);
                        }
                        html += `
                        <div class="energy-count-group">
                            ${iconHtml}
                            <span class="energy-count-number">${count}</span>
                        </div>
                    `;
                    }
                } else {
                    html = energies.map(energy => {
                        if (energy.startsWith('special:')) {
                            const cardId = energy.substring(8);
                            return getSpecialIconHtml(cardId);
                        } else {
                            return getIconHtml(energy);
                        }
                    }).join('');
                }
                container.innerHTML = html;
            }

            function updateCurrentTurnBorder(currentTurn) {
                const borderL = document.getElementById('current-L-border');
                const borderR = document.getElementById('current-R-border');

                const style = getComputedStyle(document.documentElement);
                const currentTurnFile = style.getPropertyValue('--asset-current-turn').trim().replace(/['\"]/g, '');

                // Set the background image for each border with side-specific theming
                if (borderL) {
                    const iconSrc_L = resolveAssetPath(currentTurnFile, false, 'L');
                    borderL.style.setProperty('--bg-current-turn', `url(${iconSrc_L})`);
                }
                if (borderR) {
                    const iconSrc_R = resolveAssetPath(currentTurnFile, false, 'R');
                    borderR.style.setProperty('--bg-current-turn', `url(${iconSrc_R})`);
                }

                // Toggle active class based on current turn
                if (currentTurn === 'L') {
                    borderL?.classList.add('active');
                    borderR?.classList.remove('active');
                } else if (currentTurn === 'R') {
                    borderL?.classList.remove('active');
                    borderR?.classList.add('active');
                } else {
                    borderL?.classList.remove('active');
                    borderR?.classList.remove('active');
                }
            }

            function playToolAnimation(targetEl, isBattleSlot, isAttach) {
                if (!targetEl) return;

                const videoSrc = isAttach ? '/assets/ptcg-telop/fx/tool-attach.webm' : '/assets/ptcg-telop/fx/tool-remove.webm';

                const targetRect = targetEl.getBoundingClientRect();
                if (targetRect.width === 0 && targetRect.height === 0) return;

                const video = document.createElement('video');
                video.src = videoSrc;
                video.muted = true;
                video.autoplay = true;
                video.style.position = 'absolute';
                video.style.zIndex = '400';
                video.style.pointerEvents = 'none';

                const videoWidth = isBattleSlot ? 150 : 70;
                const videoHeight = isBattleSlot ? 120 : 56;
                video.style.width = `${videoWidth}px`;
                video.style.height = `${videoHeight}px`;

                const targetCenterX = targetRect.left + targetRect.width / 2;
                const targetCenterY = targetRect.top + targetRect.height / 2;
                video.style.left = `${targetCenterX - videoWidth / 2}px`;
                video.style.top = `${targetCenterY - videoHeight / 2}px`;

                document.body.appendChild(video);
                video.addEventListener('ended', () => video.remove());
            }

            function updateAttachedTools(slotEl, newToolIds, oldToolIds, isBattleSlot, forceRedraw = false) {
                return new Promise(resolve => {
                    const db = cardDatabase.value;
                    const wrapperSelector = '.attached-tools-wrapper';
                    const itemClass = 'attached-tool-item';
                    const wrapperEl = slotEl.querySelector(wrapperSelector);
                    if (!wrapperEl) return resolve();

                    if (forceRedraw) {
                        let html = '';
                        newToolIds.forEach(id => {
                            if (db[id]) {
                                html += `<div class="${itemClass}" data-tool-id="${id}"><img src="${getCardImageUrl(id)}"></div>`;
                            }
                        });
                        wrapperEl.innerHTML = html;
                        resolve();
                        return;
                    }

                    const animationPromises = [];

                    const toolsToRemove = [];
                    const toolsToAdd = [];
                    const oldWithKept = oldToolIds.map(id => ({ id, kept: false }));
                    const tempNewIdsForConsumption = [...newToolIds];

                    oldWithKept.forEach(item => {
                        const idxInNew = tempNewIdsForConsumption.indexOf(item.id);
                        if (idxInNew > -1) {
                            item.kept = true;
                            tempNewIdsForConsumption.splice(idxInNew, 1);
                        }
                    });

                    toolsToAdd.push(...tempNewIdsForConsumption);

                    for (let i = oldWithKept.length - 1; i >= 0; i--) {
                        if (!oldWithKept[i].kept) {
                            toolsToRemove.push({ id: oldWithKept[i].id, index: i });
                        }
                    }

                    const hasRemovals = toolsToRemove.length > 0;
                    const hasAdditions = toolsToAdd.length > 0;

                    let reorderNeeded = false;
                    if (hasRemovals) {
                        let isPrefix = newToolIds.length <= oldToolIds.length;
                        if (isPrefix) {
                            for (let i = 0; i < newToolIds.length; i++) {
                                if (newToolIds[i] !== oldToolIds[i]) {
                                    isPrefix = false;
                                    break;
                                }
                            }
                        }
                        if (!isPrefix) reorderNeeded = true;
                    }

                    if (hasRemovals) {
                        if (reorderNeeded) {
                            const allElements = [...wrapperEl.querySelectorAll(`.${itemClass}`)];
                            toolsToRemove.forEach(item => {
                                const el = allElements[item.index];
                                if (el && !el.classList.contains('anim-tool-disappear')) {
                                    const p = new Promise(res => el.addEventListener('animationend', res, { once: true }));
                                    animationPromises.push(p);
                                    el.classList.add('anim-tool-disappear');
                                    playToolAnimation(el, isBattleSlot, false);
                                }
                            });

                            setTimeout(() => {
                                wrapperEl.innerHTML = '';
                                newToolIds.forEach(toolId => {
                                    if (db[toolId]) {
                                        const toolItem = document.createElement('div');
                                        toolItem.className = itemClass;
                                        toolItem.dataset.toolId = toolId;
                                        const toolImg = document.createElement('img');
                                        toolImg.src = getCardImageUrl(toolId);
                                        toolItem.appendChild(toolImg);
                                        wrapperEl.appendChild(toolItem);
                                    }
                                });
                                const p = new Promise(res => wrapperEl.addEventListener('animationend', res, { once: true }));
                                animationPromises.push(p);
                                wrapperEl.classList.add('tools-fade-in');
                                wrapperEl.addEventListener('animationend', () => wrapperEl.classList.remove('tools-fade-in'), { once: true });
                                Promise.all(animationPromises).then(() => resolve());
                            }, 300);
                        } else {
                            const allElements = [...wrapperEl.querySelectorAll(`.${itemClass}`)];
                            toolsToRemove.forEach(item => {
                                const el = allElements[item.index];
                                if (el) {
                                    const p = new Promise(res => el.addEventListener('animationend', res, { once: true }));
                                    animationPromises.push(p);
                                    el.classList.add('anim-tool-disappear');
                                    playToolAnimation(el, isBattleSlot, false);
                                    el.addEventListener('animationend', () => el.remove(), { once: true });
                                }
                            });
                        }
                    } else if (hasAdditions) {
                        toolsToAdd.forEach(id => {
                            if (db[id]) {
                                const toolItem = document.createElement('div');
                                const p = new Promise(res => toolItem.addEventListener('animationend', res, { once: true }));
                                animationPromises.push(p);
                                toolItem.className = `${itemClass} anim-tool-appear`;
                                toolItem.dataset.toolId = id;
                                const toolImg = document.createElement('img');
                                toolImg.src = getCardImageUrl(id);
                                toolItem.appendChild(toolImg);
                                wrapperEl.appendChild(toolItem);
                                toolItem.addEventListener('animationstart', () => playToolAnimation(toolItem, isBattleSlot, true), { once: true });
                                toolItem.addEventListener('animationend', () => toolItem.classList.remove('anim-tool-appear'), { once: true });
                            }
                        });
                    }

                    if (animationPromises.length > 0) {
                        if (!reorderNeeded) { // Reorder has its own resolver inside setTimeout
                            Promise.all(animationPromises).then(() => resolve());
                        }
                    } else {
                        resolve();
                    }
                });
            }

            function updateStatusAilments(containerEl, newAilments, oldAilments) {
                return new Promise(resolve => {
                    if (!containerEl) return resolve();

                    const currentIcons = new Set(Array.from(containerEl.children).map(el => el.dataset.ailment));
                    const newIcons = new Set(newAilments);
                    const oldIcons = new Set(oldAilments);
                    const animationPromises = [];

                    // Icons to remove
                    oldIcons.forEach(ailment => {
                        if (!newIcons.has(ailment)) {
                            const iconEl = containerEl.querySelector(`[data-ailment="${ailment}"]`);
                            if (iconEl) {
                                const p = new Promise(res => iconEl.addEventListener('animationend', res, { once: true }));
                                animationPromises.push(p);
                                iconEl.classList.add('anim-status-disappear');
                                iconEl.addEventListener('animationend', () => iconEl.remove(), { once: true });
                            }
                        }
                    });

                    // Icons to add
                    newIcons.forEach(ailment => {
                        if (!currentIcons.has(ailment)) {
                            const iconWrapper = document.createElement('div');
                            iconWrapper.className = 'status-icon-wrapper anim-status-appear';
                            iconWrapper.dataset.ailment = ailment;
                            const iconImg = document.createElement('img');
                            iconImg.src = `/assets/ptcg-telop/icons/${ailment}.png`;
                            iconImg.className = 'status-icon';
                            iconWrapper.appendChild(iconImg);
                            containerEl.appendChild(iconWrapper);

                            const p = new Promise(res => iconWrapper.addEventListener('animationend', res, { once: true }));
                            animationPromises.push(p);
                            iconWrapper.addEventListener('animationend', () => iconWrapper.classList.remove('anim-status-appear'), { once: true });
                        }
                    });

                    if (animationPromises.length > 0) {
                        Promise.all(animationPromises).then(() => resolve());
                    } else {
                        resolve();
                    }
                });
            }

            function handleSlotSlideAnimation(slotEl, isNewCard, forceSlideIn, skipSlideIn) {
                return new Promise(resolve => {
                    if ((isNewCard || forceSlideIn) && !skipSlideIn) {
                        const needsToWaitForSlideOut = slotEl.classList.contains('anim-slide-out-L') || slotEl.classList.contains('anim-slide-out-R');
                        const delay = needsToWaitForSlideOut ? 500 : 0;

                        setTimeout(() => {
                            const side = slotEl.id.includes('-L') ? 'L' : 'R';
                            slotEl.classList.add(`anim-slide-in-${side}`);

                            const animationEndHandler = () => {
                                slotEl.classList.remove(`anim-slide-out-${side}`, `anim-slide-in-${side}`);
                                slotEl.removeEventListener('animationend', animationEndHandler);
                                resolve();
                            };
                            slotEl.addEventListener('animationend', animationEndHandler, { once: true });

                        }, delay);
                    } else {
                        resolve(); // No animation, resolve immediately
                    }
                });
            }

            function renderSlot(side, index, slotData, oldSlotData) {
                const slotEl = document.getElementById(`slot-${side}${index}`);

                const doRender = () => {
                    const promises = [];
                    const db = cardDatabase.value;
                    const settings = settingsRep.value || {};

                    if (slotData && slotData.cardId) {
                        slotEl.classList.remove('anim-slide-out-L', 'anim-slide-out-R');
                    }

                    const hasCard = slotData && slotData.cardId;
                    const forceSlideIn = slotData && slotData.forceSlideIn;
                    const skipSlideIn = slotData && slotData.evolutionSelect;
                    const isNewCard = hasCard && (!oldSlotData || slotData.cardId !== oldSlotData.cardId);
                    const isCardChanged = !oldSlotData || (slotData && oldSlotData.cardId !== slotData.cardId);

                    const sanitizeDamage = (damage) => {
                        if (typeof damage !== 'string') return damage || '';
                        return damage.replace(/＋/g, '+').replace(/－/g, '-').replace(/×/g, '×');
                    };

                    if (!slotEl || !slotData || !slotData.cardId || !db || !db[slotData.cardId]) {
                        // If a KO or REMOVE animation is in progress for this slot, abort rendering to let the animation finish.
                        if (koSlots.has(slotEl.id) || removingSlots.has(slotEl.id)) {
                            return Promise.resolve();
                        }

                        const isSlidingOut = slotEl.classList.contains('anim-slide-out-L') || slotEl.classList.contains('anim-slide-out-R'); const clearSlot = () => {
                            const activeWrapper = slotEl.querySelector('.active-pokemon-wrapper');
                            const benchWrapper = slotEl.querySelector('.bench-pokemon-wrapper');

                            if (activeWrapper) {
                                activeWrapper.classList.add('hidden');
                                const toolsWrapper = activeWrapper.querySelector('.battle-attached-tools-wrapper');
                                if (toolsWrapper) toolsWrapper.innerHTML = '';
                                const energyWrapper = activeWrapper.querySelector('.battle-attached-energies');
                                if (energyWrapper) energyWrapper.innerHTML = '';
                                const ailmentsWrapper = activeWrapper.querySelector('.status-ailment');
                                if (ailmentsWrapper) ailmentsWrapper.innerHTML = '';
                            }
                            if (benchWrapper) {
                                slotEl.innerHTML = '';
                            }

                            slotEl.dataset.cardId = '';
                            slotEl.classList.add('is-empty');
                        };
                        if (isSlidingOut) {
                            setTimeout(clearSlot, 500);
                        } else {
                            clearSlot();
                        }
                        return Promise.resolve();
                    }
                    slotEl.classList.remove('is-empty');

                    const isUnderAttack = g_attackAnimationTargets.has(slotEl.id);

                    const imageArea = slotEl.querySelector('.battle-card-image-area, .bench-card-image-area');
                    const cardData = db[slotData.cardId];

                    slotEl.style.borderColor = 'var(--stroke-color)';
                    // if (imageArea) imageArea.style.borderColor = 'var(--stroke-color)';

                    slotEl.style.backgroundColor = 'var(--main-color)';

                    const oldToolIds = oldSlotData ? (oldSlotData.attachedToolIds || []) : [];
                    const newToolIds = slotData ? (slotData.attachedToolIds || []) : [];
                    const ailmentsBeforeChange = oldSlotData ? (oldSlotData.ailments || []) : [];
                    const newAilments = slotData ? (slotData.ailments || []) : [];

                    const isNoLongerActive = index !== 0 && oldSlotData && oldSlotData.active;

                    if (isCardChanged || isNoLongerActive) {
                        oldSlotData = null;
                    }

                    if (!cardData || !cardData.pokemon) return Promise.resolve();
                    const baseHp = parseInt(cardData.pokemon.hp || 0, 10);
                    const extraHp = parseInt(slotData.extraHp || 0, 10);
                    const damage = parseInt(slotData.damage || 0, 10);
                    const maxHp = baseHp + extraHp;
                    const currentHp = Math.max(0, maxHp - damage);

                    let hpChangeToShow = 0;
                    if (oldSlotData) {
                        const oldDamage = parseInt(oldSlotData.damage || 0, 10);
                        const oldExtraHp = parseInt(oldSlotData.extraHp || 0, 10);
                        const oldMaxHp = baseHp + oldExtraHp;
                        const oldHp = Math.max(0, oldMaxHp - oldDamage);
                        const damageDiff = damage - oldDamage;
                        if (damageDiff > 0) { hpChangeToShow = -damageDiff; }
                        else if (damageDiff < 0) { hpChangeToShow = -damageDiff; }
                        else if (extraHp !== oldExtraHp) { hpChangeToShow = currentHp - oldHp; }
                    }

                    let startHp = currentHp, startMaxHp = maxHp;
                    if (oldSlotData) {
                        const oldExtraHp = parseInt(oldSlotData.extraHp || 0, 10);
                        const oldDamage = parseInt(oldSlotData.damage || 0, 10);
                        startMaxHp = baseHp + oldExtraHp;
                        startHp = Math.max(0, startMaxHp - oldDamage);
                    }

                    const hpPercent = maxHp > 0 ? (currentHp / maxHp) * 100 : 0;
                    let hpColor = 'var(--hp-high)';
                    if (hpPercent <= 25) hpColor = 'var(--hp-low)';
                    else if (hpPercent <= 50) hpColor = 'var(--hp-medium)';
                    const getEnergyIcon = (type) => `<img class="energy-icon" src="/assets/ptcg-telop/icons/${ENERGY_MAP[type] || 'エネなし'}.png">`;

                    if (index === 0) {
                        const wrapper = slotEl.querySelector('.active-pokemon-wrapper');
                        wrapper.classList.remove('hidden');
                        wrapper.querySelector('.pokemon-name').textContent = cardData.name;
                        const img = wrapper.querySelector('.pokemon-image');

                        if (isNewCard || forceSlideIn) {
                            // Pre-position the slot off-screen to prevent visual glitch during image loading
                            const side = slotEl.id.includes('-L') ? 'L' : 'R';
                            const offScreenTransform = side === 'L' ? 'translateX(-120%)' : 'translateX(120%)';
                            slotEl.style.transform = offScreenTransform;
                            slotEl.style.opacity = '0';

                            img.style.visibility = 'hidden';
                            img.onload = () => {
                                img.style.visibility = 'visible';
                                // Reset transform before triggering slide-in animation
                                slotEl.style.transform = '';
                                slotEl.style.opacity = '';
                                promises.push(handleSlotSlideAnimation(slotEl, isNewCard, forceSlideIn, skipSlideIn));
                                img.onload = null;
                            };
                        } else {
                            promises.push(handleSlotSlideAnimation(slotEl, isNewCard, forceSlideIn, skipSlideIn));
                        }
                        img.src = getCardImageUrl(slotData.cardId);
                        img.classList.toggle('is-v', cardData.pokemon && cardData.subtype === 'V');

                        const hpUpdatePromise = new Promise(resolve => {
                            const hpUpdate = () => {
                                const hpPromises = [];
                                const hpTextEl = wrapper.querySelector('.hp-text');
                                hpPromises.push(animateHp(hpTextEl, startHp, currentHp, startMaxHp, maxHp, 500));
                                const hpBar = wrapper.querySelector('.hp-bar');
                                hpBar.style.width = `${hpPercent}%`;
                                hpBar.style.backgroundColor = hpColor;
                                if (hpChangeToShow !== 0) {
                                    hpPromises.push(displayHpChangeNumber(slotEl, hpChangeToShow));
                                }
                                Promise.all(hpPromises).then(resolve);
                            };

                            if (isUnderAttack) {
                                setTimeout(hpUpdate, 1100);
                            } else {
                                hpUpdate();
                            }
                        });
                        promises.push(hpUpdatePromise);

                        promises.push(updateAttachedTools(slotEl, newToolIds, oldToolIds, true, isCardChanged));

                        const energyContainer = wrapper.querySelector('.attached-energies');
                        renderAttachedEnergies(energyContainer, slotData.attachedEnergy, getEnergyIcon);

                        promises.push(updateStatusAilments(wrapper.querySelector('.status-ailment'), newAilments, ailmentsBeforeChange));
                        const skillsContainer = wrapper.querySelector('.skills-container');
                        skillsContainer.innerHTML = '';
                        const allSkills = [...(cardData.pokemon.abilities || []), ...(cardData.pokemon.attacks || [])];
                        allSkills.slice(0, 2).forEach(skill => {
                            const isAbility = !!skill.text && !skill.cost;
                            const abilityUsedClass = (isAbility && slotData.abilityUsed) ? 'used' : '';
                            let tagHtml = '';
                            if (isAbility) {
                                const style = getComputedStyle(document.documentElement);
                                const abilityFile = style.getPropertyValue('--asset-ability').trim().replace(/['\"]/g, '');
                                const abilityIconSrc = resolveAssetPath(abilityFile, true);
                                tagHtml = `<img src="${abilityIconSrc}" class="skill-ability-tag ${abilityUsedClass}" alt="Ability">`;
                            } else {
                                const cost = skill.cost || [];
                                const iconsToRender = cost.length > 0 ? cost : [null];
                                const iconsHtml = iconsToRender.map(getEnergyIcon).join('');
                                tagHtml = `<div class="energy-cost-container">${iconsHtml}</div>`;
                            }
                            skillsContainer.innerHTML += `
                            <div class="skill-row-wrapper">
                                ${tagHtml}
                                <div class="skill">
                                    <div class="skill-name-wrapper">
                                        <span class="skill-name ${isAbility ? 'is-ability' : ''} ${abilityUsedClass}">${skill.name}</span>
                                    </div>
                                    <div class="skill-damage">${sanitizeDamage(skill.damage)}</div>
                                </div>
                            </div>
                        `;
                        });
                    } else {
                        let wrapper = slotEl.querySelector('.bench-pokemon-wrapper');
                        const forceRedraw = !oldSlotData || !wrapper || slotEl.dataset.cardId !== slotData.cardId;

                        if (forceRedraw) {
                            slotEl.innerHTML = `
                            <div class="bench-pokemon-wrapper">
                                <div class="card-image-area">
                                    <img class="pokemon-image">
                                    <div class="attached-energies"></div>
                                    <div class="attached-tools-wrapper"></div>
                                </div>
                                <div class="bench-info-area">
                                    <div class="pokemon-name">${cardData.name}</div>
                                    <div class="hp-gauge">
                                        <div class="hp-bar-container">
                                            <div class="hp-text"></div>
                                            <div class="hp-bar"></div>
                                        </div>
                                    </div>
                                    <div class="skills-container"></div>
                                </div>
                            </div>`;
                            wrapper = slotEl.querySelector('.bench-pokemon-wrapper');
                            slotEl.dataset.cardId = slotData.cardId;

                            const mainImg = wrapper.querySelector('.pokemon-image');

                            // Pre-position the slot off-screen to prevent visual glitch during image loading
                            if (isNewCard || forceSlideIn) {
                                const side = slotEl.id.includes('-L') ? 'L' : 'R';
                                const offScreenTransform = side === 'L' ? 'translateX(-120%)' : 'translateX(120%)';
                                slotEl.style.transform = offScreenTransform;
                                slotEl.style.opacity = '0';
                            }

                            mainImg.style.visibility = 'hidden';
                            mainImg.onload = () => {
                                mainImg.style.visibility = 'visible';
                                // Reset transform before triggering slide-in animation
                                if (isNewCard || forceSlideIn) {
                                    slotEl.style.transform = '';
                                    slotEl.style.opacity = '';
                                }
                                promises.push(handleSlotSlideAnimation(slotEl, isNewCard, forceSlideIn, skipSlideIn));
                                mainImg.onload = null;
                            };
                            mainImg.src = getCardImageUrl(slotData.cardId);
                            mainImg.classList.toggle('is-v', cardData.pokemon && cardData.subtype === 'V');
                        } else {
                            promises.push(handleSlotSlideAnimation(slotEl, isNewCard, forceSlideIn, skipSlideIn));
                        }
                        wrapper.classList.remove('hidden');
                        const skillsContainer = wrapper.querySelector('.skills-container');
                        const allSkills = [...(cardData.pokemon.abilities || []), ...(cardData.pokemon.attacks || [])];
                        let skillsHtml = '';
                        allSkills.slice(0, 2).forEach(skill => {
                            const isAbility = !!skill.text && !skill.cost;
                            const abilityUsedClass = (isAbility && slotData.abilityUsed) ? 'used' : '';
                            let tagHtml = '';
                            if (isAbility) {
                                const style = getComputedStyle(document.documentElement);
                                const abilityFile = style.getPropertyValue('--asset-ability').trim().replace(/['\"]/g, '');
                                const abilityIconSrc = resolveAssetPath(abilityFile, true);
                                tagHtml = `<img src="${abilityIconSrc}" class="skill-ability-tag ${abilityUsedClass}" alt="Ability">`;
                            } else {
                                const cost = skill.cost || [];
                                const iconsToRender = cost.length > 0 ? cost : [null];
                                const iconsHtml = iconsToRender.map(getEnergyIcon).join('');
                                tagHtml = `<div class="energy-cost-container">${iconsHtml}</div>`;
                            }
                            skillsHtml += `
                            <div class="skill-row-wrapper">
                                ${tagHtml}
                                <div class="skill">
                                    <div class="skill-name-wrapper"><span class="skill-name ${isAbility ? 'is-ability' : ''} ${abilityUsedClass}">${skill.name}</span></div>
                                    <div class="skill-damage">${sanitizeDamage(skill.damage)}</div>
                                </div>
                            </div>`;
                        });
                        skillsContainer.innerHTML = skillsHtml;

                        promises.push(updateAttachedTools(slotEl, newToolIds, oldToolIds, false, forceRedraw));

                        const hpUpdatePromise = new Promise(resolve => {
                            const hpUpdate = () => {
                                const hpPromises = [];
                                const hpTextEl = wrapper.querySelector('.hp-text');
                                const hpBarEl = wrapper.querySelector('.hp-bar');
                                hpPromises.push(animateHp(hpTextEl, startHp, currentHp, startMaxHp, maxHp, 500));
                                hpBarEl.style.width = `${hpPercent}%`;
                                hpBarEl.style.backgroundColor = hpColor;
                                if (hpChangeToShow !== 0) {
                                    hpPromises.push(displayHpChangeNumber(slotEl, hpChangeToShow));
                                }
                                Promise.all(hpPromises).then(resolve);
                            };
                            if (isUnderAttack) { setTimeout(hpUpdate, 1100); } else { hpUpdate(); }
                        });
                        promises.push(hpUpdatePromise);

                        const energyContainer = wrapper.querySelector('.attached-energies');
                        const getBenchEnergyIcon = (type) => `<img class="energy-icon" src="/assets/ptcg-telop/icons/${ENERGY_MAP[type] || 'エネなし'}.png">`;
                        renderAttachedEnergies(energyContainer, slotData.attachedEnergy, getBenchEnergyIcon);
                    }
                    if (slotData && slotData.evolutionSelect) {
                        delete slotData.evolutionSelect;
                    }
                    if (slotData && slotData.forceSlideIn) {
                        delete slotData.forceSlideIn;
                    }
                    return Promise.all(promises);
                };

                const isEvolving = evolvingSlots.has(slotEl.id);
                if (isEvolving) {
                    evolvingSlots.delete(slotEl.id); // Consume the flag
                    return new Promise(resolve => {
                        setTimeout(() => {
                            doRender().then(resolve);
                        }, 500); // The magic delay for evolution
                    });
                } else {
                    return doRender();
                }
            }

            // After the page loads, start preloading all assets
            const videosToPreload = [
                // KO & Evolve FX
                '/assets/ptcg-telop/fx/active_ko.webm',
                '/assets/ptcg-telop/fx/active-evolve.webm',
                '/assets/ptcg-telop/fx/active-mega-evolve.webm',
                '/assets/ptcg-telop/fx/active-tera-evolve.webm',
                '/assets/ptcg-telop/fx/active-replace.webm',
                '/assets/ptcg-telop/fx/active-devolve.webm',
                '/assets/ptcg-telop/fx/bench_ko.webm',
                '/assets/ptcg-telop/fx/bench-replace.webm',
                '/assets/ptcg-telop/fx/bench-devolve.webm',
                '/assets/ptcg-telop/fx/bench-evolve.webm',
                '/assets/ptcg-telop/fx/bench-mega-evolve.webm',
                '/assets/ptcg-telop/fx/bench-tera-evolve.webm',
                // Hit FX
                '/assets/ptcg-telop/fx/hit-colorless.webm',
                '/assets/ptcg-telop/fx/hit-darkness.webm',
                '/assets/ptcg-telop/fx/hit-dragon.webm',
                '/assets/ptcg-telop/fx/hit-fighting.webm',
                '/assets/ptcg-telop/fx/hit-fire.webm',
                '/assets/ptcg-telop/fx/hit-grass.webm',
                '/assets/ptcg-telop/fx/hit-lightning.webm',
                '/assets/ptcg-telop/fx/hit-metal.webm',
                '/assets/ptcg-telop/fx/hit-psychic.webm',
                '/assets/ptcg-telop/fx/hit-water.webm',
                '/assets/ptcg-telop/fx/hit-fairy.webm',
                // Misc FX
                '/assets/ptcg-telop/fx/Speedline.webm',
                '/assets/ptcg-telop/fx/tool-attach.webm',
                '/assets/ptcg-telop/fx/tool-remove.webm'
            ];

            const imagesToPreload = [
                // Background and UI elements
                '/assets/ptcg-telop/element/panel-bg.png',
                '/assets/ptcg-telop/element/active-bg.png',
                '/assets/ptcg-telop/element/bench-bg.png',
                '/assets/ptcg-telop/element/current.png',
                '/assets/ptcg-telop/element/VSTAR.webp',
                '/assets/ptcg-telop/element/weakness.png',
                '/assets/ptcg-telop/element/Beginner.png',
                '/assets/ptcg-telop/element/Poké_Ball.png',
                // Player action icons
                '/assets/ptcg-telop/element/action-energy.png',
                '/assets/ptcg-telop/element/action-supporter.png',
                '/assets/ptcg-telop/element/action-retreat.png',
                // Status condition icons
                '/assets/ptcg-telop/icons/Poisoned.png',
                '/assets/ptcg-telop/icons/Burned.png',
                '/assets/ptcg-telop/icons/Asleep.png',
                '/assets/ptcg-telop/icons/Paralyzed.png',
                '/assets/ptcg-telop/icons/Confused.png',
                // Energy icons (dynamically generated)
                ...Object.values(ENERGY_MAP).map(type => `/assets/ptcg-telop/icons/${type}.png`)
            ].filter((v, i, a) => a.indexOf(v) === i); // Deduplicate, just in case

            const preloaderContainer = document.getElementById('video-preloader');
            if (preloaderContainer) {
                // Preload videos
                videosToPreload.forEach(src => {
                    const video = document.createElement('video');
                    video.src = src;
                    video.preload = 'auto';
                    video.muted = true;
                    video.playsInline = true;
                    video.load();
                    preloaderContainer.appendChild(video);
                });

                // Preload images
                imagesToPreload.forEach(src => {
                    const img = document.createElement('img');
                    img.src = src;
                    preloaderContainer.appendChild(img);
                });
            }


            const i18nStrings = nodecg.Replicant('i18nStrings');
            const language = nodecg.Replicant('language');
            const themeAssets = nodecg.Replicant('themeAssets');

            // A more descriptive function name for getting translated text
            const getI18nText = (key) => {
                if (!i18nStrings.value || !i18nStrings.value[key] || !language.value) {
                    return key; // Fallback to key name if not found
                }
                // Return the text for the current language, or fallback to Japanese, then the key itself.
                return i18nStrings.value[key][language.value] || i18nStrings.value[key]['jp'] || key;
            };

            function resolveAssetPath(assetName, isLangSpecific = false, side = null) {
                const settings = settingsRep.value || {};
                const assets = themeAssets.value || {};
                const lang = language.value || 'jp';
                const basePath = '/assets/ptcg-telop/';

                // improved activeTheme resolution
                let activeTheme = 'Default';
                if (side === 'L') {
                    activeTheme = settings.activeTheme || 'Default';
                } else if (side === 'R') {
                    // Right side logic: if "Follow Left", use Left's theme.
                    activeTheme = (settings.activeThemeR === 'Follow Left')
                        ? (settings.activeTheme || 'Default')
                        : (settings.activeThemeR || 'Default');
                } else {
                    // Fallback to Left/Default if no side specified (e.g. for common assets)
                    activeTheme = settings.activeTheme || 'Default';
                }

                const potentialPath = assetName.replace(/url\((['"]?)(.*?)\1\)/, '$2');
                const cleanAssetName = potentialPath.split('/').pop();

                // 1. Check for exact match in theme
                if (assets[activeTheme] && assets[activeTheme].includes(cleanAssetName)) {
                    return `${basePath}${activeTheme}/${cleanAssetName}`;
                }

                // 2. Check for base filename (non-language specific) in theme if applicable
                if (isLangSpecific && assets[activeTheme]) {
                    const genericFileName = cleanAssetName.replace(/_jp\.png$/, '.png');
                    if (assets[activeTheme].includes(genericFileName)) {
                        return `${basePath}${activeTheme}/${genericFileName}`;
                    }
                }

                if (isLangSpecific) {
                    const baseName = assetName.replace(/_jp\.png$/, '');
                    const langAssetName = `${baseName}_${lang}.png`;
                    return `${basePath}element/${langAssetName}`;
                }

                return `${basePath}element/${assetName}`;
            }

            function updateCustomizableAssets() {
                const root = document.documentElement;
                const style = getComputedStyle(root);
                // We use getComputedStyle on root to get default values, 
                // but we might need scoped values. 
                // However, the assets themselves are resolved via JS, so we use the settings.

                const getFile = (varName) => style.getPropertyValue(varName).trim().replace(/['\"]/g, '');

                const applyToSide = (side) => {
                    const areaId = side === 'L' ? 'player-L-area' : 'player-R-area';
                    const areaEl = document.getElementById(areaId);
                    if (!areaEl) return;

                    // Apply to the specific player area element
                    areaEl.style.setProperty('--bg-player-area', `url(${resolveAssetPath(getFile('--asset-panel-bg'), false, side)})`);
                    areaEl.style.setProperty('--bg-active-slot', `url(${resolveAssetPath(getFile('--asset-active-bg'), false, side)})`);
                    areaEl.style.setProperty('--bg-bench-slot', `url(${resolveAssetPath(getFile('--asset-bench-bg'), false, side)})`);
                    areaEl.style.setProperty('--bg-current-turn', `url(${resolveAssetPath(getFile('--asset-current-turn'), false, side)})`);
                }

                applyToSide('L');
                applyToSide('R');

                document.getElementById('vstar-L-icon').src = resolveAssetPath(getFile('--asset-vstar'), false, 'L');
                document.getElementById('vstar-R-icon').src = resolveAssetPath(getFile('--asset-vstar'), false, 'R');
                document.getElementById('action-L-energy').src = resolveAssetPath(getFile('--asset-action-energy'), false, 'L');
                document.getElementById('action-L-supporter').src = resolveAssetPath(getFile('--asset-action-supporter'), false, 'L');
                document.getElementById('action-L-retreat').src = resolveAssetPath(getFile('--asset-action-retreat'), false, 'L');
                document.getElementById('action-R-energy').src = resolveAssetPath(getFile('--asset-action-energy'), false, 'R');
                document.getElementById('action-R-supporter').src = resolveAssetPath(getFile('--asset-action-supporter'), false, 'R');
                document.getElementById('action-R-retreat').src = resolveAssetPath(getFile('--asset-action-retreat'), false, 'R');

                updateFirstMoveIcon(firstMove.value);
                updateLostZoneCounter('L', live_lostZoneL.value);
                updateLostZoneCounter('R', live_lostZoneR.value);

                updateSideArea('L', live_sideL.value);
                updateSideArea('R', live_sideR.value);

                updateCurrentTurnBorder(live_currentTurn.value);

                // Update Stadium Border Gradient
                // Use retry logic to handle potential race conditions in OBS/slower styling application
                const updateStadiumBorder = () => {
                    const stadiumCard = document.getElementById('stadium-card');
                    if (stadiumCard) {
                        const playerL = document.getElementById('player-L-area');
                        const playerR = document.getElementById('player-R-area');

                        const getBorderColor = (el) => {
                            if (!el) return '#ffffff';
                            const style = getComputedStyle(el);
                            const c1 = style.getPropertyValue('--module-color-border').trim();
                            const c2 = style.getPropertyValue('--stroke-color').trim();
                            // Return the first valid color, or default to white
                            return (c1 && c1 !== '') ? c1 : ((c2 && c2 !== '') ? c2 : '#ffffff');
                        };

                        const borderL = getBorderColor(playerL);
                        const borderR = getBorderColor(playerR);

                        stadiumCard.style.setProperty('--stadium-border-L', borderL);
                        stadiumCard.style.setProperty('--stadium-border-R', borderR);
                    }
                };

                updateStadiumBorder();
                // Single retry after a delay to ensure styles are fully calculated
                setTimeout(updateStadiumBorder, 500);

                sides.forEach(side => {
                    for (let i = 0; i < 6; i++) {
                        const replicant = live_slotReplicants[`live_slot${side}${i}`];
                        if (replicant && replicant.value) {
                            renderSlot(side, i, replicant.value, replicant.value);
                        }
                    }
                });
            }

            function setLanguageClass(lang) {
                const supportedLangs = ['jp', 'chs', 'cht', 'en'];
                supportedLangs.forEach(l => {
                    document.body.classList.remove(`lang-${l}`);
                });
                if (lang && supportedLangs.includes(lang)) {
                    document.body.classList.add(`lang-${lang}`);
                }
            }



            const activeThemeCss = nodecg.Replicant('activeThemeCss');
            const settingsRep = nodecg.Replicant('ptcg-settings'); // Moved up for use in activeThemeCss

            activeThemeCss.on('change', (newVal) => {
                const setLink = (id, url) => {
                    const link = document.getElementById(id);
                    if (link) {
                        if (url) {
                            link.href = url;
                            link.disabled = false;
                        } else {
                            link.disabled = true;
                            link.href = '';
                        }
                    }
                };

                if (newVal && typeof newVal === 'object') {
                    setLink('theme-css-L', newVal.left);
                    setLink('theme-css-R', newVal.right);
                } else {
                    // Fallback for old value format or null
                    setLink('theme-css-L', null);
                    setLink('theme-css-R', null);
                }

                // Apply active theme class to body
                const settings = settingsRep.value || {};
                const themeName = settings.activeTheme || 'Default';
                document.body.className = document.body.className.replace(/theme-[\w-]+/g, '').trim(); // Remove old theme classes if any
                document.body.classList.add(themeName); // Add simple theme name class (e.g. "Neon")

                // Update assets which might be overridden by the theme
                updateCustomizableAssets();
            });

            const cardDatabase = nodecg.Replicant('cardDatabase');
            const assetPaths = nodecg.Replicant('assetPaths');
            const playerL_name = nodecg.Replicant('playerL_name');
            const playerR_name = nodecg.Replicant('playerR_name');
            const vstarUsedL = nodecg.Replicant('live_vstar_L');
            const vstarUsedR = nodecg.Replicant('live_vstar_R');
            const live_sideL = nodecg.Replicant('live_sideL');
            const live_sideR = nodecg.Replicant('live_sideR');
            const live_stadium = nodecg.Replicant('live_stadium');
            const live_currentTurn = nodecg.Replicant('live_currentTurn');
            // settingsRep is declared earlier
            const firstMove = nodecg.Replicant('firstMove');
            const live_lostZoneL = nodecg.Replicant('live_lostZoneL');
            const live_lostZoneR = nodecg.Replicant('live_lostZoneR');
            const deckL = nodecg.Replicant('deckL');
            const deckR = nodecg.Replicant('deckR');
            const actionTypes = ['energy', 'supporter', 'retreat'];
            const sides = ['L', 'R'];
            const live_slotReplicants = {};
            const replicantList = [
                cardDatabase, assetPaths, playerL_name, playerR_name,
                vstarUsedL, vstarUsedR,
                live_sideL, live_sideR, live_stadium, live_currentTurn, settingsRep, firstMove,
                live_lostZoneL, live_lostZoneR,
                deckL, deckR, language,
                i18nStrings, themeAssets
            ];
            sides.forEach(side => {
                actionTypes.forEach(action => {
                    replicantList.push(nodecg.Replicant(`live_action_${action}_${side}`));
                });
                for (let i = 0; i < 6; i++) {
                    const id = `live_slot${side}${i}`;
                    const replicant = nodecg.Replicant(id);
                    live_slotReplicants[id] = replicant;
                    replicantList.push(replicant);
                }
            });

            function playVideoOnSlot(targetId, videoSrc) {
                return new Promise(resolve => {
                    const targetEl = document.getElementById(targetId);
                    if (!targetEl) return resolve();

                    const isBattleSlot = targetEl.id.endsWith('0');
                    const imageSelector = '.pokemon-image';
                    const cardImage = targetEl.querySelector(imageSelector);

                    // Create video element and add directly to slot
                    const video = document.createElement('video');
                    video.src = videoSrc;
                    video.muted = true;
                    video.style.position = 'absolute';
                    video.style.width = '100%';
                    video.style.height = '100%';
                    video.style.left = '0';
                    video.style.top = '0';
                    video.style.zIndex = '300';
                    video.style.objectFit = 'cover';

                    targetEl.appendChild(video);
                    video.play();

                    setTimeout(() => { if (cardImage) cardImage.style.visibility = 'hidden'; }, REPLACE_ANIMATION_HIDE_MS);
                    setTimeout(() => { if (cardImage) cardImage.style.visibility = 'visible'; }, REPLACE_ANIMATION_SHOW_MS);

                    video.addEventListener('ended', () => {
                        video.remove();
                        resolve();
                    });
                });
            }

            NodeCG.waitForReplicants(...replicantList).then(() => {
                setLanguageClass(language.value || 'jp');

                updatePlayerInfo('L', playerL_name.value);
                updatePlayerInfo('R', playerR_name.value);
                updateVstarIcon('L', vstarUsedL.value);
                updateVstarIcon('R', vstarUsedR.value);
                updateSideArea('L', live_sideL.value);
                updateSideArea('R', live_sideR.value);
                renderStadium(live_stadium.value, { cardId: null });
                // Update current turn border with new theme assets
                updateCurrentTurnBorder(live_currentTurn.value);

                // Update Stadium Border Gradient
                const stadiumCard = document.getElementById('stadium-card');
                if (stadiumCard) {
                    // We need to get the border color from the themed player areas
                    // Since updateThemeClasses has already run, these areas should have the correct theme classes
                    const playerL = document.getElementById('player-L-area');
                    const playerR = document.getElementById('player-R-area');

                    const borderL = playerL ? getComputedStyle(playerL).getPropertyValue('--stroke-color').trim() : '#ffffff';
                    const borderR = playerR ? getComputedStyle(playerR).getPropertyValue('--stroke-color').trim() : '#ffffff';

                    stadiumCard.style.setProperty('--stadium-border-L', borderL || '#ffffff');
                    stadiumCard.style.setProperty('--stadium-border-R', borderR || '#ffffff');
                }

                sides.forEach(side => {
                    actionTypes.forEach(action => {
                        const rep = nodecg.Replicant(`live_action_${action}_${side}`);
                        updateActionIcon(side, action, rep.value);
                        rep.on('change', (newVal) => updateActionIcon(side, action, newVal));
                    });
                    for (let i = 0; i < 6; i++) {
                        const replicant = live_slotReplicants[`live_slot${side}${i}`];
                        renderSlot(side, i, replicant.value, null);
                        replicant.on('change', (newVal, oldVal) => {
                            if (!oldVal) {
                                return;
                            }
                            const promise = renderSlot(side, i, newVal, oldVal);
                            addAnimationPromise(promise);
                            debouncedOnBatchFinished();
                        });
                    }
                });
                playerL_name.on('change', (val) => updatePlayerInfo('L', val));
                playerR_name.on('change', (val) => updatePlayerInfo('R', val));
                vstarUsedL.on('change', (val) => updateVstarIcon('L', val));
                vstarUsedR.on('change', (val) => updateVstarIcon('R', val));
                live_sideL.on('change', (val) => updateSideArea('L', val));
                live_sideR.on('change', (val) => updateSideArea('R', val));
                live_stadium.on('change', (newVal, oldVal) => renderStadium(newVal, oldVal || { cardId: null }));
                live_currentTurn.on('change', (val) => updateCurrentTurnBorder(val));
                updateFirstMoveIcon(firstMove.value);
                firstMove.on('change', (val) => updateFirstMoveIcon(val));
                updateLostZoneCounter('L', live_lostZoneL.value);
                updateLostZoneCounter('R', live_lostZoneR.value);
                live_lostZoneL.on('change', (val) => updateLostZoneCounter('L', val));
                live_lostZoneR.on('change', (val) => updateLostZoneCounter('R', val));

                const preloaderContainer = document.getElementById('video-preloader');
                function preloadDeckImages(deck) {
                    if (!deck || !deck.cards || !assetPaths.value.cardImgPath || !preloaderContainer) return;

                    const cardImgPath = `/${assetPaths.value.cardImgPath}`;

                    deck.cards.forEach(cardId => {
                        if (!preloaderContainer.querySelector(`img[src="${cardImgPath}${cardId}.jpg"]`)) {
                            const img = document.createElement('img');
                            img.src = `${cardImgPath}${cardId}.jpg`;
                            preloaderContainer.appendChild(img);
                        }
                    });
                }

                preloadDeckImages(deckL.value);
                preloadDeckImages(deckR.value);
                deckL.on('change', (newVal) => preloadDeckImages(newVal));
                deckR.on('change', (newVal) => preloadDeckImages(newVal));

                const handleVstarVisibility = (settings) => {
                    const vstarL_icon = document.getElementById('vstar-L-icon');
                    const vstarR_icon = document.getElementById('vstar-R-icon');
                    const enabled = settings && settings.vstarEnabled;
                    if (vstarL_icon) vstarL_icon.classList.toggle('hidden', !enabled);
                    if (vstarR_icon) vstarR_icon.classList.toggle('hidden', !enabled);
                };

                settingsRep.on('change', (newValue, oldValue) => {
                    const oldSettings = oldValue || {};
                    const newSettings = newValue || {};

                    if (oldSettings.vstarEnabled !== newSettings.vstarEnabled) {
                        handleVstarVisibility(newSettings);
                    }

                    if (oldSettings.language !== newSettings.language) {
                        setLanguageClass(newSettings.language);
                        updateCustomizableAssets();
                    }

                    // Always update theme classes just in case
                    updateThemeClasses(newSettings);
                });

                handleVstarVisibility(settingsRep.value);
                // The initial handleThemeChange call is now handled by the replicant's initial value

                function handleSwitchAnimation(animation) {
                    return new Promise(resolve => {
                        if (!animation.source || !animation.target) {
                            console.error('Invalid SWITCH_POKEMON animation data:', animation);
                            return resolve();
                        }
                        const sourceEl = document.getElementById(animation.source);
                        const targetEl = document.getElementById(animation.target);
                        const promises = [];

                        if (sourceEl && !sourceEl.classList.contains('is-empty')) {
                            const side = animation.source.includes('-L') ? 'L' : 'R';
                            const p = new Promise(res => sourceEl.addEventListener('animationend', res, { once: true }));
                            promises.push(p);
                            sourceEl.classList.add(`anim-slide-out-${side}`);
                        }
                        if (targetEl && !targetEl.classList.contains('is-empty')) {
                            const side = animation.target.includes('-L') ? 'L' : 'R';
                            const p = new Promise(res => targetEl.addEventListener('animationend', res, { once: true }));
                            promises.push(p);
                            targetEl.classList.add(`anim-slide-out-${side}`);
                        }

                        if (promises.length > 0) {
                            Promise.all(promises).then(resolve);
                        } else {
                            resolve();
                        }
                    });
                }

                function handleEvolveAnimation(animation) {
                    evolvingSlots.add(animation.target); // Flag the slot as evolving
                    const db = cardDatabase.value;
                    const isBattleSlot = animation.target.endsWith('0');
                    let videoSrc = isBattleSlot ? '/assets/ptcg-telop/fx/active-evolve.webm' : '/assets/ptcg-telop/fx/bench-evolve.webm';

                    if (animation.cardId && db && db[animation.cardId]) {
                        const cardData = db[animation.cardId];
                        if (cardData.pokemon && cardData.pokemon.option) {
                            const option = cardData.pokemon.option.toLowerCase();
                            if (option === 'mega') {
                                videoSrc = isBattleSlot ? '/assets/ptcg-telop/fx/active-mega-evolve.webm' : '/assets/ptcg-telop/fx/bench-mega-evolve.webm';
                            } else if (option === 'terastal') {
                                videoSrc = isBattleSlot ? '/assets/ptcg-telop/fx/active-tera-evolve.webm' : '/assets/ptcg-telop/fx/bench-tera-evolve.webm';
                            }
                        }
                    }
                    return playVideoOnSlot(animation.target, videoSrc);
                }

                function handleKoAnimation(animation) {
                    return new Promise(resolve => {
                        const targetEl = document.getElementById(animation.target);
                        if (!targetEl) return resolve();

                        koSlots.add(animation.target); // Flag the slot as being KO'd

                        const side = animation.target.includes('-L') ? 'L' : 'R';
                        const isBattleSlot = animation.target.endsWith('0');
                        const videoSrc = isBattleSlot ? '/assets/ptcg-telop/fx/active_ko.webm' : '/assets/ptcg-telop/fx/bench_ko.webm';
                        const imageSelector = '.pokemon-image';

                        const koVideo = document.createElement('video');
                        koVideo.src = videoSrc;
                        koVideo.muted = true;
                        koVideo.style.position = 'absolute';
                        koVideo.style.width = '100%';
                        koVideo.style.height = '100%';
                        koVideo.style.left = isBattleSlot ? '0' : '-4px';
                        koVideo.style.top = '0';
                        koVideo.style.zIndex = '200';
                        targetEl.appendChild(koVideo);
                        koVideo.play();

                        setTimeout(() => {
                            const cardImage = targetEl.querySelector(imageSelector);
                            if (cardImage) cardImage.style.visibility = 'hidden';
                        }, 85);

                        koVideo.addEventListener('ended', () => {
                            koVideo.remove();
                            targetEl.classList.add(`anim-slide-out-${side}`);
                            targetEl.addEventListener('animationend', () => {
                                koSlots.delete(animation.target); // Clean up the flag
                                resolve();
                            }, { once: true });
                        });
                    });
                }

                function handleExitAnimation(animation) {
                    return new Promise(resolve => {
                        const targetEl = document.getElementById(animation.target);
                        if (!targetEl) return resolve();

                        removingSlots.add(animation.target); // Flag the slot for removal

                        const side = animation.target.includes('-L') ? 'L' : 'R';
                        targetEl.classList.add(`anim-slide-out-${side}`);

                        targetEl.addEventListener('animationend', () => {
                            // Perform the cleanup that renderSlot would have done
                            const activeWrapper = targetEl.querySelector('.active-pokemon-wrapper');
                            const benchWrapper = targetEl.querySelector('.bench-pokemon-wrapper');
                            if (activeWrapper) { activeWrapper.classList.add('hidden'); }
                            if (benchWrapper) { targetEl.innerHTML = ''; }
                            targetEl.dataset.cardId = '';
                            targetEl.classList.add('is-empty');

                            removingSlots.delete(animation.target); // Clean up the flag
                            resolve();
                        }, { once: true });
                    });
                }

                function handleEnterAnimation(animation) {
                    return new Promise(resolve => {
                        const targetEl = document.getElementById(animation.target);
                        if (!targetEl) return resolve();
                        targetEl.classList.remove('anim-slide-out-L', 'anim-slide-out-R');
                        const side = animation.target.includes('-L') ? 'L' : 'R';
                        const animationClass = `anim-slide-in-${side}`;
                        targetEl.classList.add(animationClass);
                        targetEl.addEventListener('animationend', () => {
                            targetEl.classList.remove(animationClass);
                            resolve();
                        }, { once: true });
                    });
                }

                nodecg.listenFor('playAnimation', (animation) => {
                    if (!animation || !animation.type) {
                        console.error('Invalid animation data received:', animation);
                        return;
                    }

                    let promise;
                    switch (animation.type) {
                        case 'SWITCH_POKEMON':
                            promise = handleSwitchAnimation(animation);
                            break;
                        case 'EVOLVE_POKEMON':
                            promise = handleEvolveAnimation(animation);
                            break;
                        case 'DEVOLVE_POKEMON':
                            evolvingSlots.add(animation.target);
                            const isBattleSlot = animation.target.endsWith('0');
                            const videoSrc_devolve = isBattleSlot ? '/assets/ptcg-telop/fx/active-devolve.webm' : '/assets/ptcg-telop/fx/bench-devolve.webm';
                            promise = playVideoOnSlot(animation.target, videoSrc_devolve);
                            break;
                        case 'REPLACE_POKEMON':
                            evolvingSlots.add(animation.target);
                            const isBattleSlot_replace = animation.target.endsWith('0');
                            const videoSrc_replace = isBattleSlot_replace ? '/assets/ptcg-telop/fx/active-replace.webm' : '/assets/ptcg-telop/fx/bench-replace.webm';
                            promise = playVideoOnSlot(animation.target, videoSrc_replace);
                            break;
                        case 'KO_POKEMON':
                            promise = handleKoAnimation(animation);
                            break;
                        case 'EXIT_POKEMON':
                            promise = handleExitAnimation(animation);
                            break;
                        case 'ENTER_POKEMON':
                            promise = handleEnterAnimation(animation);
                            break;
                        default:
                            console.warn('Unknown animation type:', animation.type);
                            promise = Promise.resolve();
                            break;
                    }

                    addAnimationPromise(promise);
                    debouncedOnBatchFinished();
                });

                nodecg.listenFor('attack-fx', (data) => {
                    const promise = new Promise(resolve => {
                        console.log('Received attack-fx:', data);

                        data.targets.forEach(targetInfo => {
                            g_attackAnimationTargets.add(targetInfo.targetId.replace('slot', 'slot-'));
                        });

                        const fxContainer = document.getElementById('attack-fx-container');
                        const videoEl = fxContainer.querySelector('.attack-fx-video');
                        const moveNameEl = fxContainer.querySelector('.attack-fx-move-name');
                        const attackerNameEl = fxContainer.querySelector('.attack-fx-attacker-name');

                        const typeClass = `type-${(data.attackerType || '無').toLowerCase()}`;
                        const animationClass = `animate-${data.attackerSide}`;

                        let hasAnimationEnded = false;
                        const onAnimationEnd = () => {
                            if (hasAnimationEnded) return;
                            hasAnimationEnded = true;

                            const hitPromises = [];

                            data.targets.forEach(targetInfo => {
                                const targetEl = document.getElementById(targetInfo.targetId.replace('slot', 'slot-'));
                                if (!targetEl) return;

                                const isBattleSlot = targetInfo.targetId.endsWith('0');
                                const cardImageSelector = '.card-image-area';
                                const cardImageEl = targetEl.querySelector(cardImageSelector);
                                if (!cardImageEl) return;

                                const imageRect = cardImageEl.getBoundingClientRect();
                                const slotRect = targetEl.getBoundingClientRect();
                                const causedDamage = targetInfo.damage > 0;
                                const isOpponent = data.attackerSide !== targetInfo.targetSide;

                                if (causedDamage) {
                                    const p = new Promise(res => {
                                        setTimeout(() => {
                                            cardImageEl.classList.add('anim-shake', 'anim-flash-white');
                                            setTimeout(() => {
                                                cardImageEl.classList.remove('anim-shake', 'anim-flash-white');
                                                res();
                                            }, 400);
                                        }, 50);
                                    });
                                    hitPromises.push(p);
                                }

                                if (isOpponent || causedDamage) {
                                    const p = new Promise(res => {
                                        const videoSize = isBattleSlot ? 350 : 200;
                                        const hitVideo = document.createElement('video');
                                        hitVideo.className = 'hit-effect';
                                        hitVideo.src = getHitVideoSrc(data.attackerType);
                                        hitVideo.muted = true;
                                        hitVideo.autoplay = true;
                                        hitVideo.style.width = `${videoSize}px`;
                                        hitVideo.style.height = `${videoSize}px`;
                                        // Calculate position relative to parent slot
                                        const relativeLeft = imageRect.left - slotRect.left + (imageRect.width / 2) - (videoSize / 2);
                                        const relativeTop = imageRect.top - slotRect.top + (imageRect.height / 2) - (videoSize / 2);
                                        hitVideo.style.left = `${relativeLeft}px`;
                                        hitVideo.style.top = `${relativeTop}px`;
                                        targetEl.appendChild(hitVideo);
                                        hitVideo.addEventListener('ended', () => {
                                            hitVideo.remove();
                                            res();
                                        });
                                    });
                                    hitPromises.push(p);
                                }
                            });

                            fxContainer.classList.remove('active', animationClass, typeClass);
                            videoEl.removeEventListener('ended', onAnimationEnd);
                            fxContainer.removeEventListener('animationend', onAnimationEnd);
                            g_attackAnimationTargets.clear();

                            // Resolve the main promise only after all hit effects are done
                            Promise.all(hitPromises).then(resolve);
                        };

                        if (settingsRep.value && settingsRep.value.hideAttackName) {
                            onAnimationEnd();
                        } else {
                            moveNameEl.textContent = data.moveName;
                            attackerNameEl.textContent = data.attackerName;

                            fxContainer.className = '';
                            void fxContainer.offsetWidth;
                            fxContainer.classList.add('active', typeClass);
                            fxContainer.classList.add(animationClass);

                            videoEl.currentTime = 0;
                            videoEl.play();

                            videoEl.addEventListener('ended', onAnimationEnd);
                            fxContainer.addEventListener('animationend', (e) => {
                                if (e.target === fxContainer) onAnimationEnd();
                            });

                            setTimeout(onAnimationEnd, 2000); // Safety timeout
                        }

                        data.targets.forEach(targetInfo => {
                            const targetEl = document.getElementById(targetInfo.targetId.replace('slot', 'slot-'));
                            const causedDamage = targetInfo.damage > 0;
                            const isBattleSlot = targetInfo.targetId.endsWith('0');
                            if (causedDamage && targetInfo.isWeakness && isBattleSlot) {
                                activeAnimations.set(targetEl.id, { isWeakness: true });
                            }
                        });
                    });

                    addAnimationPromise(promise);
                    debouncedOnBatchFinished();
                });
            }).catch(err => console.error("Replicants failed to load:", err));
        });
    </script>
    <script>
        // --- New Animation Promise Manager ---
        let animationPromises = [];

        // Debounce function to prevent rapid firing
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }

        // This function will be called after a batch of replicant changes
        const onBatchFinished = () => {
            if (animationPromises.length === 0) {
                // If there were no animations triggered in this batch, we can send the ACK immediately.
                // This is important for data-only changes.
                console.log('Animation batch empty. Sending ACK immediately.');
                nodecg.sendMessage('animationBatchComplete');
                return;
            }

            console.log(`Waiting for ${animationPromises.length} animation(s) to complete...`);

            Promise.all(animationPromises)
                .then(() => {
                    console.log('All animations in batch complete. Sending ACK.');
                    nodecg.sendMessage('animationBatchComplete');
                })
                .catch(err => {
                    console.error('An error occurred in an animation promise:', err);
                    // Still send the ACK to prevent the backend from getting stuck
                    nodecg.sendMessage('animationBatchComplete');
                })
                .finally(() => {
                    // Clear the array for the next batch
                    animationPromises = [];
                });
        };

        // Create a debounced version of the function. The 150ms window should be enough to capture all replicant changes in a single backend batch.
        const debouncedOnBatchFinished = debounce(onBatchFinished, 150);

        // Helper to add promises to the queue
        function addAnimationPromise(promise) {
            if (promise && typeof promise.then === 'function') {
                animationPromises.push(promise);
            }
        }
    </script>
</body>

</html>